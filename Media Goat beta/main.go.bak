// Filename: main.go
package main

import (
	"bufio"
	"bytes"
	"crypto/sha1"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
)

// --- Script Configuration & Globals ---
const Version = "12.3.0-GO-EDITION"

type Config struct {
	Mode          string
	TargetDir     string
	ConcurrentJobs int
	EnableBackups bool
	SortOrder     string
}

// Global state and counters
var (
	logFile       *os.File
	reportFile    string
	resultsDir    string
	tempDir       string
	runStarted    time.Time
	totalFiles    int
	processedCount int
	successCount  int
	failCount     int
	skipCount     int
	resumedCount  int
	totalSaved    int64

	// Terminal Colors
	bold      = color.New(color.Bold).SprintFunc()
	cyan      = color.New(color.FgCyan).SprintFunc()
	green     = color.New(color.FgGreen).SprintFunc()
	yellow    = color.New(color.FgYellow).SprintFunc()
	red       = color.New(color.FgRed).SprintFunc()
	violet    = color.New(color.FgHiMagenta).SprintFunc()
	subtle    = color.New(color.Faint).SprintFunc()
)

// --- Logging ---
func initLogging(cfg Config) {
	logDir := cfg.TargetDir
	timestamp := time.Now().Format("20060102_150405")
	logFileName := filepath.Join(logDir, fmt.Sprintf("%s_conversion_%s.txt", cfg.Mode, timestamp))
	reportFile = filepath.Join(logDir, fmt.Sprintf("%s_conversion_report_%s.txt", cfg.Mode, timestamp))

	var err error
	logFile, err = os.OpenFile(logFileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("æ— æ³•åˆ›å»ºæ—¥å¿—æ–‡ä»¶: %v", err)
	}

	log.SetOutput(logFile)
	log.SetFlags(log.Ldate | log.Ltime)

	// Log header
	header := fmt.Sprintf(`ğŸ“œ åª’ä½“è½¬æ¢æ—¥å¿— - %s
=================================================
  - Go ç‰ˆæœ¬: %s
  - æ¨¡å¼: %s
  - ç›®æ ‡: %s
  - å¹¶å‘: %d
  - å¤‡ä»½: %t
=================================================`,
		time.Now().Format(time.RFC1123), Version, cfg.Mode, cfg.TargetDir, cfg.ConcurrentJobs, cfg.EnableBackups)
	log.Println(header)
	fmt.Fprintln(logFile, header) // Also write directly to file to bypass log prefix
}

func logMessage(level, message string) {
	log.Printf("[%s] %s\n", level, message)
}

// --- Core Utilities ---

// execute command and return output, optionally logging errors
func runCmd(name string, args ...string) (string, error) {
	cmd := exec.Command(name, args...)
	var out, errOut bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errOut

	err := cmd.Run()
	if err != nil {
		errMsg := fmt.Sprintf("å‘½ä»¤æ‰§è¡Œå¤±è´¥: %s %s. é”™è¯¯: %v. Stderr: %s", name, strings.Join(args, " "), err, errOut.String())
		logMessage("ERROR", errMsg)
		return "", fmt.Errorf(errMsg)
	}
	return strings.TrimSpace(out.String()), nil
}

func getFileSize(path string) int64 {
	fi, err := os.Stat(path)
	if err != nil {
		return 0
	}
	return fi.Size()
}

func getMimeType(file string) string {
	// `file` command is more reliable on Linux/macOS
	if runtime.GOOS != "windows" {
		out, err := runCmd("file", "--mime-type", "-b", file)
		if err == nil && !strings.Contains(out, "application/octet-stream") {
			return out
		}
	}
	// Fallback to extension for octet-stream or Windows
	ext := strings.ToLower(filepath.Ext(file))
	switch ext {
	case ".webm", ".mp4", ".avi", ".mov", ".mkv", ".flv", ".wmv", ".m4v":
		return "video/" + strings.TrimPrefix(ext, ".")
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".heic", ".heif", ".jxl", ".avif":
		return "image/" + strings.TrimPrefix(ext, ".")
	default:
		return "unknown"
	}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func createBackup(file, backupDir string, enabled bool) bool {
	if !enabled {
		return true // Pretend success if disabled
	}
	if err := os.MkdirAll(backupDir, 0755); err != nil {
		logMessage("ERROR", fmt.Sprintf("æ— æ³•åˆ›å»ºå¤‡ä»½ç›®å½• %s: %v", backupDir, err))
		return false
	}
	
	base := filepath.Base(file)
	ext := filepath.Ext(base)
	name := strings.TrimSuffix(base, ext)
	backupPath := filepath.Join(backupDir, fmt.Sprintf("%s_%d.bak%s", name, time.Now().Unix(), ext))

	sourceFile, err := os.Open(file)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("æ— æ³•æ‰“å¼€æºæ–‡ä»¶è¿›è¡Œå¤‡ä»½ %s: %v", file, err))
		return false
	}
	defer sourceFile.Close()

	destFile, err := os.Create(backupPath)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("æ— æ³•åˆ›å»ºå¤‡ä»½æ–‡ä»¶ %s: %v", backupPath, err))
		return false
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	if err != nil {
		logMessage("ERROR", fmt.Sprintf("å¤‡ä»½æ–‡ä»¶å¤±è´¥ %s: %v", file, err))
		os.Remove(backupPath)
		return false
	}
	logMessage("INFO", fmt.Sprintf("å·²åˆ›å»ºå¤‡ä»½: %s", backupPath))
	return true
}

func preserveMetadata(src, dst string) {
	// Preserve file modification time
	srcInfo, err := os.Stat(src)
	if err == nil {
		os.Chtimes(dst, srcInfo.ModTime(), srcInfo.ModTime())
	}
	
	// Preserve EXIF data using exiftool
	_, err = runCmd("exiftool", "-TagsFromFile", src, "-all:all", "--icc_profile", "-overwrite_original", "-preserve", dst)
	if err != nil {
		logMessage("WARN", fmt.Sprintf("å…ƒæ•°æ®è¿ç§»å¯èƒ½ä¸å®Œæ•´: %s -> %s", filepath.Base(src), filepath.Base(dst)))
	}
}

func getResultFilePath(filePath string) string {
	hash := sha1.Sum([]byte(filePath))
	return filepath.Join(resultsDir, hex.EncodeToString(hash[:]))
}

// --- Media Analysis ---
func isAnimated(file string) bool {
	mime := getMimeType(file)
	if !strings.Contains(mime, "gif") && !strings.Contains(mime, "webp") && !strings.Contains(mime, "avif") {
		return false
	}
	// ffprobe is the most reliable way to check frame count
	out, err := runCmd("ffprobe", "-v", "quiet", "-select_streams", "v:0", "-show_entries", "stream=nb_frames", "-of", "csv=p=0", file)
	if err != nil {
		return false // Assume not animated on error
	}
	frames, _ := strconv.Atoi(out)
	return frames > 1
}

// A simple heuristic for what to skip
func shouldSkipFile(file string, mode string) (bool, string) {
	base := filepath.Base(file)
	mime := getMimeType(file)

	if !strings.HasPrefix(mime, "image/") && !strings.HasPrefix(mime, "video/") {
		return true, fmt.Sprintf("â­ï¸ è·³è¿‡ä¸æ”¯æŒçš„MIMEç±»å‹: %s (%s)", base, mime)
	}

	targetExt := ""
	if strings.HasPrefix(mime, "image/") {
		if mode == "quality" {
			targetExt = ".jxl"
		} else {
			targetExt = ".avif"
		}
	} else { // video
		targetExt = ".mov"
	}

	if strings.HasSuffix(strings.ToLower(file), targetExt) {
		return true, fmt.Sprintf("æ–‡ä»¶å·²æ˜¯ç›®æ ‡æ ¼å¼: %s", base)
	}
	
	targetFilename := strings.TrimSuffix(file, filepath.Ext(file)) + targetExt
	if fileExists(targetFilename) {
		return true, fmt.Sprintf("â­ï¸ è·³è¿‡ï¼Œç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨: %s", filepath.Base(targetFilename))
	}

	return false, ""
}


// --- Conversion Logic ---

// Represents a conversion attempt
type conversionResult struct {
	FilePath     string
	Tag          string
	Decision     string
	OriginalSize int64
	NewSize      int64
	Error        error
}

// This is the core worker function, equivalent to `process_file` in bash
func processFile(filePath, mode string, cfg Config) conversionResult {
	logMessage("INFO", fmt.Sprintf("å¼€å§‹å¤„ç†: %s (æ¨¡å¼: %s)", filepath.Base(filePath), mode))
	
	result := conversionResult{FilePath: filePath, OriginalSize: getFileSize(filePath)}

	if skip, reason := shouldSkipFile(filePath, mode); skip {
		logMessage("INFO", reason)
		result.Decision = "SKIP"
		return result
	}

	// Create a temporary directory for this file's operations
	fileTempDir, err := os.MkdirTemp(tempDir, "conv_*")
	if err != nil {
		result.Error = fmt.Errorf("æ— æ³•åˆ›å»ºä¸´æ—¶ç›®å½•: %v", err)
		return result
	}
	defer os.RemoveAll(fileTempDir)
	
	mime := getMimeType(filePath)
	var tempOutPath, tag, decision string

	if strings.HasPrefix(mime, "image/") {
		tempOutPath, tag, decision, err = processImage(filePath, fileTempDir, result.OriginalSize, mode)
	} else if strings.HasPrefix(mime, "video/") {
		tempOutPath, tag, decision, err = processVideo(filePath, fileTempDir, mode)
	} else {
		result.Decision = "SKIP"
		logMessage("INFO", fmt.Sprintf("è·³è¿‡æœªçŸ¥ç±»å‹æ–‡ä»¶: %s", filepath.Base(filePath)))
		return result
	}

	if err != nil {
		result.Error = err
		logMessage("ERROR", fmt.Sprintf("æ ¸å¿ƒè½¬æ¢è¿‡ç¨‹å¤±è´¥: %s. åŸå› : %v", filepath.Base(filePath), err))
		return result
	}

	result.NewSize = getFileSize(tempOutPath)
	result.Tag = tag
	result.Decision = decision

	if result.NewSize <= 0 {
		result.Error = fmt.Errorf("è½¬æ¢åæ–‡ä»¶å¤§å°æ— æ•ˆ")
		return result
	}

	// Decide whether to replace the original
	shouldReplace := false
	if mode == "quality" {
		shouldReplace = true // In quality mode, we replace even if larger (e.g., PNG to lossless JXL)
	} else { // efficiency mode
		if result.NewSize < result.OriginalSize {
			shouldReplace = true
		}
	}
	
	if shouldReplace {
		backupDir := filepath.Join(cfg.TargetDir, ".backups")
		if !createBackup(filePath, backupDir, cfg.EnableBackups) {
			result.Error = fmt.Errorf("åˆ›å»ºå¤‡ä»½å¤±è´¥ï¼Œä¸­æ­¢æ›¿æ¢")
			return result
		}

		preserveMetadata(filePath, tempOutPath)
		
		targetPath := strings.TrimSuffix(filePath, filepath.Ext(filePath)) + filepath.Ext(tempOutPath)
		
		if err := os.Rename(tempOutPath, targetPath); err != nil {
			result.Error = fmt.Errorf("æ— æ³•ç§»åŠ¨è½¬æ¢åçš„æ–‡ä»¶: %v", err)
			return result
		}
		
		// If the original file extension is different, remove it
		if strings.ToLower(filePath) != strings.ToLower(targetPath) {
			os.Remove(filePath)
		}

		logMessage("SUCCESS", fmt.Sprintf("%s | %s -> %s | %s", filepath.Base(targetPath), formatBytes(result.OriginalSize), formatBytes(result.NewSize), tag))
	} else {
		result.Decision = "SKIP_LARGER"
		logMessage("WARN", fmt.Sprintf("è½¬æ¢åæ–‡ä»¶å¢å¤§ï¼Œä¸æ›¿æ¢: %s (%s -> %s)", filepath.Base(filePath), formatBytes(result.OriginalSize), formatBytes(result.NewSize)))
	}

	return result
}

func processImage(input, tempDir string, originalSize int64, mode string) (string, string, string, error) {
	isAnim := isAnimated(input)
	
	// In quality mode, we go straight for lossless
	if mode == "quality" {
		ext := "jxl"
		if isAnim {
			ext = "avif"
		}
		losslessPath := filepath.Join(tempDir, "lossless."+ext)
		tag, err := generateLosslessImage(input, losslessPath, isAnim)
		if err != nil {
			return "", "", "", err
		}
		return losslessPath, tag, "QUALITY_LOSSLESS", nil
	}

	// Efficiency mode: smart analysis
	var wg sync.WaitGroup
	var losslessPath, lossyPath string
	var losslessTag, lossyTag string
	var losslessErr, lossyErr error

	wg.Add(2)

	// Attempt lossless conversion in parallel
	go func() {
		defer wg.Done()
		ext := "jxl"
		if isAnim {
			ext = "avif"
		}
		path := filepath.Join(tempDir, "lossless."+ext)
		losslessTag, losslessErr = generateLosslessImage(input, path, isAnim)
		if losslessErr == nil {
			losslessPath = path
		}
	}()

	// Attempt lossy conversion in parallel
	go func() {
		defer wg.Done()
		path := filepath.Join(tempDir, "lossy.avif")
		lossyTag, lossyErr = generateLossyImage(input, path, isAnim, 80) // Start with quality 80
		if lossyErr == nil {
			lossyPath = path
		}
	}()
	
	wg.Wait()

	losslessSize := getFileSize(losslessPath)
	lossySize := getFileSize(lossyPath)
	
	// Smart decision logic
	if losslessSize > 0 && losslessSize < lossySize && float64(losslessSize) < float64(originalSize)*0.8 {
		logMessage("INFO", fmt.Sprintf("æ™ºèƒ½å†³ç­–: æ— æŸ (%s) ä¼˜äºæœ‰æŸ (%s) for %s", formatBytes(losslessSize), formatBytes(lossySize), filepath.Base(input)))
		os.Remove(lossyPath)
		return losslessPath, losslessTag, "SMART_LOSSLESS", nil
	}

	if lossySize > 0 && float64(lossySize) < float64(originalSize)*0.9 {
		logMessage("INFO", fmt.Sprintf("æ™ºèƒ½å†³ç­–: æœ‰æŸ (%s) è¶³å¤Ÿå¥½ for %s", formatBytes(lossySize), filepath.Base(input)))
		os.Remove(losslessPath)
		return lossyPath, lossyTag, "SMART_LOSSY", nil
	}
	
	// If lossy is not good enough, and lossless is not better, maybe original is best.
	// But we must return one if successful. Prioritize the smaller one.
	if lossySize > 0 && (losslessSize == 0 || lossySize < losslessSize) {
		os.Remove(losslessPath)
		return lossyPath, lossyTag, "LOSSY_DEFAULT", nil
	}
	if losslessSize > 0 {
		os.Remove(lossyPath)
		return losslessPath, losslessTag, "LOSSLESS_DEFAULT", nil
	}

	return "", "", "", fmt.Errorf("æ‰€æœ‰å›¾ç‰‡è½¬æ¢å°è¯•å‡å¤±è´¥")
}

func generateLosslessImage(input, output string, isAnim bool) (string, error) {
	if isAnim { // Animated -> Lossless AVIF
		_, err := runCmd("ffmpeg", "-hide_banner", "-v", "error", "-y", "-i", input, "-c:v", "libsvtav1", "-qp", "0", "-preset", "8", "-pix_fmt", "yuv420p", "-f", "avif", output)
		return "AVIF-Lossless", err
	}
	// Static -> Lossless JXL
	_, err := runCmd("cjxl", input, output, "-d", "0", "-e", "9")
	if err != nil {
		// Fallback to ImageMagick if cjxl fails
		_, err = runCmd("magick", input, "-quality", "100", output)
		return "JXL-Lossless(fallback)", err
	}
	return "JXL-Lossless", err
}

func generateLossyImage(input, output string, isAnim bool, quality int) (string, error) {
	qStr := strconv.Itoa(quality)
	if isAnim { // Animated -> AVIF with CRF
		// FFMPEG uses CRF for AV1, let's map quality to a reasonable CRF (30-50 range is good)
		crf := 30 + (100-quality)/4
		_, err := runCmd("ffmpeg", "-hide_banner", "-v", "error", "-y", "-i", input, "-c:v", "libsvtav1", "-crf", strconv.Itoa(crf), "-preset", "7", "-pix_fmt", "yuv420p", "-f", "avif", output)
		return "AVIF-Anim-CRF" + strconv.Itoa(crf), err
	}
	// Static -> AVIF with quality
	_, err := runCmd("magick", input, "-quality", qStr, output)
	return "AVIF-Q" + qStr, err
}


func processVideo(input, tempDir string, mode string) (string, string, string, error) {
    base := filepath.Base(input)
    tempOut := filepath.Join(tempDir, strings.TrimSuffix(base, filepath.Ext(base)) + ".mov")

    var attempts []struct{
        name string
        args []string
        tag  string
    }

    if mode == "quality" {
        attempts = []struct{name string; args []string; tag string}{
            {"HEVC Lossless", []string{"-c:v", "libx265", "-x265-params", "lossless=1", "-c:a", "aac", "-b:a", "192k"}, "HEVC-Quality"},
            {"AV1 Lossless", []string{"-c:v", "libsvtav1", "-qp", "0", "-preset", "8", "-c:a", "copy"}, "AV1-Lossless-Fallback"},
            {"Remux", []string{"-c", "copy", "-map", "0"}, "REMUX-Fallback"},
        }
    } else { // efficiency
        attempts = []struct{name string; args []string; tag string}{
            {"HEVC Lossy", []string{"-c:v", "libx265", "-crf", "28", "-preset", "medium", "-c:a", "aac", "-b:a", "128k"}, "HEVC-CRF28"},
            {"AV1 Lossy", []string{"-c:v", "libsvtav1", "-crf", "35", "-preset", "7", "-c:a", "aac", "-b:a", "128k"}, "AV1-CRF35-Fallback"},
            {"Remux", []string{"-c", "copy", "-map", "0"}, "REMUX-Fallback"},
        }
    }

    commonArgs := []string{"-hide_banner", "-v", "error", "-y", "-i", input}
    finalArgs := []string{"-movflags", "+faststart", "-avoid_negative_ts", "make_zero", tempOut}

    for _, attempt := range attempts {
        logMessage("INFO", fmt.Sprintf("è§†é¢‘å°è¯•: [%s] for %s", attempt.name, base))
        args := append(commonArgs, attempt.args...)
        args = append(args, finalArgs...)
        _, err := runCmd("ffmpeg", args...)
        if err == nil && getFileSize(tempOut) > 0 {
            logMessage("INFO", fmt.Sprintf("è§†é¢‘æˆåŠŸ: [%s]", attempt.name))
            return tempOut, attempt.tag, "VIDEO_CONVERTED", nil
        }
        logMessage("WARN", fmt.Sprintf("è§†é¢‘å¤±è´¥: [%s]. Error: %v", attempt.name, err))
    }

    return "", "", "", fmt.Errorf("æ‰€æœ‰è§†é¢‘è½¬æ¢å°è¯•å‡å¤±è´¥: %s", base)
}


// --- Main Logic & UI ---

func formatBytes(b int64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", float64(b)/float64(div), "KMGTPE"[exp])
}

type FileTask struct {
    Path string
    Size int64
    // for auto mode
    Mode string
}

func main() {
	var cfg Config
	flag.StringVar(&cfg.Mode, "mode", "", "è½¬æ¢æ¨¡å¼: 'quality', 'efficiency', or 'auto'")
	flag.StringVar(&cfg.TargetDir, "dir", "", "ç›®æ ‡ç›®å½•è·¯å¾„")
	flag.IntVar(&cfg.ConcurrentJobs, "jobs", 0, "å¹¶å‘ä»»åŠ¡æ•° (0 for auto)")
	flag.BoolVar(&cfg.EnableBackups, "no-backup", true, "ç¦ç”¨å¤‡ä»½ (è®¾ç½®ä¸ºfalseæ¥ç¦ç”¨)")
	flag.StringVar(&cfg.SortOrder, "sort-by", "size", "å¤„ç†é¡ºåº: 'size' or 'quality'")
	flag.Parse()

	// Invert -no-backup logic
	cfg.EnableBackups = flag.Lookup("no-backup").Value.String() != "true" == !cfg.EnableBackups


	if cfg.TargetDir == "" || cfg.Mode == "" {
		interactiveSetup(&cfg)
	}
	
	if err := validateConfig(cfg); err != nil {
		fmt.Println(red("é”™è¯¯: " + err.Error()))
		os.Exit(1)
	}

	if cfg.ConcurrentJobs == 0 {
		cfg.ConcurrentJobs = int(float64(runtime.NumCPU()) * 0.75)
		if cfg.ConcurrentJobs < 1 {
			cfg.ConcurrentJobs = 1
		}
	}
	
	showBanner()
	fmt.Printf("  %-10s %s\n", "ğŸ“ ç›®æ ‡:", cyan(cfg.TargetDir))
	fmt.Printf("  %-10s %s\n", "ğŸš€ æ¨¡å¼:", cyan(cfg.Mode))
	fmt.Printf("  %-10s %s\n", "âš¡ å¹¶å‘:", cyan(strconv.Itoa(cfg.ConcurrentJobs)))
	fmt.Printf("  %-10s %s\n", "ğŸ›¡ï¸ å¤‡ä»½:", cyan(fmt.Sprintf("%t", cfg.EnableBackups)))
	fmt.Println(subtle("------------------------"))

	var err error
	tempDir, err = os.MkdirTemp("", "media_converter_go")
	if err != nil {
		log.Fatalf("æ— æ³•åˆ›å»ºä¸»ä¸´æ—¶ç›®å½•: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	resultsDir = filepath.Join(cfg.TargetDir, ".media_conversion_results")
	os.MkdirAll(resultsDir, 0755)

	initLogging(cfg)
	defer logFile.Close()

	runStarted = time.Now()
	
	fmt.Println(bold("ğŸ” [1/3] æ‰«æåª’ä½“æ–‡ä»¶å¹¶å»ºç«‹ç´¢å¼•..."))
	tasks, err := findFiles(cfg)
	if err != nil {
		fmt.Println(red("é”™è¯¯: " + err.Error()))
		os.Exit(1)
	}

	totalFiles = len(tasks)
	if totalFiles == 0 {
		fmt.Println(yellow("âš ï¸ æœªå‘ç°éœ€è¦å¤„ç†çš„åª’ä½“æ–‡ä»¶ã€‚"))
		return
	}
	fmt.Printf("  âœ¨ å‘ç° %s ä¸ªå¾…å¤„ç†æ–‡ä»¶ (%s ä¸ªæ–‡ä»¶å·²è·³è¿‡)\n", violet(strconv.Itoa(totalFiles)), violet(strconv.Itoa(resumedCount)))

	fmt.Printf(bold("âš™ï¸ [2/3] å¼€å§‹è½¬æ¢ (å¹¶å‘æ•°: %s)...\n"), cyan(cfg.ConcurrentJobs))
	
	// Worker Pool setup
	jobs := make(chan FileTask, totalFiles)
	results := make(chan conversionResult, totalFiles)
	
	var wg sync.WaitGroup
	for i := 0; i < cfg.ConcurrentJobs; i++ {
		wg.Add(1)
		go worker(&wg, jobs, results, cfg)
	}
	
	for _, task := range tasks {
		jobs <- task
	}
	close(jobs)

	// Progress bar goroutine
	progressDone := make(chan bool)
	go func() {
		for processedCount < totalFiles {
			showProgress(processedCount, totalFiles, "è½¬æ¢ä¸­")
			time.Sleep(200 * time.Millisecond)
		}
		showProgress(totalFiles, totalFiles, "å®Œæˆ")
		progressDone <- true
	}()
	
	// Wait for all workers to finish
	wg.Wait()
	close(results)
	<-progressDone

	fmt.Printf("\n"+bold("ğŸ“Š [3/3] æ­£åœ¨æ±‡æ€»ç»“æœå¹¶ç”ŸæˆæŠ¥å‘Š...\n"))

	var finalResults []conversionResult
	for res := range results {
		processedCount++
		if res.Error != nil {
			failCount++
		} else if res.Decision == "SKIP" || res.Decision == "SKIP_LARGER" {
			skipCount++
		} else {
			successCount++
			totalSaved += (res.OriginalSize - res.NewSize)
		}
		finalResults = append(finalResults, res)
		// Write result file for resuming
		resultFilePath := getResultFilePath(res.FilePath)
		statusLine := fmt.Sprintf("%s|%s|%d|%d", res.Decision, res.Tag, res.OriginalSize, res.NewSize)
		os.WriteFile(resultFilePath, []byte(statusLine), 0644)
	}

	generateReport(cfg, finalResults)
}

func worker(wg *sync.WaitGroup, jobs <-chan FileTask, results chan<- conversionResult, cfg Config) {
	defer wg.Done()
	for task := range jobs {
		mode := cfg.Mode
		if task.Mode != "" { // for auto mode
			mode = task.Mode
		}
		results <- processFile(task.Path, mode, cfg)
	}
}


func findFiles(cfg Config) ([]FileTask, error) {
	var tasks []FileTask
	err := filepath.Walk(cfg.TargetDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// Skip directories and our own special dirs
		if info.IsDir() {
			if info.Name() == ".backups" || info.Name() == ".media_conversion_results" {
				return filepath.SkipDir
			}
			return nil
		}
		
		// Check if already processed
		resultFile := getResultFilePath(path)
		if fileExists(resultFile) {
			resumedCount++
			return nil
		}
		
		tasks = append(tasks, FileTask{Path: path, Size: info.Size()})
		return nil
	})

	if cfg.SortOrder == "size" {
		sort.Slice(tasks, func(i, j int) bool {
			return tasks[i].Size < tasks[j].Size
		})
	}
	// 'quality' sort would need ffprobe analysis here, simplified for now
	
	return tasks, err
}


func validateConfig(cfg Config) error {
	if cfg.TargetDir == "" {
		return fmt.Errorf("ç›®æ ‡ç›®å½•æœªæŒ‡å®š")
	}
	if _, err := os.Stat(cfg.TargetDir); os.IsNotExist(err) {
		return fmt.Errorf("ç›®æ ‡ç›®å½•ä¸å­˜åœ¨: %s", cfg.TargetDir)
	}
	if cfg.Mode != "quality" && cfg.Mode != "efficiency" && cfg.Mode != "auto" {
		return fmt.Errorf("æ— æ•ˆçš„æ¨¡å¼: %s. è¯·é€‰æ‹© 'quality', 'efficiency', or 'auto'", cfg.Mode)
	}
	return nil
}

func interactiveSetup(cfg *Config) {
	reader := bufio.NewReader(os.Stdin)
	
	showBanner()

	// Get target directory
	for {
		fmt.Print(bold(cyan("ğŸ“‚ è¯·è¾“å…¥æˆ–æ‹–å…¥ç›®æ ‡æ–‡ä»¶å¤¹, ç„¶åæŒ‰ Enter: ")))
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		// Clean path from drag-and-drop (remove quotes, etc.)
		input = strings.Trim(input, `"'`)
		if _, err := os.Stat(input); err == nil {
			cfg.TargetDir, _ = filepath.Abs(input)
			break
		}
		fmt.Println(yellow("âš ï¸ æ— æ•ˆçš„ç›®å½•ï¼Œè¯·é‡æ–°è¾“å…¥ã€‚"))
	}

	// Get mode
	fmt.Println("\n" + bold(cyan("âš™ï¸ è¯·é€‰æ‹©è½¬æ¢æ¨¡å¼: ")))
	fmt.Printf("  %s %s - è¿½æ±‚æè‡´ç”»è´¨ï¼Œé€‚åˆå­˜æ¡£ã€‚\n", green("[1]"), bold("è´¨é‡æ¨¡å¼ (Quality)"))
	fmt.Printf("  %s %s - å¹³è¡¡ç”»è´¨ä¸ä½“ç§¯ï¼Œé€‚åˆæ—¥å¸¸ã€‚\n", yellow("[2]"), bold("æ•ˆç‡æ¨¡å¼ (Efficiency)"))
	fmt.Printf("  %s %s - %s\n", violet("[3]"), bold("è‡ªåŠ¨æ¨¡å¼ (Auto)"), bold(subtle("å¼ºçƒˆæ¨è!")))
	
	for {
		fmt.Print(bold(cyan("ğŸ‘‰ è¯·è¾“å…¥æ‚¨çš„é€‰æ‹© (1/2/3) [å›è½¦é»˜è®¤ 3]: ")))
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		if input == "" || input == "3" {
			cfg.Mode = "auto"
			break
		}
		if input == "1" {
			cfg.Mode = "quality"
			break
		}
		if input == "2" {
			cfg.Mode = "efficiency"
			break
		}
	}
}

func showBanner() {
	color.Cyan(`
         __  __          __           _       ____                          __
        / / / /___ _____/ /___  _    (_)___  / __ \____ _      _____  _____/ /
       / /_/ / __ ` + "`" + `/ __  / __ \| |   / / __ \/ / / / __ \ | /| / / _ \/ ___/ / 
      / __  / /_/ / /_/ / /_/ /| |  / / /_/ / /_/ / /_/ / |/ |/ /  __/ /  /_/  
     /_/ /_/\__,_/\__,_/\____/ |___/ /\____/_____/\____/|__/|__/\___/_/  (_)   
                               /___/                                         
	`)
	fmt.Printf(bold(violet("              âœ¨ æ¬¢è¿ä½¿ç”¨åª’ä½“æ‰¹é‡è½¬æ¢è„šæœ¬ v%s âœ¨\n")), Version)
	fmt.Println(subtle("                  Go è¯­è¨€é‡æ„ç‰ˆ - ç¨³å®šã€é«˜æ•ˆã€è·¨å¹³å°"))
	fmt.Println("================================================================================\n")
}

func showProgress(current, total int, taskName string) {
	if total == 0 {
		return
	}
	pct := float64(current) / float64(total) * 100
	barWidth := 40
	filledWidth := int(float64(barWidth) * float64(current) / float64(total))
	
	bar := strings.Repeat("â–ˆ", filledWidth) + strings.Repeat("â–‘", barWidth-filledWidth)
	
	fmt.Printf("\r%s [%s] %.0f%% (%d/%d)", taskName, cyan(bar), pct, current, total)
}


func generateReport(cfg Config, results []conversionResult) {
	var report strings.Builder

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("ğŸ“Š ================= åª’ä½“è½¬æ¢æœ€ç»ˆæŠ¥å‘Š =================="))))
	report.WriteString(fmt.Sprintf("%s %s\n", subtle("ğŸ“ ç›®å½•:"), cfg.TargetDir))
	report.WriteString(fmt.Sprintf("%s %s    %s %s\n", subtle("âš™ï¸ æ¨¡å¼:"), cfg.Mode, subtle("ğŸš€ Go ç‰ˆæœ¬:"), Version))
	report.WriteString(fmt.Sprintf("%s %s\n\n", subtle("â° å®Œæˆ:"), time.Now().Format(time.RFC1123)))
	
	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- ğŸ“‹ æ¦‚è§ˆ ---"))))
	report.WriteString(fmt.Sprintf("  %s æ€»è®¡æ‰«æ: %d æ–‡ä»¶\n", violet("ğŸ—‚ï¸"), totalFiles+resumedCount))
	report.WriteString(fmt.Sprintf("  %s æˆåŠŸè½¬æ¢: %d\n", green("âœ…"), successCount))
	report.WriteString(fmt.Sprintf("  %s è½¬æ¢å¤±è´¥: %d\n", red("âŒ"), failCount))
	report.WriteString(fmt.Sprintf("  %s ä¸»åŠ¨è·³è¿‡: %d\n", subtle("â­ï¸"), skipCount))
	report.WriteString(fmt.Sprintf("  %s æ–­ç‚¹ç»­ä¼ : %d (å·²å¤„ç†)\n\n", cyan("ğŸ”„"), resumedCount))

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- ğŸ’¾ å¤§å°å˜åŒ–ç»Ÿè®¡ ---"))))
	report.WriteString(fmt.Sprintf("  %s æ€»ç©ºé—´èŠ‚çœ: %s\n\n", green("ğŸ’°"), bold(green(formatBytes(totalSaved)))))

	report.WriteString(fmt.Sprintf("%s\n", bold(cyan("--- ğŸ… ç¼–ç è´¨é‡åˆ†å¸ƒ ---"))))
	qualitySummary := make(map[string]int)
	for _, res := range results {
		if res.Tag != "" {
			qualitySummary[res.Tag]++
		}
	}
	for tag, count := range qualitySummary {
		report.WriteString(fmt.Sprintf("  %s(%d) ", tag, count))
	}
	report.WriteString("\n\n")

	report.WriteString("--------------------------------------------------------\n")
	report.WriteString(fmt.Sprintf("%s %s\n", subtle("ğŸ“„ è¯¦ç»†æ—¥å¿—:"), logFile.Name()))
	
	failedFiles := []string{}
	for _, res := range results {
		if res.Error != nil {
			failedFiles = append(failedFiles, fmt.Sprintf("  â€¢ %s (é”™è¯¯: %v)", filepath.Base(res.FilePath), res.Error))
		}
	}
	if len(failedFiles) > 0 {
		report.WriteString(fmt.Sprintf("\n%s\n", red(bold("âŒ å¤±è´¥æ–‡ä»¶åˆ—è¡¨:"))))
		report.WriteString(strings.Join(failedFiles, "\n"))
	}
	
	// Print to console and write to file
	fmt.Println("\n" + report.String())
	os.WriteFile(reportFile, []byte(report.String()), 0644)
}