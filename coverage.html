
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>converter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pixly/core/converter/advanced_pool.go (27.2%)</option>
				
				<option value="file1">pixly/core/converter/atomic_ops.go (0.8%)</option>
				
				<option value="file2">pixly/core/converter/batch_processor.go (0.0%)</option>
				
				<option value="file3">pixly/core/converter/checkpoint.go (10.4%)</option>
				
				<option value="file4">pixly/core/converter/conversion_framework.go (0.0%)</option>
				
				<option value="file5">pixly/core/converter/converter.go (7.3%)</option>
				
				<option value="file6">pixly/core/converter/error_handler.go (1.7%)</option>
				
				<option value="file7">pixly/core/converter/file_type_detector.go (1.2%)</option>
				
				<option value="file8">pixly/core/converter/image.go (0.0%)</option>
				
				<option value="file9">pixly/core/converter/memory_pool.go (12.3%)</option>
				
				<option value="file10">pixly/core/converter/metadata.go (0.6%)</option>
				
				<option value="file11">pixly/core/converter/path_security.go (0.0%)</option>
				
				<option value="file12">pixly/core/converter/path_utils.go (13.6%)</option>
				
				<option value="file13">pixly/core/converter/performance_optimizer.go (0.0%)</option>
				
				<option value="file14">pixly/core/converter/report.go (0.0%)</option>
				
				<option value="file15">pixly/core/converter/signal_handler.go (26.2%)</option>
				
				<option value="file16">pixly/core/converter/strategy.go (6.7%)</option>
				
				<option value="file17">pixly/core/converter/task_monitor.go (17.0%)</option>
				
				<option value="file18">pixly/core/converter/tool_manager.go (13.1%)</option>
				
				<option value="file19">pixly/core/converter/video.go (0.0%)</option>
				
				<option value="file20">pixly/core/converter/watchdog.go (15.1%)</option>
				
				<option value="file21">pixly/core/converter/worker_pool.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package converter

import (
        "context"
        "errors"
        "fmt"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        "github.com/panjf2000/ants/v2"
        "go.uber.org/zap"
)

// TaskPriority 任务优先级枚举
type TaskPriority int

const (
        PriorityLow      TaskPriority = iota // 低优先级
        PriorityNormal                       // 普通优先级
        PriorityHigh                         // 高优先级
        PriorityCritical                     // 关键优先级
)

// PriorityTask 带优先级的任务
type PriorityTask struct {
        Task     func()       // 任务函数
        Priority TaskPriority // 任务优先级
        ID       string       // 任务ID
        Created  time.Time    // 创建时间
}

// PoolMetrics 池监控指标
type PoolMetrics struct {
        ActiveWorkers   int32         // 活跃工作者数量
        QueuedTasks     int32         // 排队任务数量
        CompletedTasks  int64         // 已完成任务数量
        FailedTasks     int64         // 失败任务数量
        TotalTasks      int64         // 总任务数量
        AverageWaitTime time.Duration // 平均等待时间
        AverageExecTime time.Duration // 平均执行时间
        LastUpdate      time.Time     // 最后更新时间
}

// AdvancedPoolConfig 高级池配置
type AdvancedPoolConfig struct {
        InitialSize        int           // 初始池大小
        MinSize            int           // 最小池大小
        MaxSize            int           // 最大池大小
        ScaleUpThreshold   float64       // 扩容阈值（队列长度/池大小）
        ScaleDownThreshold float64       // 缩容阈值
        ScaleInterval      time.Duration // 调整间隔
        IdleTimeout        time.Duration // 空闲超时
        EnablePriority     bool          // 是否启用优先级
        EnableMetrics      bool          // 是否启用监控

        // 新增：队列与提交的稳态化配置
        QueueCapacityMultiplier int           // 优先级队列容量倍率（相对于 MaxSize）
        EnqueueTimeout          time.Duration // 入队最大等待时长，超时则回退到 ants
        EnqueueRetryInterval    time.Duration // 入队重试间隔
        AntsMaxBlockingTasks    int           // ants 最大阻塞提交数上限（避免 ErrPoolOverload）
        AntsSubmitRetry         int           // ants 提交出错重试次数
        AntsSubmitBackoff       time.Duration // ants 提交重试退避基准
}

// GetDefaultAdvancedPoolConfig 获取默认高级池配置
func GetDefaultAdvancedPoolConfig() *AdvancedPoolConfig <span class="cov8" title="1">{
        // 计算合适的队列大小，确保能处理大量文件
        maxSize := runtime.NumCPU() * 16 // 增加到16倍CPU核心数
        if maxSize &lt; 128 </span><span class="cov0" title="0">{
                maxSize = 128 // 最小保证128个队列槽位
        }</span>

        <span class="cov8" title="1">return &amp;AdvancedPoolConfig{
                InitialSize:             runtime.NumCPU(),
                MinSize:                 2,
                MaxSize:                 maxSize,
                ScaleUpThreshold:        0.8,                 // 当队列长度达到池大小的80%时扩容
                ScaleDownThreshold:      0.2,                 // 当队列长度低于池大小的20%时缩容
                ScaleInterval:           time.Second * 30,
                IdleTimeout:             time.Minute * 10,
                EnablePriority:          true,
                EnableMetrics:           true,
                QueueCapacityMultiplier: 8,                   // 优先级队列容量扩大到 MaxSize*8
                EnqueueTimeout:          200 * time.Millisecond,
                EnqueueRetryInterval:    2 * time.Millisecond,
                AntsMaxBlockingTasks:    maxSize * 16,        // 允许大量提交在 ants 层等待
                AntsSubmitRetry:         3,
                AntsSubmitBackoff:       20 * time.Millisecond,
        }</span>
}

// AdvancedPool 高级ants池管理器
type AdvancedPool struct {
        config  *AdvancedPoolConfig
        logger  *zap.Logger
        pool    *ants.Pool
        metrics *PoolMetrics
        ctx     context.Context
        cancel  context.CancelFunc
        mutex   sync.RWMutex

        // 优先级队列
        priorityQueues map[TaskPriority]chan *PriorityTask
        queueMutex     sync.RWMutex

        // 监控相关
        monitorTicker *time.Ticker
        scaleTicker   *time.Ticker
        logCounter    int32 // 日志输出计数器

        // 统计信息
        taskWaitTimes []time.Duration
        taskExecTimes []time.Duration
        timesMutex    sync.Mutex

        // 任务监控
        taskMonitor *TaskMonitor
}

// NewAdvancedPool 创建新的高级池
func NewAdvancedPool(config *AdvancedPoolConfig, logger *zap.Logger) (*AdvancedPool, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = GetDefaultAdvancedPoolConfig()
        }</span>

        // 验证配置参数
        <span class="cov8" title="1">if config.InitialSize &lt;= 0 </span><span class="cov0" title="0">{
                logger.Warn("InitialSize无效，使用默认值", zap.Int("provided", config.InitialSize))
                config.InitialSize = runtime.NumCPU()
                if config.InitialSize &lt;= 0 </span><span class="cov0" title="0">{
                        config.InitialSize = 1
                }</span>
        }
        <span class="cov8" title="1">if config.MaxSize &lt;= 0 </span><span class="cov0" title="0">{
                logger.Warn("MaxSize无效，使用默认值", zap.Int("provided", config.MaxSize))
                config.MaxSize = runtime.NumCPU() * 16
                if config.MaxSize &lt; 128 </span><span class="cov0" title="0">{
                        config.MaxSize = 128
                }</span>
        }
        <span class="cov8" title="1">if config.MinSize &lt;= 0 </span><span class="cov0" title="0">{
                config.MinSize = 1
        }</span>
        // 确保InitialSize在合理范围内
        <span class="cov8" title="1">if config.InitialSize &gt; config.MaxSize </span><span class="cov0" title="0">{
                config.InitialSize = config.MaxSize
        }</span>
        <span class="cov8" title="1">if config.InitialSize &lt; config.MinSize </span><span class="cov0" title="0">{
                config.InitialSize = config.MinSize
        }</span>

        // 合理化新增配置
        <span class="cov8" title="1">if config.QueueCapacityMultiplier &lt;= 0 </span><span class="cov0" title="0">{
                config.QueueCapacityMultiplier = 8
        }</span>
        <span class="cov8" title="1">if config.EnqueueTimeout &lt;= 0 </span><span class="cov0" title="0">{
                config.EnqueueTimeout = 200 * time.Millisecond
        }</span>
        <span class="cov8" title="1">if config.EnqueueRetryInterval &lt;= 0 </span><span class="cov0" title="0">{
                config.EnqueueRetryInterval = 2 * time.Millisecond
        }</span>
        <span class="cov8" title="1">if config.AntsMaxBlockingTasks &lt;= 0 </span><span class="cov0" title="0">{
                config.AntsMaxBlockingTasks = config.MaxSize * 16
        }</span>
        <span class="cov8" title="1">if config.AntsSubmitRetry &lt; 0 </span><span class="cov0" title="0">{
                config.AntsSubmitRetry = 0
        }</span>
        <span class="cov8" title="1">if config.AntsSubmitBackoff &lt;= 0 </span><span class="cov0" title="0">{
                config.AntsSubmitBackoff = 20 * time.Millisecond
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())

        // 创建基础ants池
        pool, err := ants.NewPool(config.InitialSize, ants.WithOptions(ants.Options{
                ExpiryDuration:   config.IdleTimeout,
                PreAlloc:         true,
                MaxBlockingTasks: config.AntsMaxBlockingTasks,
                Nonblocking:      false,
                PanicHandler: func(p interface{}) </span><span class="cov0" title="0">{
                        logger.Error("ants池中的goroutine发生panic", zap.Any("panic", p))
                }</span>,
        }))
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建ants池失败: %w", err)
        }</span>

        // 创建任务监控器
        <span class="cov8" title="1">taskMonitor := NewTaskMonitor(logger)

        ap := &amp;AdvancedPool{
                config:      config,
                logger:      logger,
                pool:        pool,
                metrics:     &amp;PoolMetrics{LastUpdate: time.Now()},
                ctx:         ctx,
                cancel:      cancel,
                taskMonitor: taskMonitor,
        }

        // 初始化优先级队列
        if config.EnablePriority </span><span class="cov8" title="1">{
                ap.priorityQueues = make(map[TaskPriority]chan *PriorityTask)
                // 计算队列容量（放大，缓冲高峰流量）
                capSize := config.MaxSize * config.QueueCapacityMultiplier
                if capSize &lt; config.MaxSize </span><span class="cov0" title="0">{
                        capSize = config.MaxSize
                }</span>
                <span class="cov8" title="1">for priority := PriorityCritical; priority &gt;= PriorityLow; priority-- </span><span class="cov8" title="1">{
                        ap.priorityQueues[priority] = make(chan *PriorityTask, capSize)
                }</span>
                // 启动优先级任务调度器
                <span class="cov8" title="1">go ap.priorityScheduler()</span>
        }

        // 启动任务监控器
        <span class="cov8" title="1">if err := ap.taskMonitor.Start(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("启动任务监控器失败: %w", err)
        }</span>

        // 设置监控器的工作器信息
        <span class="cov8" title="1">ap.taskMonitor.SetMaxWorkers(int32(config.InitialSize))

        // 启动监控
        if config.EnableMetrics </span><span class="cov8" title="1">{
                ap.monitorTicker = time.NewTicker(time.Second * 5)
                go ap.monitor()
        }</span>

        // 启动动态调整
        <span class="cov8" title="1">ap.scaleTicker = time.NewTicker(config.ScaleInterval)
        go ap.autoScale()

        // 高级ants池已启动

        return ap, nil</span>
}

// Submit 提交普通任务
func (ap *AdvancedPool) Submit(task func()) error <span class="cov0" title="0">{
        return ap.SubmitWithPriority(task, PriorityNormal, "")
}</span>

// SubmitTask 提交任务到池中
func (ap *AdvancedPool) SubmitTask(task PriorityTask) error <span class="cov0" title="0">{
        // 在任务监控器中注册任务
        ap.taskMonitor.RegisterTask(
                task.ID,
                "", // filePath - 从PriorityTask结构体中没有这个字段
                0,  // fileSize - 从PriorityTask结构体中没有这个字段
                task.Priority,
        )

        // 更新任务状态为排队
        if err := ap.taskMonitor.UpdateTaskState(task.ID, TaskStateQueued); err != nil </span><span class="cov0" title="0">{
                ap.logger.Warn("更新任务状态失败", zap.Error(err))
        }</span>

        // 使用现有的SubmitWithPriority方法
        <span class="cov0" title="0">err := ap.SubmitWithPriority(task.Task, task.Priority, task.ID)
        if err != nil </span><span class="cov0" title="0">{
                // 更新任务状态为失败
                ap.taskMonitor.UpdateTaskState(task.ID, TaskStateFailed, err.Error())
                return err
        }</span>

        // 任务已提交到队列
        <span class="cov0" title="0">return nil</span>
}

// SubmitWithPriority 提交带优先级的任务
func (ap *AdvancedPool) SubmitWithPriority(task func(), priority TaskPriority, taskID string) error <span class="cov0" title="0">{
        if ap.config.EnablePriority </span><span class="cov0" title="0">{
                priorityTask := &amp;PriorityTask{
                        Task:     task,
                        Priority: priority,
                        ID:       taskID,
                        Created:  time.Now(),
                }

                // 尝试在限定时间内入队，缓解瞬时高峰导致的“队列已满”
                deadline := time.Now().Add(ap.config.EnqueueTimeout)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case ap.priorityQueues[priority] &lt;- priorityTask:<span class="cov0" title="0">
                                atomic.AddInt32(&amp;ap.metrics.QueuedTasks, 1)
                                atomic.AddInt64(&amp;ap.metrics.TotalTasks, 1)
                                return nil</span>
                        case &lt;-ap.ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("池已关闭")</span>
                        default:<span class="cov0" title="0">
                                if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                        // 超时，回退到直接提交ants池
                                        ap.logger.Debug("优先级队列繁忙，回退到直接提交",
                                                zap.String("taskID", taskID),
                                                zap.Int("priority", int(priority)))
                                        return ap.submitToAnts(task, taskID)
                                }</span>
                                <span class="cov0" title="0">time.Sleep(ap.config.EnqueueRetryInterval)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // 直接提交到ants池
                return ap.submitToAnts(task, taskID)
        }</span>
}

// submitToAnts 提交任务到ants池
func (ap *AdvancedPool) submitToAnts(task func(), taskID string) error <span class="cov0" title="0">{
        startTime := time.Now()
        atomic.AddInt64(&amp;ap.metrics.TotalTasks, 1)

        // 更新任务状态为运行中
        if taskID != "" </span><span class="cov0" title="0">{
                if err := ap.taskMonitor.UpdateTaskState(taskID, TaskStateRunning); err != nil </span><span class="cov0" title="0">{
                        ap.logger.Warn("更新任务状态失败", zap.Error(err))
                }</span>
        }

        // 简化重试逻辑，只重试一次以减少延迟
        <span class="cov0" title="0">err := ap.pool.Submit(func() </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;ap.metrics.ActiveWorkers, 1)
                defer atomic.AddInt32(&amp;ap.metrics.ActiveWorkers, -1)

                execStart := time.Now()
                waitTime := execStart.Sub(startTime)

                // 执行任务
                taskErr := func() (err error) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        atomic.AddInt64(&amp;ap.metrics.FailedTasks, 1)
                                        err = fmt.Errorf("任务执行panic: %v", r)
                                        ap.logger.Error("任务执行panic", zap.String("taskID", taskID), zap.Any("panic", r))
                                }</span>
                        }()
                        <span class="cov0" title="0">task()
                        return nil</span>
                }()

                <span class="cov0" title="0">execTime := time.Since(execStart)

                // 更新任务状态
                if taskID != "" </span><span class="cov0" title="0">{
                        if taskErr != nil </span><span class="cov0" title="0">{
                                ap.taskMonitor.UpdateTaskState(taskID, TaskStateFailed, taskErr.Error())
                        }</span> else<span class="cov0" title="0"> {
                                ap.taskMonitor.UpdateTaskState(taskID, TaskStateCompleted)
                                atomic.AddInt64(&amp;ap.metrics.CompletedTasks, 1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if taskErr == nil </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;ap.metrics.CompletedTasks, 1)
                        }</span>
                }

                // 记录时间统计
                <span class="cov0" title="0">if ap.config.EnableMetrics </span><span class="cov0" title="0">{
                        ap.timesMutex.Lock()
                        ap.taskWaitTimes = append(ap.taskWaitTimes, waitTime)
                        ap.taskExecTimes = append(ap.taskExecTimes, execTime)
                        // 保持最近1000个记录
                        if len(ap.taskWaitTimes) &gt; 1000 </span><span class="cov0" title="0">{
                                ap.taskWaitTimes = ap.taskWaitTimes[len(ap.taskWaitTimes)-1000:]
                        }</span>
                        <span class="cov0" title="0">if len(ap.taskExecTimes) &gt; 1000 </span><span class="cov0" title="0">{
                                ap.taskExecTimes = ap.taskExecTimes[len(ap.taskExecTimes)-1000:]
                        }</span>
                        <span class="cov0" title="0">ap.timesMutex.Unlock()</span>
                }
        })

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 如果是池过载错误，再尝试一次
        <span class="cov0" title="0">if errors.Is(err, ants.ErrPoolOverload) </span><span class="cov0" title="0">{
                time.Sleep(ap.config.AntsSubmitBackoff)
                err = ap.pool.Submit(func() </span><span class="cov0" title="0">{
                        atomic.AddInt32(&amp;ap.metrics.ActiveWorkers, 1)
                        defer atomic.AddInt32(&amp;ap.metrics.ActiveWorkers, -1)
                        // 执行任务
                        taskErr := func() (err error) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                atomic.AddInt64(&amp;ap.metrics.FailedTasks, 1)
                                                err = fmt.Errorf("任务执行panic: %v", r)
                                                ap.logger.Error("任务执行panic", zap.String("taskID", taskID), zap.Any("panic", r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">task()
                                return nil</span>
                        }()
                        // 更新任务状态
                        <span class="cov0" title="0">if taskID != "" </span><span class="cov0" title="0">{
                                if taskErr != nil </span><span class="cov0" title="0">{
                                        ap.taskMonitor.UpdateTaskState(taskID, TaskStateFailed, taskErr.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        ap.taskMonitor.UpdateTaskState(taskID, TaskStateCompleted)
                                        atomic.AddInt64(&amp;ap.metrics.CompletedTasks, 1)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if taskErr == nil </span><span class="cov0" title="0">{
                                        atomic.AddInt64(&amp;ap.metrics.CompletedTasks, 1)
                                }</span>
                        }
                })
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;ap.metrics.FailedTasks, 1)
                // 更新任务状态为失败
                if taskID != "" </span><span class="cov0" title="0">{
                        ap.taskMonitor.UpdateTaskState(taskID, TaskStateFailed, err.Error())
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

// priorityScheduler 优先级任务调度器
func (ap *AdvancedPool) priorityScheduler() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span>{<span class="cov0" title="0">
                        // 优先级调度器已安全退出
                }</span>
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ap.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        // 按优先级顺序处理任务
                        processed := false
                PriorityLoop:
                        for priority := PriorityCritical; priority &gt;= PriorityLow; priority-- </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ap.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case task, ok := &lt;-ap.priorityQueues[priority]:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                // channel已关闭
                                                return
                                        }</span>
                                        <span class="cov0" title="0">atomic.AddInt32(&amp;ap.metrics.QueuedTasks, -1)

                                        // 提交到ants池
                                        err := ap.submitToAnts(task.Task, task.ID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                ap.logger.Error("提交优先级任务失败",
                                                        zap.String("taskID", task.ID),
                                                        zap.Int("priority", int(task.Priority)),
                                                        zap.Error(err))
                                                // 重新入队（降低优先级）
                                                if task.Priority &gt; PriorityLow </span><span class="cov0" title="0">{
                                                        task.Priority--
                                                        select </span>{
                                                        case ap.priorityQueues[task.Priority] &lt;- task:<span class="cov0" title="0"></span>
                                                        case &lt;-ap.ctx.Done():<span class="cov0" title="0">
                                                                return</span>
                                                        default:<span class="cov0" title="0">
                                                                // 队列满，丢弃任务
                                                                atomic.AddInt64(&amp;ap.metrics.FailedTasks, 1)</span>
                                                        }
                                                }
                                        } else <span class="cov0" title="0">{
                                                // 优先级任务已提交
                                        }</span>
                                        <span class="cov0" title="0">processed = true
                                        break PriorityLoop</span>
                                default:<span class="cov8" title="1"></span>
                                        // 该优先级队列为空，检查下一个
                                }
                        }

                        // 如果没有处理任何任务，短暂休眠避免CPU占用过高
                        <span class="cov8" title="1">if !processed </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ap.ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                case &lt;-time.After(time.Millisecond * 10):<span class="cov8" title="1"></span>
                                        // 继续下一轮循环
                                }
                        }
                }
        }
}

// monitor 监控池状态
func (ap *AdvancedPool) monitor() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ap.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ap.monitorTicker.C:<span class="cov0" title="0">
                        ap.updateMetrics()
                        ap.logMetrics()</span>
                }
        }
}

// updateMetrics 更新监控指标
func (ap *AdvancedPool) updateMetrics() <span class="cov0" title="0">{
        ap.mutex.Lock()
        defer ap.mutex.Unlock()

        // 计算平均时间
        ap.timesMutex.Lock()
        if len(ap.taskWaitTimes) &gt; 0 </span><span class="cov0" title="0">{
                var totalWait time.Duration
                for _, wait := range ap.taskWaitTimes </span><span class="cov0" title="0">{
                        totalWait += wait
                }</span>
                <span class="cov0" title="0">ap.metrics.AverageWaitTime = totalWait / time.Duration(len(ap.taskWaitTimes))</span>
        }

        <span class="cov0" title="0">if len(ap.taskExecTimes) &gt; 0 </span><span class="cov0" title="0">{
                var totalExec time.Duration
                for _, exec := range ap.taskExecTimes </span><span class="cov0" title="0">{
                        totalExec += exec
                }</span>
                <span class="cov0" title="0">ap.metrics.AverageExecTime = totalExec / time.Duration(len(ap.taskExecTimes))</span>
        }
        <span class="cov0" title="0">ap.timesMutex.Unlock()

        ap.metrics.LastUpdate = time.Now()</span>
}

// logMetrics 记录监控指标
func (ap *AdvancedPool) logMetrics() <span class="cov0" title="0">{
        // 减少日志输出频率，每10次监控周期才输出一次
        counter := atomic.AddInt32(&amp;ap.logCounter, 1)
        if counter%10 == 0 </span>{<span class="cov0" title="0">
                // 池监控指标已记录
        }</span>
}

// autoScale 自动调整池大小
func (ap *AdvancedPool) autoScale() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ap.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ap.scaleTicker.C:<span class="cov0" title="0">
                        ap.performAutoScale()</span>
                }
        }
}

// performAutoScale 执行自动调整
func (ap *AdvancedPool) performAutoScale() <span class="cov0" title="0">{
        currentSize := ap.pool.Cap()
        queuedTasks := atomic.LoadInt32(&amp;ap.metrics.QueuedTasks)
        queueRatio := float64(queuedTasks) / float64(currentSize)

        // 扩容逻辑
        if queueRatio &gt; ap.config.ScaleUpThreshold &amp;&amp; currentSize &lt; ap.config.MaxSize </span><span class="cov0" title="0">{
                newSize := currentSize + (currentSize / 4) // 增加25%
                if newSize &gt; ap.config.MaxSize </span><span class="cov0" title="0">{
                        newSize = ap.config.MaxSize
                }</span>
                <span class="cov0" title="0">if newSize &gt; currentSize </span><span class="cov0" title="0">{
                        ap.pool.Tune(newSize)
                        // 池扩容完成
                }</span>
        }

        // 缩容逻辑
        <span class="cov0" title="0">if queueRatio &lt; ap.config.ScaleDownThreshold &amp;&amp; currentSize &gt; ap.config.MinSize </span><span class="cov0" title="0">{
                newSize := currentSize - (currentSize / 4) // 减少25%
                if newSize &lt; ap.config.MinSize </span><span class="cov0" title="0">{
                        newSize = ap.config.MinSize
                }</span>
                <span class="cov0" title="0">if newSize &lt; currentSize </span><span class="cov0" title="0">{
                        ap.pool.Tune(newSize)
                        // 池缩容完成
                }</span>
        }
}

// GetMetrics 获取监控指标
func (ap *AdvancedPool) GetMetrics() *PoolMetrics <span class="cov0" title="0">{
        ap.mutex.RLock()
        defer ap.mutex.RUnlock()

        // 从任务监控器获取详细指标
        if ap.taskMonitor != nil </span><span class="cov0" title="0">{
                taskMetrics := ap.taskMonitor.GetMetrics()

                // 同步任务计数
                ap.metrics.CompletedTasks = taskMetrics.CompletedTasks
                ap.metrics.FailedTasks = taskMetrics.FailedTasks
                ap.metrics.TotalTasks = taskMetrics.TotalTasks
                ap.metrics.AverageWaitTime = taskMetrics.AverageWaitTime
                ap.metrics.AverageExecTime = taskMetrics.AverageProcessingTime
        }</span>

        // 返回指标副本
        <span class="cov0" title="0">metrics := *ap.metrics
        return &amp;metrics</span>
}

// GetPoolInfo 获取池信息
func (ap *AdvancedPool) GetPoolInfo() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "capacity":       ap.pool.Cap(),
                "running":        ap.pool.Running(),
                "free":           ap.pool.Free(),
                "activeWorkers":  atomic.LoadInt32(&amp;ap.metrics.ActiveWorkers),
                "queuedTasks":    atomic.LoadInt32(&amp;ap.metrics.QueuedTasks),
                "completedTasks": atomic.LoadInt64(&amp;ap.metrics.CompletedTasks),
                "failedTasks":    atomic.LoadInt64(&amp;ap.metrics.FailedTasks),
                "totalTasks":     atomic.LoadInt64(&amp;ap.metrics.TotalTasks),
        }
}</span>

// Tune 手动调整池大小
func (ap *AdvancedPool) Tune(size int) <span class="cov0" title="0">{
        if size &lt; ap.config.MinSize </span><span class="cov0" title="0">{
                size = ap.config.MinSize
        }</span>
        <span class="cov0" title="0">if size &gt; ap.config.MaxSize </span><span class="cov0" title="0">{
                size = ap.config.MaxSize
        }</span>
        <span class="cov0" title="0">ap.pool.Tune(size)</span>
        // 手动调整池大小完成
}

// Close 关闭池
func (ap *AdvancedPool) Close() error <span class="cov8" title="1">{
        // 首先取消context，通知所有goroutine退出
        ap.cancel()

        // 给goroutine一些时间优雅退出
        time.Sleep(100 * time.Millisecond)

        // 停止任务监控器
        ap.taskMonitor.Stop()

        if ap.monitorTicker != nil </span><span class="cov8" title="1">{
                ap.monitorTicker.Stop()
        }</span>
        <span class="cov8" title="1">if ap.scaleTicker != nil </span><span class="cov8" title="1">{
                ap.scaleTicker.Stop()
        }</span>

        // 关闭优先级队列
        <span class="cov8" title="1">if ap.config.EnablePriority </span><span class="cov8" title="1">{
                ap.queueMutex.Lock()
                for _, queue := range ap.priorityQueues </span><span class="cov8" title="1">{
                        // 安全关闭channel
                        select </span>{
                        case &lt;-queue:<span class="cov0" title="0"></span>
                                // 清空队列中剩余的任务
                        default:<span class="cov8" title="1"></span>
                        }
                        <span class="cov8" title="1">close(queue)</span>
                }
                <span class="cov8" title="1">ap.queueMutex.Unlock()</span>
        }

        // 释放ants池
        <span class="cov8" title="1">ap.pool.Release()

        // 高级ants池已关闭
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package converter

import (
        "os"
        "os/exec"
        "strconv"
        "strings"
        "time"

        "pixly/config"

        "go.uber.org/zap"
)

// AtomicFileOperations 六步原子操作文件替换机制
type AtomicFileOperations struct {
        logger       *zap.Logger
        config       *config.Config
        errorHandler *ErrorHandler
}

// NewAtomicFileOperations 创建原子操作实例
func NewAtomicFileOperations(logger *zap.Logger, config *config.Config, errorHandler *ErrorHandler) *AtomicFileOperations <span class="cov8" title="1">{
        return &amp;AtomicFileOperations{
                logger:       logger,
                config:       config,
                errorHandler: errorHandler,
        }
}</span>

// SixStepAtomicReplace 六步原子操作文件替换
// 步骤1: 创建临时文件
// 步骤2: 写入新内容到临时文件
// 步骤3: 同步临时文件到磁盘
// 步骤4: 原子性重命名临时文件为目标文件
// 步骤5: 同步包含目录到磁盘
// 步骤6: 验证替换结果
func (afo *AtomicFileOperations) SixStepAtomicReplace(oldPath, newPath string, content []byte) error <span class="cov0" title="0">{
        // 开始六步原子操作文件替换

        // 预检查：磁盘空间
        requiredSize := int64(len(content)) * 2 // 考虑临时文件和最终文件
        if err := afo.checkDiskSpace(newPath, requiredSize); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("磁盘空间预检查失败", err)
        }</span>

        // 步骤1: 创建临时文件
        <span class="cov0" title="0">tempPath := newPath + ".tmp." + time.Now().Format("20060102150405")
        tempFile, err := os.Create(tempPath)
        if err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤1失败 - 无法创建临时文件", err)
        }</span>

        // 增强的临时文件清理机制
        <span class="cov0" title="0">var tempFileCreated bool = true
        defer func() </span><span class="cov0" title="0">{
                // 确保临时文件被清理
                if tempFileCreated </span><span class="cov0" title="0">{
                        if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                                afo.logger.Warn("清理临时文件时关闭失败", zap.String("temp_path", tempPath), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">if err := os.Remove(tempPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                afo.logger.Warn("清理临时文件时删除失败", zap.String("temp_path", tempPath), zap.Error(err))
                        }</span>
                }
        }()

        // 步骤2: 写入新内容到临时文件
        <span class="cov0" title="0">if _, err := tempFile.Write(content); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤2失败 - 无法写入临时文件", err)
        }</span>

        // 步骤3: 同步临时文件到磁盘
        <span class="cov0" title="0">if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤3失败 - 无法同步临时文件", err)
        }</span>

        // 关闭临时文件
        <span class="cov0" title="0">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("无法关闭临时文件", err)
        }</span>

        // 步骤4: 原子性重命名临时文件为目标文件
        <span class="cov0" title="0">if err := os.Rename(tempPath, newPath); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤4失败 - 无法原子性重命名文件", err)
        }</span>

        // 重命名成功，标记临时文件已被处理，避免defer中重复清理
        <span class="cov0" title="0">tempFileCreated = false

        // 步骤5: 同步包含目录到磁盘
        dir := GlobalPathUtils.GetDirName(newPath)
        if err := syncDir(dir); err != nil </span><span class="cov0" title="0">{
                afo.logger.Warn("步骤5警告 - 无法同步目录", zap.String("directory", dir), zap.Error(err))
        }</span>

        // 步骤6: 验证替换结果
        <span class="cov0" title="0">if err := afo.verifyFileReplacement(oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤6失败 - 文件替换验证失败", err)
        }</span>

        // 六步原子操作文件替换完成

        <span class="cov0" title="0">return nil</span>
}

// SixStepAtomicReplaceWithMetadata 六步原子操作文件替换（包含元数据迁移）
func (afo *AtomicFileOperations) SixStepAtomicReplaceWithMetadata(oldPath, newPath string, content []byte) error <span class="cov0" title="0">{
        // 开始六步原子操作文件替换（包含元数据迁移）

        // 预检查：磁盘空间
        requiredSize := int64(len(content)) * 2 // 考虑临时文件和最终文件
        if err := afo.checkDiskSpace(newPath, requiredSize); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("磁盘空间预检查失败", err)
        }</span>

        // 步骤1: 创建临时文件
        <span class="cov0" title="0">tempPath := newPath + ".tmp." + time.Now().Format("20060102150405")
        tempFile, err := os.Create(tempPath)
        if err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤1失败 - 无法创建临时文件", err)
        }</span>

        // 增强的临时文件清理机制
        <span class="cov0" title="0">var tempFileCreated bool = true
        defer func() </span><span class="cov0" title="0">{
                // 确保临时文件被清理
                if tempFileCreated </span><span class="cov0" title="0">{
                        if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                                afo.logger.Warn("清理临时文件时关闭失败", zap.String("temp_path", tempPath), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">if err := os.Remove(tempPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                afo.logger.Warn("清理临时文件时删除失败", zap.String("temp_path", tempPath), zap.Error(err))
                        }</span>
                }
        }()

        // 步骤2: 写入新内容到临时文件
        <span class="cov0" title="0">if _, err := tempFile.Write(content); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤2失败 - 无法写入临时文件", err)
        }</span>

        // 步骤3: 同步临时文件到磁盘
        <span class="cov0" title="0">if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤3失败 - 无法同步临时文件", err)
        }</span>

        // 关闭临时文件
        <span class="cov0" title="0">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("无法关闭临时文件", err)
        }</span>

        // 在重命名前迁移元数据
        <span class="cov0" title="0">if err := afo.migrateMetadata(oldPath, tempPath); err != nil </span><span class="cov0" title="0">{
                afo.logger.Warn("元数据迁移失败", zap.String("source", oldPath), zap.String("target", tempPath), zap.Error(err))
        }</span>

        // 步骤4: 原子性重命名临时文件为目标文件
        <span class="cov0" title="0">if err := os.Rename(tempPath, newPath); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤4失败 - 无法原子性重命名文件", err)
        }</span>

        // 重命名成功，标记临时文件已被处理，避免defer中重复清理
        <span class="cov0" title="0">tempFileCreated = false

        // 步骤5: 同步包含目录到磁盘
        dir := GlobalPathUtils.GetDirName(newPath)
        if err := syncDir(dir); err != nil </span><span class="cov0" title="0">{
                afo.logger.Warn("步骤5警告 - 无法同步目录", zap.String("directory", dir), zap.Error(err))
        }</span>

        // 步骤6: 验证替换结果
        <span class="cov0" title="0">if err := afo.verifyFileReplacement(oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("步骤6失败 - 文件替换验证失败", err)
        }</span>

        // 关键修复：确保oldPath和newPath是同一个文件时才删除
        // 检查是否是原地转换
        <span class="cov0" title="0">if oldPath == newPath </span><span class="cov0" title="0">{
                // 原地转换：无需删除，文件已被替换
                afo.logger.Debug("原地转换完成，无需删除原始文件", zap.String("path", newPath))
        }</span> else<span class="cov0" title="0"> {
                // 非原地转换：需要删除原始文件
                if err := os.Remove(oldPath); err != nil </span><span class="cov0" title="0">{
                        afo.logger.Warn("删除原始文件失败", zap.String("old_path", oldPath), zap.Error(err))
                        return afo.errorHandler.WrapError("删除原始文件失败", err)
                }</span>
                <span class="cov0" title="0">afo.logger.Debug("原始文件已删除", zap.String("old_path", oldPath))</span>
        }

        // 六步原子操作文件替换（包含元数据迁移）完成

        <span class="cov0" title="0">return nil</span>
}

// verifyFileReplacement 验证文件替换结果
func (afo *AtomicFileOperations) verifyFileReplacement(oldPath, newPath string) error <span class="cov0" title="0">{
        // 检查新文件是否存在
        if _, err := os.Stat(newPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                var errorBuilder strings.Builder
                errorBuilder.WriteString("新文件不存在: path: ")
                errorBuilder.WriteString(newPath)
                return afo.errorHandler.WrapError(errorBuilder.String(), nil)
        }</span>

        // 检查文件大小是否合理
        <span class="cov0" title="0">newInfo, err := os.Stat(newPath)
        if err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapError("无法获取新文件信息", err)
        }</span>

        <span class="cov0" title="0">if newInfo.Size() == 0 </span><span class="cov0" title="0">{
                var sizeErrorBuilder strings.Builder
                sizeErrorBuilder.WriteString("新文件大小为0: path: ")
                sizeErrorBuilder.WriteString(newPath)
                return afo.errorHandler.WrapError(sizeErrorBuilder.String(), nil)
        }</span>

        // 如果原文件存在，检查文件大小是否合理
        <span class="cov0" title="0">if oldInfo, err := os.Stat(oldPath); err == nil </span><span class="cov0" title="0">{
                // 对于JPEG重新包装，允许更大的文件大小
                // 只有当文件大小超过原文件4倍时才认为异常
                if newInfo.Size() &gt; oldInfo.Size()*4 </span><span class="cov0" title="0">{
                        afo.logger.Warn("新文件大小异常",
                                zap.Int64("old_size", oldInfo.Size()),
                                zap.Int64("new_size", newInfo.Size()))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// migrateMetadata 使用exiftool迁移元数据
func (afo *AtomicFileOperations) migrateMetadata(sourcePath, targetPath string) error <span class="cov0" title="0">{
        // 检查exiftool是否可用
        if _, err := os.Stat(afo.config.Tools.ExiftoolPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                var toolErrorBuilder strings.Builder
                toolErrorBuilder.WriteString("exiftool不可用: path: ")
                toolErrorBuilder.WriteString(afo.config.Tools.ExiftoolPath)
                return afo.errorHandler.WrapError(toolErrorBuilder.String(), nil)
        }</span>

        // 使用exiftool迁移所有元数据
        // 命令: exiftool -TagsFromFile source -all:all target
        <span class="cov0" title="0">args := []string{
                "-TagsFromFile", sourcePath,
                "-all:all", targetPath,
                "-overwrite_original",
        }

        cmd := exec.Command(afo.config.Tools.ExiftoolPath, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return afo.errorHandler.WrapErrorWithOutput("exiftool元数据迁移失败", err, output)
        }</span>

        // 元数据迁移完成

        <span class="cov0" title="0">return nil</span>
}

// syncDir 同步目录到磁盘
func syncDir(dir string) error <span class="cov0" title="0">{
        // 打开目录
        d, err := os.Open(dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := d.Close(); err != nil </span>{<span class="cov0" title="0">
                        // 目录关闭失败通常不是致命错误，记录警告即可
                }</span>
        }()

        // 同步目录
        <span class="cov0" title="0">if err := d.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkDiskSpace 检查磁盘空间是否足够
func (afo *AtomicFileOperations) checkDiskSpace(filePath string, requiredSize int64) error <span class="cov0" title="0">{
        // 获取文件所在目录的磁盘空间信息
        dir := GlobalPathUtils.GetDirName(filePath)

        // 使用 os.Stat 获取文件系统信息（跨平台兼容）
        var availableSpace int64

        // 简化的磁盘空间检查实现
        // 在实际生产环境中，可以使用 golang.org/x/sys/unix 或 golang.org/x/sys/windows
        // 来获取更精确的磁盘空间信息

        // 这里使用一个保守的估算方法
        if _, err := os.Stat(dir); err == nil </span><span class="cov0" title="0">{
                // 假设至少需要1GB的可用空间作为安全缓冲
                minRequiredSpace := int64(1024 * 1024 * 1024) // 1GB
                if requiredSize &lt; minRequiredSpace </span><span class="cov0" title="0">{
                        requiredSize = minRequiredSpace
                }</span>

                // 简化检查：如果目录可访问，假设有足够空间
                // 实际实现应该调用系统API获取真实的可用空间
                <span class="cov0" title="0">availableSpace = requiredSize + 1</span> // 简化实现
        } else<span class="cov0" title="0"> {
                return afo.errorHandler.WrapError("无法访问目标目录", err)
        }</span>

        <span class="cov0" title="0">if availableSpace &lt; requiredSize </span><span class="cov0" title="0">{
                var spaceErrorBuilder strings.Builder
                spaceErrorBuilder.WriteString("磁盘空间不足：需要 ")
                spaceErrorBuilder.WriteString(strconv.FormatInt(requiredSize, 10))
                spaceErrorBuilder.WriteString(" 字节，可用 ")
                spaceErrorBuilder.WriteString(strconv.FormatInt(availableSpace, 10))
                spaceErrorBuilder.WriteString(" 字节")
                return afo.errorHandler.WrapError(spaceErrorBuilder.String(), nil)
        }</span>

        // 磁盘空间检查通过

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package converter

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "pixly/core/input"
        "pixly/core/output"
        "pixly/internal/ui"

        "go.uber.org/zap"
)

// BatchProcessor 批处理处理器
type BatchProcessor struct {
        converter      *Converter
        logger         *zap.Logger
        taskQueue      []*MediaFile
        corruptedFiles []*MediaFile
        stats          *ConversionStats
        results        []*ConversionResult
        watchdog       *ProgressWatchdog
        atomicOps      *AtomicFileOperations
        // themeManager   *theme.ThemeManager // 暂时注释避免循环导入
        ctx context.Context

        strategy   ConversionStrategy // 添加策略字段
        mutex      sync.RWMutex
        memoryPool *MemoryPool // 内存池
}

// detectMagicNumberAndCorrectExtension 检测文件的Magic Number并纠正扩展名
func (bp *BatchProcessor) detectMagicNumberAndCorrectExtension(filePath string) (string, bool) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // 读取文件头部字节
        header := make([]byte, 32)
        n, err := file.Read(header)
        if err != nil || n &lt; 4 </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // Magic Number匹配逻辑
        <span class="cov0" title="0">switch </span>{
        case bytes.HasPrefix(header, []byte{0xFF, 0xD8, 0xFF}):<span class="cov0" title="0"> // JPEG
                return "jpg", true</span>
        case bytes.HasPrefix(header, []byte{0x89, 0x50, 0x4E, 0x47}):<span class="cov0" title="0"> // PNG
                return "png", true</span>
        case bytes.HasPrefix(header, []byte{0x47, 0x49, 0x46, 0x38}):<span class="cov0" title="0"> // GIF
                return "gif", true</span>
        case bytes.HasPrefix(header, []byte{0x52, 0x49, 0x46, 0x46}) &amp;&amp; bytes.Contains(header[8:12], []byte("WEBP")):<span class="cov0" title="0"> // WebP
                return "webp", true</span>
        case bytes.HasPrefix(header, []byte{0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70}):<span class="cov0" title="0"> // MP4
                return "mp4", true</span>
        case bytes.HasPrefix(header, []byte{0x00, 0x00, 0x00, 0x14, 0x66, 0x74, 0x79, 0x70}):<span class="cov0" title="0"> // MP4
                return "mp4", true</span>
        case bytes.HasPrefix(header, []byte{0x1A, 0x45, 0xDF, 0xA3}):<span class="cov0" title="0"> // MKV/WebM
                return "mkv", true</span>
        case bytes.HasPrefix(header, []byte{0x46, 0x4C, 0x56}):<span class="cov0" title="0"> // FLV
                return "flv", true</span>
        case bytes.HasPrefix(header, []byte{0x30, 0x26, 0xB2, 0x75}):<span class="cov0" title="0"> // ASF/WMV
                return "wmv", true</span>
        default:<span class="cov0" title="0">
                return "", false</span>
        }
}

// preValidateAllFiles 预验证所有文件
func (bp *BatchProcessor) preValidateAllFiles(files []*MediaFile) error <span class="cov0" title="0">{
        for _, file := range files </span><span class="cov0" title="0">{
                // 检查文件是否存在
                if _, err := os.Stat(file.Path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("文件不存在: %s", file.Path)
                }</span>

                // 检查文件是否可读
                <span class="cov0" title="0">if f, err := os.Open(file.Path); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("文件无法读取: %s, 错误: %v", file.Path, err)
                }</span> else<span class="cov0" title="0"> {
                        f.Close()
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// atomicBatchProcess 原子批处理
func (bp *BatchProcessor) atomicBatchProcess(files []*MediaFile) error <span class="cov0" title="0">{
        // 使用原子操作确保批处理的一致性
        // 不要在第一个错误时就中断，而是继续处理所有文件
        var firstError error

        for _, file := range files </span><span class="cov0" title="0">{
                result := bp.converter.processFile(file)
                // 注意：UpdateStats已经在processFile内部调用，这里不需要重复调用
                if !result.Success &amp;&amp; firstError == nil </span><span class="cov0" title="0">{
                        // 记录第一个错误，但继续处理其他文件
                        firstError = result.Error
                        bp.logger.Error("文件处理失败", zap.String("file", file.Path), zap.Error(result.Error))
                }</span>
        }

        // 如果有错误，返回第一个错误
        <span class="cov0" title="0">if firstError != nil </span><span class="cov0" title="0">{
                return firstError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createBackup 创建文件备份
func (bp *BatchProcessor) createBackup(srcPath, backupPath string) error <span class="cov0" title="0">{
        src, err := os.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer src.Close()

        dst, err := os.Create(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        _, err = io.Copy(dst, src)
        return err</span>
}

// rollbackFiles 回滚文件
func (bp *BatchProcessor) rollbackFiles(backupMap map[string]string) <span class="cov0" title="0">{
        for originalPath, backupPath := range backupMap </span><span class="cov0" title="0">{
                if _, err := os.Stat(backupPath); err == nil </span><span class="cov0" title="0">{
                        os.Rename(backupPath, originalPath)
                }</span>
        }
}

// cleanupBackups 清理备份文件
func (bp *BatchProcessor) cleanupBackups(backupMap map[string]string) <span class="cov0" title="0">{
        for _, backupPath := range backupMap </span><span class="cov0" title="0">{
                os.Remove(backupPath)
        }</span>
}

// NewBatchProcessor 创建新的批处理处理器
func NewBatchProcessor(converter *Converter, logger *zap.Logger) *BatchProcessor <span class="cov0" title="0">{
        return &amp;BatchProcessor{
                converter:      converter,
                logger:         logger,
                taskQueue:      make([]*MediaFile, 0),
                corruptedFiles: make([]*MediaFile, 0),
                stats:          converter.stats,
                results:        converter.results,
                watchdog:       converter.watchdog,
                atomicOps:      converter.atomicOps,
                // themeManager:   converter.themeManager, // 暂时注释避免循环导入
                ctx: converter.ctx,

                strategy:   converter.strategy,                    // 添加策略字段
                memoryPool: GetGlobalMemoryPool(converter.logger), // 初始化内存池
        }
}</span>

// ScanAndAnalyze 统一扫描和分析（双阶段智能分析架构）
func (bp *BatchProcessor) ScanAndAnalyze(inputDir string) error <span class="cov0" title="0">{
        // 开始统一扫描和分析
        
        // 阶段一：元信息预判（95%）
        // 通过文件扩展名、Magic Number 和文件大小等元信息进行快速筛选和分类
        files, mediaInfoMap, totalScannedFiles, skippedFiles, err := bp.quickScan(inputDir)
        if err != nil </span><span class="cov0" title="0">{
                return bp.converter.errorHandler.WrapError("快速扫描失败", err)
        }</span>

        // 阶段二：FFmpeg 深度验证（5%）
        // 仅对阶段一无法确定的文件调用 ffprobe 进行深度分析
        <span class="cov0" title="0">uncertainFiles := bp.identifyUncertainFiles(files, mediaInfoMap)
        if err := bp.deepAnalysis(uncertainFiles, mediaInfoMap, inputDir); err != nil </span><span class="cov0" title="0">{
                return bp.converter.errorHandler.WrapError("深度分析失败", err)
        }</span>

        // 构建任务队列
        <span class="cov0" title="0">taskQueue := make([]*MediaFile, 0, len(files))
        corruptedFiles := make([]*MediaFile, 0)

        // 计算总文件大小
        var totalSize int64 = 0

        // 分类文件
        for _, file := range files </span><span class="cov0" title="0">{
                // 累加文件大小
                totalSize += file.Size

                // 检查文件是否损坏
                if mediaInfo, exists := mediaInfoMap[file.Path]; exists &amp;&amp; mediaInfo.IsCorrupted </span><span class="cov0" title="0">{
                        file.IsCorrupted = true
                        corruptedFiles = append(corruptedFiles, file)
                        continue</span>
                }

                // 检查是否编解码器不兼容
                <span class="cov0" title="0">if mediaInfo, exists := mediaInfoMap[file.Path]; exists &amp;&amp; bp.isCodecIncompatible(mediaInfo) </span><span class="cov0" title="0">{
                        file.IsCodecIncompatible = true
                }</span>

                // 检查是否容器不兼容
                <span class="cov0" title="0">if mediaInfo, exists := mediaInfoMap[file.Path]; exists &amp;&amp; bp.isContainerIncompatible(mediaInfo) </span><span class="cov0" title="0">{
                        file.IsContainerIncompatible = true
                }</span>

                // 添加到任务队列
                <span class="cov0" title="0">taskQueue = append(taskQueue, file)</span>
        }

        // 处理不同类型的问题文件
        <span class="cov0" title="0">if err := bp.converter.HandleCodecIncompatibility(taskQueue); err != nil </span><span class="cov0" title="0">{
                bp.logger.Warn("处理编解码器不兼容文件时出错", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := bp.converter.HandleContainerIncompatibility(taskQueue); err != nil </span><span class="cov0" title="0">{
                bp.logger.Warn("处理容器不兼容文件时出错", zap.Error(err))
        }</span>

        // 处理跳过的文件
        <span class="cov0" title="0">if len(skippedFiles) &gt; 0 </span><span class="cov0" title="0">{
                bp.mutex.Lock()
                for _, skippedFile := range skippedFiles </span><span class="cov0" title="0">{
                        // 创建跳过的转换结果
                        result := &amp;ConversionResult{
                                OriginalFile:     skippedFile,
                                OutputPath:       skippedFile.Path,
                                OriginalSize:     skippedFile.Size,
                                CompressedSize:   skippedFile.Size,
                                CompressionRatio: 0,
                                Success:          true,
                                Skipped:          true,
                                SkipReason:       "already target format",
                                Method:           "skip",
                                Duration:         0,
                        }

                        // 添加到结果列表
                        bp.results = append(bp.results, result)
                        // 同步到Converter的results
                        bp.converter.mutex.Lock()
                        bp.converter.results = append(bp.converter.results, result)
                        bp.converter.mutex.Unlock()
                }</span>
                <span class="cov0" title="0">bp.mutex.Unlock()</span>
        }

        // 更新批处理器状态
        <span class="cov0" title="0">bp.mutex.Lock()
        bp.taskQueue = taskQueue
        bp.corruptedFiles = corruptedFiles
        // 初始化统计信息 - 使用实际扫描到的文件总数（包括跳过的文件）
        bp.stats.TotalFiles = totalScannedFiles
        bp.stats.TotalSize = totalSize // 同时初始化总大小
        bp.stats.StartTime = time.Now()
        bp.mutex.Unlock()

        // 扫描和分析完成

        return nil</span>
}

// isCodecIncompatible 检查是否编解码器不兼容
func (bp *BatchProcessor) isCodecIncompatible(mediaInfo *MediaInfo) bool <span class="cov0" title="0">{
        // 这里可以添加具体的编解码器不兼容检查逻辑
        // 例如：检查是否为不支持的编解码器
        incompatibleCodecs := []string{"unsupported_codec1", "unsupported_codec2"}
        for _, codec := range incompatibleCodecs </span><span class="cov0" title="0">{
                if mediaInfo.Codec == codec </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isContainerIncompatible 检查是否容器不兼容
func (bp *BatchProcessor) isContainerIncompatible(mediaInfo *MediaInfo) bool <span class="cov0" title="0">{
        // 这里可以添加具体的容器不兼容检查逻辑
        // 例如：检查是否为不支持的容器格式
        // incompatibleContainers := []string{"unsupported_container1", "unsupported_container2"}
        // 这里简化处理，实际应该从mediaInfo中获取容器信息
        return false
}</span>

// quickScan 快速扫描（阶段一：元信息预判）
// 在95%扫描阶段执行Magic Number检测，提高文件识别准确性
func (bp *BatchProcessor) quickScan(inputDir string) ([]*MediaFile, map[string]*MediaInfo, int, []*MediaFile, error) <span class="cov0" title="0">{
        var files []*MediaFile
        mediaInfoMap := make(map[string]*MediaInfo)

        // 扫描阶段使用动态进度显示
        // 虽然不知道总文件数，但可以使用扫描计数显示进度

        // 用于跟踪扫描的文件数量
        var scannedCount int64
        var totalCount int64
        var skippedCount int64
        // 用于存储跳过的文件，确保它们也被记录到结果中
        var skippedFiles []*MediaFile
        
        // 启动扫描进度显示（使用未知总大小的进度条）
        ui.StartDynamicProgressUnknownTotal("扫描文件...")

        // 使用GlobalPathUtils规范化输入目录
        normalizedInputDir, err := GlobalPathUtils.NormalizePath(inputDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, 0, nil, bp.converter.errorHandler.WrapError("无法规范化输入目录", err)
        }</span>

        <span class="cov0" title="0">err = GlobalPathUtils.WalkPath(normalizedInputDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        bp.logger.Warn("无法访问文件", zap.String("path", path), zap.Error(err))
                        return nil
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 更新扫描计数
                <span class="cov0" title="0">totalCount++

                // 扫描阶段不更新进度条，只记录日志

                // 每扫描100个文件更新进度
                if totalCount%100 == 0 </span><span class="cov0" title="0">{
                        ui.UpdateDynamicProgress(int64(totalCount), fmt.Sprintf("已扫描 %d 个文件...", totalCount))
                }</span>

                // 检查是否为媒体文件
                <span class="cov0" title="0">if !bp.converter.isMediaFile(path) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 获取文件扩展名
                // 使用GlobalPathUtils处理路径
                <span class="cov0" title="0">normalizedPath, pathErr := GlobalPathUtils.NormalizePath(path)
                if pathErr != nil </span><span class="cov0" title="0">{
                        bp.logger.Warn("路径规范化失败", zap.String("path", path), zap.Error(pathErr))
                        return nil
                }</span>
                <span class="cov0" title="0">ext := strings.ToLower(GlobalPathUtils.GetExtension(normalizedPath))

                // 只对可疑文件进行Magic Number检测以提高性能
                needsMagicCheck := false
                if !knownFormats[ext] </span><span class="cov0" title="0">{
                        needsMagicCheck = true
                }</span> else<span class="cov0" title="0"> if info.Size() == 0 </span><span class="cov0" title="0">{
                        needsMagicCheck = true
                }</span> else<span class="cov0" title="0"> if info.Size() &gt; 100*1024*1024 </span><span class="cov0" title="0">{ // 超过100MB的文件
                        needsMagicCheck = true
                }</span>

                <span class="cov0" title="0">if needsMagicCheck </span><span class="cov0" title="0">{
                        if actualExt, corrected := bp.detectMagicNumberAndCorrectExtension(path); corrected </span><span class="cov0" title="0">{
                                // 检查修正后的扩展名是否为目标格式，如果是则跳过处理
                                correctedExt := "." + actualExt
                                if bp.converter.IsTargetFormat(correctedExt) </span><span class="cov0" title="0">{
                                        bp.logger.Debug("修正后的扩展名为目标格式，跳过处理",
                                                zap.String("file", path),
                                                zap.String("original_ext", ext),
                                                zap.String("corrected_ext", actualExt))
                                        ext = correctedExt
                                        // 将文件标记为跳过
                                        skippedFile := &amp;MediaFile{
                                                Path:      path,
                                                Name:      info.Name(),
                                                Size:      info.Size(),
                                                Extension: correctedExt,
                                                ModTime:   info.ModTime(),
                                                Type:      bp.converter.GetFileType(correctedExt),
                                        }
                                        skippedFiles = append(skippedFiles, skippedFile)
                                        
                                        // 创建媒体信息并跳过
                                        mediaInfo := &amp;MediaInfo{
                                                FullPath:       path,
                                                FileSize:       info.Size(),
                                                ModTime:        info.ModTime(),
                                                Codec:          actualExt,
                                                FrameCount:     0,
                                                IsAnimated:     false,
                                                IsCorrupted:    info.Size() == 0,
                                                InitialQuality: 50,
                                        }
                                        mediaInfoMap[path] = mediaInfo
                                        skippedCount++
                                        return nil
                                }</span>
                                
                                <span class="cov0" title="0">bp.logger.Debug("扩展名修正完成",
                                        zap.String("file", path),
                                        zap.String("original_ext", ext),
                                        zap.String("corrected_ext", actualExt))
                                ext = correctedExt</span>
                        }
                }

                // 检查文件是否已经是目标格式，如果是则记录为跳过文件
                <span class="cov0" title="0">if bp.converter.IsTargetFormat(ext) </span><span class="cov0" title="0">{
                        // 文件已是目标格式，跳过扫描和扩展名修正
                        bp.logger.Info("跳过目标格式文件",
                                zap.String("file", path),
                                zap.String("format", ext),
                                zap.String("reason", "已经是目标格式，无需转换"))

                        // 创建跳过的文件信息
                        skippedFile := &amp;MediaFile{
                                Path:       path,
                                Name:       info.Name(),
                                Size:       info.Size(),
                                Extension:  ext,
                                ModTime:    info.ModTime(),
                                Type:       bp.converter.GetFileType(ext),
                                SkipReason: "已经是目标格式",
                        }
                        // 添加到跳过文件列表
                        skippedFiles = append(skippedFiles, skippedFile)

                        // 创建媒体信息
                        mediaInfo := &amp;MediaInfo{
                                FullPath:       path,
                                FileSize:       info.Size(),
                                ModTime:        info.ModTime(),
                                Codec:          strings.TrimPrefix(ext, "."),
                                FrameCount:     0,
                                IsAnimated:     false,
                                IsCorrupted:    info.Size() == 0,
                                InitialQuality: 50,
                        }

                        // 对于跳过的文件，使用轻量级标识符而不是计算耗时的SHA256哈希值
                        // 使用文件路径、大小和修改时间作为唯一标识
                        var hashBuilder strings.Builder
                        hashBuilder.WriteString("skip_")
                        hashBuilder.WriteString(path)
                        hashBuilder.WriteString("_")
                        hashBuilder.WriteString(strconv.FormatInt(info.Size(), 10))
                        hashBuilder.WriteString("_")
                        hashBuilder.WriteString(strconv.FormatInt(info.ModTime().Unix(), 10))
                        mediaInfo.SHA256Hash = hashBuilder.String()

                        mediaInfoMap[path] = mediaInfo
                        skippedCount++
                        return nil
                }</span>

                <span class="cov0" title="0">mediaFile := &amp;MediaFile{
                        Path:      path,
                        Name:      info.Name(),
                        Size:      info.Size(),
                        Extension: ext,
                        ModTime:   info.ModTime(),
                }

                // 确定文件类型
                mediaFile.Type = bp.converter.GetFileType(mediaFile.Extension)

                files = append(files, mediaFile)
                scannedCount++

                // 创建初步的媒体信息
                mediaInfo := &amp;MediaInfo{
                        FullPath:       path,
                        FileSize:       info.Size(),
                        ModTime:        info.ModTime(),
                        Codec:          strings.TrimPrefix(ext, "."), // 使用扩展名作为初始编解码器
                        FrameCount:     0,                            // 将在阶段二中填充
                        IsAnimated:     false,
                        IsCorrupted:    info.Size() == 0, // 简单判断空文件为损坏文件
                        InitialQuality: 50,               // 默认质量
                }

                // 使用轻量级标识符代替耗时的SHA256哈希值计算
                // 使用文件路径、大小和修改时间作为唯一标识，提升扫描性能
                var hashBuilder strings.Builder
                hashBuilder.WriteString("quick_")
                hashBuilder.WriteString(path)
                hashBuilder.WriteString("_")
                hashBuilder.WriteString(strconv.FormatInt(info.Size(), 10))
                hashBuilder.WriteString("_")
                hashBuilder.WriteString(strconv.FormatInt(info.ModTime().Unix(), 10))
                mediaInfo.SHA256Hash = hashBuilder.String()

                mediaInfoMap[path] = mediaInfo

                return nil</span>
        })

        // 完成扫描
        // 扫描完成

        // 快速扫描完成

        // 记录实际需要处理的文件数量，用于调试
        // 实际需要处理的文件数量

        // 将跳过的文件添加到BatchProcessor中，并更新统计信息
        <span class="cov0" title="0">if len(skippedFiles) &gt; 0 </span><span class="cov0" title="0">{
                bp.mutex.Lock()
                for _, skippedFile := range skippedFiles </span><span class="cov0" title="0">{
                        // 创建跳过的转换结果
                        result := &amp;ConversionResult{
                                OriginalFile:     skippedFile,
                                OutputPath:       skippedFile.Path, // 跳过的文件输出路径为原路径
                                OriginalSize:     skippedFile.Size,
                                CompressedSize:   skippedFile.Size,
                                CompressionRatio: 0,
                                Success:          true,
                                Skipped:          true,
                                SkipReason:       "已经是目标格式",
                                Method:           "skip",
                                Duration:         0,
                        }

                        // 添加到结果列表
                        bp.results = append(bp.results, result)
                        // 同步到Converter的results
                        bp.converter.results = append(bp.converter.results, result)

                        // 立即更新统计信息，确保跳过文件被正确统计
                        bp.converter.UpdateStats(result)
                }</span>
                <span class="cov0" title="0">bp.mutex.Unlock()</span>

                // 已记录跳过的文件到结果中并更新统计
        }

        // 完成扫描进度
        <span class="cov0" title="0">ui.FinishDynamicProgress()
        return files, mediaInfoMap, int(totalCount), skippedFiles, err</span>
}

// calculateFileHash 计算文件的SHA256哈希值
func (bp *BatchProcessor) calculateFileHash(filePath string) (hash string, err error) <span class="cov0" title="0">{
        // 添加panic恢复机制
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        bp.logger.Error("Panic in calculateFileHash",
                                zap.String("file", filePath),
                                zap.Any("panic", r),
                                zap.Stack("stacktrace"))
                        hash = ""
                        var errBuilder strings.Builder
                        errBuilder.WriteString("panic in calculateFileHash: ")
                        errBuilder.WriteString(fmt.Sprint(r))
                        err = fmt.Errorf("%s", errBuilder.String())
                }</span>
        }()

        // 验证文件是否存在和可读
        <span class="cov0" title="0">if _, err := os.Stat(filePath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file stat failed: %w", err)
        }</span>

        <span class="cov0" title="0">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file open failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        bp.logger.Warn("Failed to close file during hash calculation",
                                zap.String("file", filePath),
                                zap.Error(err))
                }</span>
        }()

        // 使用内存池获取缓冲区，提升性能并减少GC压力
        <span class="cov0" title="0">buffer := bp.memoryPool.GetBuffer()
        defer bp.memoryPool.PutBuffer(buffer)

        // 确保缓冲区有足够的容量用于哈希计算
        const optimalBufferSize = 32 * 1024
        if cap(buffer) &lt; optimalBufferSize </span><span class="cov0" title="0">{
                // 如果内存池提供的缓冲区太小，直接使用固定大小的缓冲区
                // 避免重新分配和复制，这样更高效
                buffer = make([]byte, optimalBufferSize)
        }</span> else<span class="cov0" title="0"> {
                // 重置缓冲区长度为最优大小
                buffer = buffer[:optimalBufferSize]
        }</span>

        <span class="cov0" title="0">hasher := sha256.New()
        if _, err := io.CopyBuffer(hasher, file, buffer); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("hash calculation failed: %w", err)
        }</span>

        <span class="cov0" title="0">hashBytes := hasher.Sum(nil)
        var hashBuilder strings.Builder
        hashBuilder.Grow(len(hashBytes) * 2) // 预分配空间
        for _, b := range hashBytes </span><span class="cov0" title="0">{
                if b &lt; 16 </span><span class="cov0" title="0">{
                        hashBuilder.WriteByte('0')
                }</span>
                <span class="cov0" title="0">hashBuilder.WriteString(strconv.FormatUint(uint64(b), 16))</span>
        }
        <span class="cov0" title="0">return hashBuilder.String(), nil</span>
}

// 文件类型分类器 - 消除复杂的评分逻辑
var (
        knownFormats = map[string]bool{
                // 图片格式 - 基础格式（仅包含真正的图片媒体文件）
                ".jpg": true, ".jpeg": true, ".jpe": true, ".png": true, ".gif": true,
                ".bmp": true, ".tiff": true, ".tif": true, ".ico": true,

                // 图片格式 - 现代格式
                ".webp": true, ".heic": true, ".heif": true, ".jxl": true, ".avif": true,
                ".jp2": true, ".jpx": true, ".j2k": true, ".j2c": true, ".jpc": true,
                ".apng": true,

                // 视频格式 - 主流格式（仅包含真正的视频媒体文件）
                ".mp4": true, ".mov": true, ".avi": true, ".mkv": true, ".webm": true,
                ".flv": true, ".wmv": true, ".asf": true, ".m4v": true, ".3gp": true,
                ".3g2": true, ".f4v": true, ".f4p": true,

                // 视频格式 - 专业格式
                ".mxf": true, ".mts": true, ".m2ts": true, ".ts": true, ".vob": true,
                ".mpg": true, ".mpeg": true, ".m1v": true, ".m2v": true, ".mpv": true,
                ".mpe": true, ".mpv2": true,

                // 视频格式 - 新兴格式
                ".av1": true, ".ivf": true, ".y4m": true, ".yuv": true,
                ".dv": true, ".hdv": true, ".divx": true, ".xvid": true, ".ogv": true,
                ".ogm": true, ".rm": true, ".rmvb": true, ".rv": true, ".amv": true,
        }
        trashFormats = map[string]bool{
                ".tmp": true, ".bak": true, ".old": true, ".temp": true,
                ".cache": true, ".log": true, ".swp": true, ".swo": true,
                ".~": true, ".backup": true, ".orig": true, ".save": true,
        }
        animatedFormats = map[string]bool{
                ".gif": true, ".webp": true, ".avif": true, ".apng": true,
                ".flif": true, ".mng": true, ".jng": true, ".jxl": true,
                ".tiff": true, ".tif": true,
        }
)

// identifyUncertainFiles 识别需要深度分析的文件 - 简化版本
// 怀疑度评分阈值常量 - README要求的核心参数
const (
        SUSPICION_THRESHOLD   = 50 // 达到50分才进行深度分析（提高阈值减少深度分析）
        SCORE_UNKNOWN_FORMAT  = 20 // 未知格式扩展名
        SCORE_ZERO_SIZE       = 25 // 零字节文件
        SCORE_HUGE_SIZE       = 15 // 超大文件(&gt;100MB)
        SCORE_NO_EXTENSION    = 10 // 无扩展名
        SCORE_SUSPICIOUS_NAME = 5  // 可疑文件名模式
        SCORE_RECENT_MODIFIED = 3  // 最近修改的文件
)

func (bp *BatchProcessor) identifyUncertainFiles(files []*MediaFile, mediaInfoMap map[string]*MediaInfo) []*MediaFile <span class="cov0" title="0">{
        uncertainFiles := make([]*MediaFile, 0)
        skippedByScore := 0

        for _, file := range files </span><span class="cov0" title="0">{
                mediaInfo := mediaInfoMap[file.Path]
                ext := strings.ToLower(file.Extension)

                // 已知格式：预填充信息，无需深度分析
                if knownFormats[ext] </span><span class="cov0" title="0">{
                        mediaInfo.Codec = ext
                        mediaInfo.IsAnimated = animatedFormats[ext]
                        if mediaInfo.IsAnimated </span><span class="cov0" title="0">{
                                mediaInfo.FrameCount = 10
                        }</span> else<span class="cov0" title="0"> {
                                mediaInfo.FrameCount = 1
                        }</span>
                        <span class="cov0" title="0">mediaInfo.SuspicionScore = 0 // 已知格式无怀疑
                        continue</span>
                }

                // 怀疑度评分制度 - README要求的核心功能
                <span class="cov0" title="0">suspicionScore := 0
                suspicionReasons := make([]string, 0)

                // 评分规则1: 未知格式扩展名和Magic Number检测
                if ext == "" </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_NO_EXTENSION
                        suspicionReasons = append(suspicionReasons, "无扩展名")
                }</span> else<span class="cov0" title="0"> if !knownFormats[ext] </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_UNKNOWN_FORMAT
                        var reasonBuilder strings.Builder
                        reasonBuilder.WriteString("未知格式: ")
                        reasonBuilder.WriteString(ext)
                        suspicionReasons = append(suspicionReasons, reasonBuilder.String())
                }</span>

                // 对于未知格式或可疑文件，进行Magic Number检测
                <span class="cov0" title="0">if !knownFormats[ext] || file.Size == 0 || file.Size &gt; 100*1024*1024 </span><span class="cov0" title="0">{
                        if detectedExt, needsCorrection := bp.detectMagicNumberAndCorrectExtension(file.Path); needsCorrection </span><span class="cov0" title="0">{
                                suspicionScore += 15 // Magic Number不匹配扩展名
                                var mismatchBuilder strings.Builder
                                mismatchBuilder.WriteString("扩展名不匹配(实际:")
                                mismatchBuilder.WriteString(detectedExt)
                                mismatchBuilder.WriteString(")")
                                suspicionReasons = append(suspicionReasons, mismatchBuilder.String())

                                // 记录扩展名修正信息
                                if mediaInfo, exists := mediaInfoMap[file.Path]; exists </span><span class="cov0" title="0">{
                                        mediaInfo.DetectedFormat = detectedExt
                                        mediaInfo.NeedsExtensionCorrection = true
                                }</span>
                        }
                }

                // 评分规则2: 文件大小异常
                <span class="cov0" title="0">if file.Size == 0 </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_ZERO_SIZE
                        suspicionReasons = append(suspicionReasons, "零字节文件")
                }</span> else<span class="cov0" title="0"> if file.Size &gt; 100*1024*1024 </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_HUGE_SIZE
                        var sizeBuilder strings.Builder
                        sizeBuilder.WriteString("超大文件: ")
                        sizeBuilder.WriteString(strconv.FormatFloat(float64(file.Size)/(1024*1024), 'f', 1, 64))
                        sizeBuilder.WriteString("MB")
                        suspicionReasons = append(suspicionReasons, sizeBuilder.String())
                }</span>

                // 评分规则3: 可疑文件名模式
                <span class="cov0" title="0">fileName := strings.ToLower(file.Name)
                if strings.Contains(fileName, "temp") || strings.Contains(fileName, "tmp") ||
                        strings.Contains(fileName, "cache") || strings.Contains(fileName, "backup") </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_SUSPICIOUS_NAME
                        suspicionReasons = append(suspicionReasons, "可疑文件名模式")
                }</span>

                // 评分规则4: 最近修改的文件(可能正在使用中)
                <span class="cov0" title="0">if time.Since(file.ModTime) &lt; 24*time.Hour </span><span class="cov0" title="0">{
                        suspicionScore += SCORE_RECENT_MODIFIED
                        suspicionReasons = append(suspicionReasons, "24小时内修改")
                }</span>

                // 记录怀疑度评分
                <span class="cov0" title="0">mediaInfo.SuspicionScore = suspicionScore
                mediaInfo.SuspicionReasons = suspicionReasons

                // 只有达到阈值才进行深度分析 - README的核心要求
                if suspicionScore &gt;= SUSPICION_THRESHOLD </span><span class="cov0" title="0">{
                        uncertainFiles = append(uncertainFiles, file)
                        // 文件需要深度分析
                }</span> else<span class="cov0" title="0"> {
                        skippedByScore++
                        // 文件跳过深度分析
                }</span>
        }

        // 怀疑度评分完成
        <span class="cov0" title="0">return uncertainFiles</span>
}

// deepAnalysis 深度分析文件
func (bp *BatchProcessor) deepAnalysis(filesToAnalyze []*MediaFile, mediaInfoMap map[string]*MediaInfo, inputDir string) error <span class="cov0" title="0">{
        // 启动深度分析进度条
        ui.StartNamedProgress("analysis", int64(len(filesToAnalyze)), "深度分析")
        defer ui.FinishNamedProgress("analysis")

        // 开始深度分析
        // 开始深度分析

        // 获取工作池
        pool := bp.converter.GetWorkerPool()
        if pool == nil </span><span class="cov0" title="0">{
                bp.logger.Error("无法获取工作池进行深度分析")
                return fmt.Errorf("工作池不可用")
        }</span>

        // 使用原子计数器跟踪进度
        <span class="cov0" title="0">var analyzedCount int64
        var wg sync.WaitGroup

        // 对每个不确定的文件进行深度分析
        for _, file := range filesToAnalyze </span><span class="cov0" title="0">{
                // 检查上下文是否已取消
                select </span>{
                case &lt;-bp.converter.ctx.Done():<span class="cov0" title="0">
                        // 深度分析被取消
                        return bp.converter.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">wg.Add(1)
                fileCopy := file // 避免闭包变量问题
                err := pool.Submit(func() </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // 为每个文件创建带超时的上下文
                        ctx, cancel := context.WithTimeout(bp.converter.ctx, 30*time.Second)
                        defer cancel()

                        // 在goroutine中执行分析
                        done := make(chan bool, 1)
                        go func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        done &lt;- true
                                }</span>()

                                // 调用 ffprobe 获取详细媒体信息
                                <span class="cov0" title="0">mediaInfo, err := bp.getMediaInfo(fileCopy.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        bp.logger.Warn("获取媒体信息失败", zap.String("file", fileCopy.Path), zap.Error(err))
                                        // 标记文件为损坏
                                        if info, exists := mediaInfoMap[fileCopy.Path]; exists </span><span class="cov0" title="0">{
                                                info.IsCorrupted = true
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }

                                // 更新媒体信息
                                <span class="cov0" title="0">if info, exists := mediaInfoMap[fileCopy.Path]; exists </span><span class="cov0" title="0">{
                                        info.Codec = mediaInfo.Codec
                                        info.FrameCount = mediaInfo.FrameCount
                                        info.IsAnimated = mediaInfo.IsAnimated
                                        info.IsCorrupted = mediaInfo.IsCorrupted
                                        info.InitialQuality = mediaInfo.InitialQuality
                                        info.Container = mediaInfo.Container
                                        info.IsCodecIncompatible = mediaInfo.IsCodecIncompatible
                                        info.IsContainerIncompatible = mediaInfo.IsContainerIncompatible
                                }</span>
                        }()

                        // 等待分析完成或超时
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // 超时或取消
                                bp.logger.Warn("文件深度分析超时", zap.String("file", fileCopy.Path))
                                // 标记文件为损坏
                                if mediaInfo, exists := mediaInfoMap[fileCopy.Path]; exists </span><span class="cov0" title="0">{
                                        mediaInfo.IsCorrupted = true
                                }</span>
                        case &lt;-done:<span class="cov0" title="0"></span>
                                // 分析完成
                        }

                        // 原子更新分析计数
                        <span class="cov0" title="0">currentCount := atomic.AddInt64(&amp;analyzedCount, 1)

                        // 更新进度条 - 使用字符串构建器避免fmt.Sprintf
                        var progressMsg strings.Builder
                        progressMsg.WriteString("深度分析 (")
                        progressMsg.WriteString(strconv.FormatInt(currentCount, 10))
                        progressMsg.WriteString("/")
                        progressMsg.WriteString(strconv.Itoa(len(filesToAnalyze)))
                        progressMsg.WriteString(")")
                        ui.UpdateNamedProgress("analysis", currentCount, progressMsg.String())

                        if currentCount%10 == 0 </span>{<span class="cov0" title="0">
                                // 深度分析进度
                        }</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        bp.logger.Error("提交深度分析任务失败", zap.String("file", fileCopy.Path), zap.Error(err))
                        wg.Done() // 如果提交失败，需要手动调用 Done
                }</span>
        }

        // 等待所有分析任务完成
        <span class="cov0" title="0">wg.Wait()

        // 深度分析完成
        return nil</span>
}

// getMediaInfo 使用 ffprobe 获取媒体文件信息
func (bp *BatchProcessor) getMediaInfo(filePath string) (*MediaInfo, error) <span class="cov0" title="0">{
        // 首先尝试从内存池获取媒体信息
        if cachedInfo := bp.memoryPool.GetMediaInfo(); cachedInfo != nil &amp;&amp; cachedInfo.FullPath == filePath </span><span class="cov0" title="0">{
                return cachedInfo, nil
        }</span>

        // 使用FFprobe获取媒体信息
        <span class="cov0" title="0">args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_format",
                "-show_streams",
                filePath,
        }

        cmd := exec.Command(bp.converter.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, bp.converter.errorHandler.WrapError("ffprobe failed", err)
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Format struct {
                        FormatName string `json:"format_name"`
                        Duration   string `json:"duration"`
                        BitRate    string `json:"bit_rate"`
                } `json:"format"`
                Streams []struct {
                        CodecName  string `json:"codec_name"`
                        CodecType  string `json:"codec_type"`
                        Width      int    `json:"width"`
                        Height     int    `json:"height"`
                        RFrameRate string `json:"r_frame_rate"`
                        ColorSpace string `json:"color_space"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil </span><span class="cov0" title="0">{
                return nil, bp.converter.errorHandler.WrapError("failed to parse ffprobe output", err)
        }</span>

        <span class="cov0" title="0">mediaInfo := &amp;MediaInfo{
                FullPath:                filePath,
                Codec:                   "",
                FrameCount:              1,
                IsAnimated:              false,
                IsCorrupted:             false,
                Container:               probeData.Format.FormatName,
                IsCodecIncompatible:     false,
                IsContainerIncompatible: false,
        }

        // 填充基本文件信息
        if fileInfo, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                mediaInfo.FileSize = fileInfo.Size()
                mediaInfo.ModTime = fileInfo.ModTime()
        }</span>

        // 解析编解码器信息
        <span class="cov0" title="0">if len(probeData.Streams) &gt; 0 </span><span class="cov0" title="0">{
                // 安全访问第一个流
                if firstStream := probeData.Streams[0]; firstStream.CodecName != "" </span><span class="cov0" title="0">{
                        mediaInfo.Codec = firstStream.CodecName
                }</span> else<span class="cov0" title="0"> {
                        bp.logger.Warn("第一个流的编解码器名称为空", zap.String("file", filePath))
                        mediaInfo.Codec = "unknown"
                }</span>

                // 检查编解码器是否不兼容
                <span class="cov0" title="0">mediaInfo.IsCodecIncompatible = bp.isCodecIncompatibleByFFprobe(probeData.Streams)</span>
        } else<span class="cov0" title="0"> {
                bp.logger.Warn("文件没有检测到任何流", zap.String("file", filePath))
                mediaInfo.Codec = "unknown"
                mediaInfo.IsCorrupted = true
        }</span>

        // 检查容器是否不兼容
        <span class="cov0" title="0">mediaInfo.IsContainerIncompatible = bp.isContainerIncompatibleByFFprobe(probeData.Format.FormatName)

        // 判断是否为动图或视频
        for _, stream := range probeData.Streams </span><span class="cov0" title="0">{
                if stream.CodecType == "video" </span><span class="cov0" title="0">{
                        // 检查帧率是否大于1来判断是否为动图
                        if stream.RFrameRate != "0/0" &amp;&amp; stream.RFrameRate != "1/1" </span><span class="cov0" title="0">{
                                mediaInfo.IsAnimated = true
                                mediaInfo.FrameCount = 10 // 简化处理，假设动图至少10帧
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return mediaInfo, nil</span>
}

// isCodecIncompatibleByFFprobe 根据FFprobe结果检查编解码器是否不兼容
func (bp *BatchProcessor) isCodecIncompatibleByFFprobe(streams []struct {
        CodecName  string `json:"codec_name"`
        CodecType  string `json:"codec_type"`
        Width      int    `json:"width"`
        Height     int    `json:"height"`
        RFrameRate string `json:"r_frame_rate"`
        ColorSpace string `json:"color_space"`
}) bool <span class="cov0" title="0">{
        // 这里可以添加具体的编解码器不兼容检查逻辑
        // 例如：检查是否为不支持的编解码器
        incompatibleCodecs := []string{"unsupported_codec1", "unsupported_codec2"}
        for _, stream := range streams </span><span class="cov0" title="0">{
                for _, codec := range incompatibleCodecs </span><span class="cov0" title="0">{
                        if stream.CodecName == codec </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// isContainerIncompatibleByFFprobe 根据FFprobe结果检查容器格式是否不兼容
func (bp *BatchProcessor) isContainerIncompatibleByFFprobe(formatName string) bool <span class="cov0" title="0">{
        // 这里可以添加具体的容器格式不兼容检查逻辑
        // 例如：检查是否为不支持的容器格式
        incompatibleContainers := []string{"unsupported_container1", "unsupported_container2"}
        for _, container := range incompatibleContainers </span><span class="cov0" title="0">{
                if formatName == container </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HandleCorruptedFiles 处理损坏文件 (批量决策阶段)
// CorruptedFileAction 定义损坏文件处理动作
type CorruptedFileAction int

const (
        ActionIgnore CorruptedFileAction = iota
        ActionDelete
        ActionMoveToTrash
)

// CorruptedFileHandler 处理损坏文件的核心逻辑
type CorruptedFileHandler struct {
        logger *zap.Logger
}

func (h *CorruptedFileHandler) executeAction(action CorruptedFileAction, files []*MediaFile) error <span class="cov0" title="0">{
        switch action </span>{
        case ActionDelete:<span class="cov0" title="0">
                return h.deleteFiles(files)</span>
        case ActionMoveToTrash:<span class="cov0" title="0">
                return h.moveToTrash(files)</span>
        default:<span class="cov0" title="0">
                // 忽略损坏文件
                return nil</span>
        }
}

func (h *CorruptedFileHandler) deleteFiles(files []*MediaFile) error <span class="cov0" title="0">{
        // 删除损坏文件
        for _, file := range files </span><span class="cov0" title="0">{
                if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("删除失败", zap.String("file", file.Path), zap.Error(err))
                }</span> else <span class="cov0" title="0">{
                        // 删除成功
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *CorruptedFileHandler) moveToTrash(files []*MediaFile) error <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">firstPath, err := GlobalPathUtils.NormalizePath(files[0].Path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("路径规范化失败: %w", err)
        }</span>

        <span class="cov0" title="0">trashDir, err := GlobalPathUtils.JoinPath(GlobalPathUtils.GetDirName(firstPath), ".trash")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("构建垃圾箱路径失败: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(trashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建垃圾箱目录失败: %w", err)
        }</span>

        // 移动到垃圾箱
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                normalizedPath, err := GlobalPathUtils.NormalizePath(file.Path)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("路径规范化失败", zap.String("path", file.Path), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">trashPath, err := GlobalPathUtils.JoinPath(trashDir, GlobalPathUtils.GetBaseName(normalizedPath))
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("构建垃圾箱文件路径失败", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if err := os.Rename(file.Path, trashPath); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("移动失败", zap.String("file", file.Path), zap.Error(err))
                }</span> else <span class="cov0" title="0">{
                        // 移动成功
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (bp *BatchProcessor) HandleCorruptedFiles() error <span class="cov0" title="0">{
        bp.mutex.RLock()
        if len(bp.corruptedFiles) == 0 </span><span class="cov0" title="0">{
                bp.mutex.RUnlock()
                return nil
        }</span>
        // 直接使用原始切片，避免内存拷贝
        <span class="cov0" title="0">corruptedFiles := bp.corruptedFiles
        bp.mutex.RUnlock()

        handler := &amp;CorruptedFileHandler{logger: bp.logger}
        action := bp.determineAction(corruptedFiles)

        if err := handler.executeAction(action, corruptedFiles); err != nil </span><span class="cov0" title="0">{
                bp.logger.Error("处理损坏文件失败", zap.Error(err))
                return err
        }</span>

        // 只有删除或移动操作才需要清理任务队列
        <span class="cov0" title="0">if action == ActionDelete || action == ActionMoveToTrash </span><span class="cov0" title="0">{
                bp.removeCorruptedFromQueue(corruptedFiles)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (bp *BatchProcessor) determineAction(files []*MediaFile) CorruptedFileAction <span class="cov0" title="0">{
        strategy := bp.converter.config.ProblemFileHandling.CorruptedFileStrategy

        switch strategy </span>{
        case "delete":<span class="cov0" title="0">
                return ActionDelete</span>
        case "move_to_trash":<span class="cov0" title="0">
                return ActionMoveToTrash</span>
        case "ignore":<span class="cov0" title="0">
                return ActionIgnore</span>
        default:<span class="cov0" title="0">
                return bp.promptUserAction(files)</span>
        }
}

func (bp *BatchProcessor) promptUserAction(files []*MediaFile) CorruptedFileAction <span class="cov0" title="0">{
        // 发现损坏文件，需要用户决策

        for i, file := range files </span><span class="cov0" title="0">{
                bp.logger.Warn("损坏文件", zap.Int("index", i+1), zap.String("path", file.Path))
        }</span>

        <span class="cov0" title="0">output.WriteLine("\n请选择处理方式:")
        output.WriteLine("[D] 全部删除 (Delete All)")
        output.WriteLine("[I] 忽略不处理 (Ignore)")
        output.WriteLine("\n将在5秒后默认选择 [I] 忽略...")

        inputChan := make(chan string, 1)
        go func() </span><span class="cov0" title="0">{
                userInput, err := input.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        inputChan &lt;- ""
                        return
                }</span>
                <span class="cov0" title="0">inputChan &lt;- strings.TrimSpace(strings.ToLower(userInput))</span>
        }()

        <span class="cov0" title="0">timer := time.NewTimer(5 * time.Second)
        defer timer.Stop()

        var choice string
        select </span>{
        case choice = &lt;-inputChan:<span class="cov0" title="0"></span>
        case &lt;-timer.C:<span class="cov0" title="0">
                output.WriteLine("\n超时，自动选择 [I] 忽略")
                choice = "i"</span>
        }

        <span class="cov0" title="0">switch choice </span>{
        case "d":<span class="cov0" title="0">
                output.WriteLine("已删除所有损坏文件")
                return ActionDelete</span>
        default:<span class="cov0" title="0">
                output.WriteLine("忽略所有损坏文件")
                return ActionIgnore</span>
        }
}

func (bp *BatchProcessor) removeCorruptedFromQueue(corruptedFiles []*MediaFile) <span class="cov0" title="0">{
        bp.mutex.Lock()
        defer bp.mutex.Unlock()

        corruptedPaths := make(map[string]bool, len(corruptedFiles))
        for _, file := range corruptedFiles </span><span class="cov0" title="0">{
                corruptedPaths[file.Path] = true
        }</span>

        <span class="cov0" title="0">newQueue := make([]*MediaFile, 0, len(bp.taskQueue))
        for _, file := range bp.taskQueue </span><span class="cov0" title="0">{
                if !corruptedPaths[file.Path] </span><span class="cov0" title="0">{
                        newQueue = append(newQueue, file)
                }</span>
        }

        <span class="cov0" title="0">bp.taskQueue = newQueue
        bp.corruptedFiles = make([]*MediaFile, 0)</span>
}

// ProcessTaskQueue 处理任务队列 - 实现严格的批处理原子性
func (bp *BatchProcessor) ProcessTaskQueue() error <span class="cov0" title="0">{
        bp.mutex.RLock()
        taskQueue := make([]*MediaFile, len(bp.taskQueue))
        copy(taskQueue, bp.taskQueue)
        bp.mutex.RUnlock()

        if len(taskQueue) == 0 </span><span class="cov0" title="0">{
                // 没有文件需要处理
                // 即使没有文件处理，也要设置TotalDuration
                bp.mutex.Lock()
                if !bp.stats.StartTime.IsZero() </span><span class="cov0" title="0">{
                        bp.stats.TotalDuration = time.Since(bp.stats.StartTime)
                }</span>
                <span class="cov0" title="0">bp.mutex.Unlock()
                return nil</span>
        }

        // 开始批处理原子性操作

        // 阶段1: 预检查 - 确保所有文件都可以安全处理
        <span class="cov0" title="0">if err := bp.preValidateAllFiles(taskQueue); err != nil </span><span class="cov0" title="0">{
                return bp.converter.errorHandler.WrapError("预检查失败，批处理中止", err)
        }</span>

        // 阶段2: 原子性批处理 - 要么全部成功，要么全部回滚
        <span class="cov0" title="0">if err := bp.atomicBatchProcess(taskQueue); err != nil </span><span class="cov0" title="0">{
                return bp.converter.errorHandler.WrapError("原子性批处理失败", err)
        }</span>

        // 批处理原子性操作完成
        <span class="cov0" title="0">return nil</span>
}

// GetTaskQueue 获取任务队列
// GetTaskQueue 返回任务队列的只读视图，避免不必要的内存拷贝
func (bp *BatchProcessor) GetTaskQueue() []*MediaFile <span class="cov0" title="0">{
        bp.mutex.RLock()
        defer bp.mutex.RUnlock()
        return bp.taskQueue
}</span>

// GetCorruptedFiles 返回损坏文件列表的只读视图，避免不必要的内存拷贝
func (bp *BatchProcessor) GetCorruptedFiles() []*MediaFile <span class="cov0" title="0">{
        bp.mutex.RLock()
        defer bp.mutex.RUnlock()
        return bp.corruptedFiles
}</span>

// processFiles 处理文件
func (bp *BatchProcessor) processFiles(files []*MediaFile) error <span class="cov0" title="0">{
        // 注意：TotalFiles和StartTime已经在ScanAndAnalyze中设置，这里不需要重复设置

        // 启动转换进度条
        ui.StartNamedProgress("convert", int64(len(files)), "转换文件")
        defer ui.FinishNamedProgress("convert")

        // 记录开始处理
        // 开始批处理文件

        // 使用ants池进行并发控制，替代原有的goroutine+channel模式
        processedCount := int64(0)

        // 获取转换器的工作池
        workerPool := bp.converter.GetWorkerPool()
        if workerPool == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法获取工作池")
        }</span>

        // 使用WaitGroup等待所有任务完成
        <span class="cov0" title="0">var wg sync.WaitGroup

        // 提交所有文件处理任务到ants池
        for i, file := range files </span><span class="cov0" title="0">{
                // 检查是否收到中断信号
                select </span>{
                case &lt;-bp.ctx.Done():<span class="cov0" title="0">
                        // 收到中断信号，停止启动新的转换任务
                        return bp.ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">wg.Add(1)
                currentFile := file

                // 提交任务到高级ants池，使用普通优先级
                taskID := fmt.Sprintf("batch_task_%d", i)
                err := workerPool.SubmitWithPriority(func() </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // 在任务内部检查中断信号
                        select </span>{
                        case &lt;-bp.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        // 处理文件（Converter的processFile方法会自动更新统计信息）
                        <span class="cov0" title="0">_ = bp.converter.processFile(currentFile)
                        // 注意：UpdateStats已经在processFile内部调用，这里不需要重复调用

                        // 更新进度
                        processed := atomic.AddInt64(&amp;processedCount, 1)
                        var progressMsg strings.Builder
                        progressMsg.WriteString("转换中 (")
                        progressMsg.WriteString(strconv.FormatInt(processed, 10))
                        progressMsg.WriteString("/")
                        progressMsg.WriteString(strconv.Itoa(len(files)))
                        progressMsg.WriteString(")")
                        ui.UpdateNamedProgress("convert", processed, progressMsg.String())</span>
                }, PriorityNormal, taskID)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        wg.Done() // 如果提交失败，需要减少计数器
                        bp.logger.Error("提交任务到高级池失败", zap.String("file", currentFile.Path), zap.Error(err))
                }</span>
        }

        // 等待所有任务完成
        <span class="cov0" title="0">wg.Wait()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package converter

import (
        "encoding/json"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "go.etcd.io/bbolt"
        "go.uber.org/zap"
)

// FileStatus 文件处理状态
type FileStatus int

const (
        StatusPending FileStatus = iota
        StatusProcessing
        StatusCompleted
        StatusFailed
        StatusSkipped
)

// String 返回状态字符串
func (s FileStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusPending:<span class="cov0" title="0">
                return "pending"</span>
        case StatusProcessing:<span class="cov0" title="0">
                return "processing"</span>
        case StatusCompleted:<span class="cov0" title="0">
                return "completed"</span>
        case StatusFailed:<span class="cov0" title="0">
                return "failed"</span>
        case StatusSkipped:<span class="cov0" title="0">
                return "skipped"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// FileRecord 文件处理记录
type FileRecord struct {
        FilePath     string     `json:"file_path"`
        Status       FileStatus `json:"status"`
        StartTime    time.Time  `json:"start_time"`
        EndTime      time.Time  `json:"end_time"`
        ErrorMessage string     `json:"error_message,omitempty"`
        OutputPath   string     `json:"output_path,omitempty"`
        FileSize     int64      `json:"file_size"`
        Mode         string     `json:"mode"`
}

// SessionInfo 转换会话信息
type SessionInfo struct {
        SessionID  string    `json:"session_id"`
        TargetDir  string    `json:"target_dir"`
        Mode       string    `json:"mode"`
        StartTime  time.Time `json:"start_time"`
        LastUpdate time.Time `json:"last_update"`
        TotalFiles int       `json:"total_files"`
        Processed  int       `json:"processed"`
        Completed  int       `json:"completed"`
        Failed     int       `json:"failed"`
        Skipped    int       `json:"skipped"`
}

// CheckpointManager 断点续传管理器
type CheckpointManager struct {
        db           *bbolt.DB
        logger       *zap.Logger
        mutex        sync.RWMutex
        sessionID    string
        session      *SessionInfo
        dbPath       string
        errorHandler *ErrorHandler
}

// 数据库bucket名称
const (
        SessionBucket = "sessions"
        FilesBucket   = "files"
)

// NewCheckpointManager 创建新的断点续传管理器
func NewCheckpointManager(logger *zap.Logger, targetDir string, errorHandler *ErrorHandler) (*CheckpointManager, error) <span class="cov8" title="1">{
        // 创建数据库文件路径
        dbDir := filepath.Join(os.TempDir(), "pixly_checkpoints")
        if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, errorHandler.WrapError("创建检查点目录失败", err)
        }</span>

        <span class="cov8" title="1">dbPath := filepath.Join(dbDir, "conversion.db")

        // 打开数据库 - 增加超时时间并添加重试机制
        var db *bbolt.DB
        var err error

        // 重试机制：最多尝试3次
        for i := 0; i &lt; 3; i++ </span><span class="cov8" title="1">{
                db, err = bbolt.Open(dbPath, 0600, &amp;bbolt.Options{
                        Timeout: 30 * time.Second, // 增加超时时间
                })
                if err == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                // 如果是超时错误，尝试删除可能损坏的数据库文件
                <span class="cov0" title="0">if i &lt; 2 </span><span class="cov0" title="0">{ // 前两次尝试时
                        if os.Remove(dbPath) == nil </span><span class="cov0" title="0">{
                                logger.Warn("删除可能损坏的数据库文件", zap.String("path", dbPath))
                        }</span>
                        <span class="cov0" title="0">time.Sleep(time.Second)</span> // 等待1秒后重试
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errorHandler.WrapError("打开检查点数据库失败", err)
        }</span>

        // 创建buckets
        <span class="cov8" title="1">err = db.Update(func(tx *bbolt.Tx) error </span><span class="cov8" title="1">{
                if _, err := tx.CreateBucketIfNotExists([]byte(SessionBucket)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := tx.CreateBucketIfNotExists([]byte(FilesBucket)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, errorHandler.WrapError("初始化数据库失败", err)
        }</span>

        <span class="cov8" title="1">cm := &amp;CheckpointManager{
                db:           db,
                logger:       logger,
                dbPath:       dbPath,
                errorHandler: errorHandler,
        }

        return cm, nil</span>
}

// StartSession 开始新的转换会话
func (cm *CheckpointManager) StartSession(targetDir, mode string, totalFiles int) error <span class="cov0" title="0">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        // 生成会话ID
        var builder strings.Builder
        builder.WriteString(filepath.Base(targetDir))
        builder.WriteString("_")
        builder.WriteString(strconv.FormatInt(time.Now().Unix(), 10))
        cm.sessionID = builder.String()

        // 创建会话信息
        cm.session = &amp;SessionInfo{
                SessionID:  cm.sessionID,
                TargetDir:  targetDir,
                Mode:       mode,
                StartTime:  time.Now(),
                LastUpdate: time.Now(),
                TotalFiles: totalFiles,
        }

        // 保存到数据库
        return cm.saveSession()
}</span>

// ResumeSession 恢复会话
func (cm *CheckpointManager) ResumeSession(sessionID string) (*SessionInfo, error) <span class="cov0" title="0">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        cm.sessionID = sessionID

        // 从数据库加载会话
        err := cm.db.View(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket([]byte(SessionBucket))
                data := b.Get([]byte(sessionID))
                if data == nil </span><span class="cov0" title="0">{
                        var builder strings.Builder
                        builder.WriteString("会话不存在: sessionID: ")
                        builder.WriteString(sessionID)
                        return cm.errorHandler.WrapError(builder.String(), nil)
                }</span>

                <span class="cov0" title="0">return json.Unmarshal(data, &amp;cm.session)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cm.session, nil</span>
}

// ListSessions 列出所有可恢复的会话
func (cm *CheckpointManager) ListSessions() ([]*SessionInfo, error) <span class="cov0" title="0">{
        var sessions []*SessionInfo

        err := cm.db.View(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket([]byte(SessionBucket))
                return b.ForEach(func(k, v []byte) error </span><span class="cov0" title="0">{
                        var session SessionInfo
                        if err := json.Unmarshal(v, &amp;session); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">sessions = append(sessions, &amp;session)
                        return nil</span>
                })
        })

        <span class="cov0" title="0">return sessions, err</span>
}

// UpdateFileStatus 更新文件状态 - 原子操作，立即同步到磁盘
func (cm *CheckpointManager) UpdateFileStatus(filePath string, status FileStatus, errorMsg string, outputPath string) error <span class="cov0" title="0">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        if cm.sessionID == "" </span><span class="cov0" title="0">{
                return cm.errorHandler.WrapError("没有活动会话", nil)
        }</span>

        // 获取文件信息
        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        var fileSize int64
        if err == nil </span><span class="cov0" title="0">{
                fileSize = fileInfo.Size()
        }</span>

        // 创建文件记录
        <span class="cov0" title="0">record := &amp;FileRecord{
                FilePath:     filePath,
                Status:       status,
                StartTime:    time.Now(),
                EndTime:      time.Now(),
                ErrorMessage: errorMsg,
                OutputPath:   outputPath,
                FileSize:     fileSize,
                Mode:         cm.session.Mode,
        }

        // 如果是开始处理，只设置开始时间
        if status == StatusProcessing </span><span class="cov0" title="0">{
                record.EndTime = time.Time{}
        }</span>

        // 原子保存文件记录和会话状态
        <span class="cov0" title="0">var keyBuilder strings.Builder
        keyBuilder.WriteString(cm.sessionID)
        keyBuilder.WriteString(":")
        keyBuilder.WriteString(filePath)
        key := keyBuilder.String()
        err = cm.db.Update(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                // 保存文件记录
                filesBucket := tx.Bucket([]byte(FilesBucket))
                data, err := json.Marshal(record)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := filesBucket.Put([]byte(key), data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 同时更新会话统计
                <span class="cov0" title="0">cm.updateSessionStats(status)

                // 保存会话状态
                sessionBucket := tx.Bucket([]byte(SessionBucket))
                sessionData, err := json.Marshal(cm.session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return sessionBucket.Put([]byte(cm.sessionID), sessionData)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 强制同步到磁盘 - 确保断电也不丢失
        <span class="cov0" title="0">return cm.db.Sync()</span>
}

// GetFileStatus 获取文件状态
func (cm *CheckpointManager) GetFileStatus(filePath string) (*FileRecord, error) <span class="cov0" title="0">{
        cm.mutex.RLock()
        defer cm.mutex.RUnlock()

        if cm.sessionID == "" </span><span class="cov0" title="0">{
                return nil, cm.errorHandler.WrapError("没有活动会话", nil)
        }</span>

        <span class="cov0" title="0">var keyBuilder strings.Builder
        keyBuilder.WriteString(cm.sessionID)
        keyBuilder.WriteString(":")
        keyBuilder.WriteString(filePath)
        key := keyBuilder.String()
        var record FileRecord

        err := cm.db.View(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket([]byte(FilesBucket))
                data := b.Get([]byte(key))
                if data == nil </span><span class="cov0" title="0">{
                        return cm.errorHandler.WrapError("文件记录不存在", nil)
                }</span>
                <span class="cov0" title="0">return json.Unmarshal(data, &amp;record)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;record, nil</span>
}

// GetPendingFiles 获取待处理的文件列表
func (cm *CheckpointManager) GetPendingFiles() ([]string, error) <span class="cov0" title="0">{
        cm.mutex.RLock()
        defer cm.mutex.RUnlock()

        if cm.sessionID == "" </span><span class="cov0" title="0">{
                return nil, cm.errorHandler.WrapError("没有活动会话", nil)
        }</span>

        <span class="cov0" title="0">var pendingFiles []string
        prefix := cm.sessionID + ":"

        err := cm.db.View(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket([]byte(FilesBucket))
                c := b.Cursor()

                for k, v := c.Seek([]byte(prefix)); k != nil &amp;&amp; string(k)[:len(prefix)] == prefix; k, v = c.Next() </span><span class="cov0" title="0">{
                        var record FileRecord
                        if err := json.Unmarshal(v, &amp;record); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if record.Status == StatusPending </span><span class="cov0" title="0">{
                                pendingFiles = append(pendingFiles, record.FilePath)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return pendingFiles, err</span>
}

// SaveCurrentState 保存当前状态 - 强制同步到磁盘
func (cm *CheckpointManager) SaveCurrentState() error <span class="cov0" title="0">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        if cm.session == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cm.session.LastUpdate = time.Now()
        if err := cm.saveSession(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 强制同步到磁盘
        <span class="cov0" title="0">return cm.db.Sync()</span>
}

// CleanupSession 清理会话
func (cm *CheckpointManager) CleanupSession(sessionID string) error <span class="cov0" title="0">{
        cm.mutex.Lock()
        defer cm.mutex.Unlock()

        return cm.db.Update(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                // 删除会话
                sessionBucket := tx.Bucket([]byte(SessionBucket))
                if err := sessionBucket.Delete([]byte(sessionID)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 删除相关文件记录
                <span class="cov0" title="0">filesBucket := tx.Bucket([]byte(FilesBucket))
                c := filesBucket.Cursor()
                prefix := sessionID + ":"

                var keysToDelete [][]byte
                for k, v := c.Seek([]byte(prefix)); k != nil &amp;&amp; string(k)[:len(prefix)] == prefix; k, v = c.Next() </span><span class="cov0" title="0">{
                        // v is the value associated with the key, we don't need it for deletion
                        _ = v // explicitly acknowledge we're not using the value
                        keysToDelete = append(keysToDelete, append([]byte(nil), k...))
                }</span>

                <span class="cov0" title="0">for _, key := range keysToDelete </span><span class="cov0" title="0">{
                        if err := filesBucket.Delete(key); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

// Close 关闭检查点管理器
func (cm *CheckpointManager) Close() error <span class="cov8" title="1">{
        if cm.db != nil </span><span class="cov8" title="1">{
                return cm.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// saveSession 保存会话到数据库
func (cm *CheckpointManager) saveSession() error <span class="cov0" title="0">{
        if cm.session == nil </span><span class="cov0" title="0">{
                return cm.errorHandler.WrapError("没有会话数据", nil)
        }</span>

        <span class="cov0" title="0">return cm.db.Update(func(tx *bbolt.Tx) error </span><span class="cov0" title="0">{
                b := tx.Bucket([]byte(SessionBucket))
                data, err := json.Marshal(cm.session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return b.Put([]byte(cm.sessionID), data)</span>
        })
}

// updateSessionStats 更新会话统计
func (cm *CheckpointManager) updateSessionStats(status FileStatus) <span class="cov0" title="0">{
        if cm.session == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch status </span>{
        case StatusProcessing:<span class="cov0" title="0">
                cm.session.Processed++</span>
        case StatusCompleted:<span class="cov0" title="0">
                cm.session.Completed++</span>
        case StatusFailed:<span class="cov0" title="0">
                cm.session.Failed++</span>
        case StatusSkipped:<span class="cov0" title="0">
                cm.session.Skipped++</span>
        }

        <span class="cov0" title="0">cm.session.LastUpdate = time.Now()</span>
}

// GetSessionInfo 获取当前会话信息
func (cm *CheckpointManager) GetSessionInfo() *SessionInfo <span class="cov0" title="0">{
        cm.mutex.RLock()
        defer cm.mutex.RUnlock()
        return cm.session
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package converter

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
)

// ConversionConfig 统一的转换配置
type ConversionConfig struct {
        OutputExtension string
        ToolPath        string
        ArgsBuilder     func(input, output string, quality int) []string
        PreProcessor    func(inputPath string) (processedPath string, cleanup func(), err error)
        PostProcessor   func(outputPath string) error
}

// ConversionFramework 统一的转换框架，消除重复代码
type ConversionFramework struct {
        converter *Converter
}

// NewConversionFramework 创建转换框架
func NewConversionFramework(converter *Converter) *ConversionFramework <span class="cov0" title="0">{
        return &amp;ConversionFramework{
                converter: converter,
        }
}</span>

// Execute 执行统一的转换流程，消除所有特殊情况
func (cf *ConversionFramework) Execute(file *MediaFile, config ConversionConfig, quality int) (string, error) <span class="cov0" title="0">{
        // 1. 计算输出路径（统一逻辑）
        outputPath := cf.converter.getOutputPath(file, config.OutputExtension)

        // 2. 处理原地转换（统一逻辑）
        isInPlace := cf.converter.config.Output.DirectoryTemplate == ""
        actualOutputPath := cf.prepareOutputPath(outputPath, isInPlace)

        // 3. 预处理输入文件（可选）
        inputPath := file.Path
        var cleanup func()
        if config.PreProcessor != nil </span><span class="cov0" title="0">{
                processedPath, cleanupFunc, err := config.PreProcessor(file.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return "", cf.converter.errorHandler.WrapError("preprocessing failed", err)
                }</span>
                <span class="cov0" title="0">inputPath = processedPath
                cleanup = cleanupFunc</span>
        }

        // 4. 清理函数（统一逻辑）
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cleanup != nil </span><span class="cov0" title="0">{
                        cleanup()
                }</span>
                <span class="cov0" title="0">cf.cleanupTempFile(actualOutputPath, outputPath)</span>
        }()

        // 5. 构建命令参数
        <span class="cov0" title="0">args := config.ArgsBuilder(inputPath, actualOutputPath, quality)

        // 6. 执行转换命令（统一逻辑）
        output, err := cf.converter.toolManager.ExecuteWithPathValidation(config.ToolPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", cf.converter.errorHandler.WrapErrorWithOutput("conversion failed", err, output)
        }</span>

        // 7. 后处理（可选）
        <span class="cov0" title="0">if config.PostProcessor != nil </span><span class="cov0" title="0">{
                if err := config.PostProcessor(actualOutputPath); err != nil </span><span class="cov0" title="0">{
                        return "", cf.converter.errorHandler.WrapError("post-processing failed", err)
                }</span>
        }

        // 8. 验证临时文件（在移动之前验证）
        <span class="cov0" title="0">if !cf.converter.verifyOutputFile(actualOutputPath, file.Size) </span><span class="cov0" title="0">{
                var errorBuilder strings.Builder
                errorBuilder.WriteString("temp file verification failed: path: ")
                errorBuilder.WriteString(actualOutputPath)
                return "", cf.converter.errorHandler.WrapError(errorBuilder.String(), nil)
        }</span>

        // 9. 移动临时文件到最终位置（统一逻辑）
        <span class="cov0" title="0">if err := cf.finalizeTempFile(actualOutputPath, outputPath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Conversion completed

        <span class="cov0" title="0">return outputPath, nil</span>
}

// prepareOutputPath 准备输出路径（统一逻辑）
func (cf *ConversionFramework) prepareOutputPath(outputPath string, isInPlace bool) string <span class="cov0" title="0">{
        actualOutputPath := outputPath + ".tmp"

        if !isInPlace </span><span class="cov0" title="0">{
                // 确保输出目录存在
                os.MkdirAll(filepath.Dir(outputPath), 0755)
        }</span>
        // 对于原地转换，我们仍然需要确保目录存在
        <span class="cov0" title="0">os.MkdirAll(filepath.Dir(outputPath), 0755)

        return actualOutputPath</span>
}

// cleanupTempFile 清理临时文件（统一逻辑）
func (cf *ConversionFramework) cleanupTempFile(actualOutputPath, outputPath string) <span class="cov0" title="0">{
        if actualOutputPath != outputPath </span><span class="cov0" title="0">{
                // 检查最终文件是否存在，如果不存在说明转换失败，需要清理临时文件
                if _, err := os.Stat(outputPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        os.Remove(actualOutputPath)
                }</span>
                // 注意：对于原地转换成功的情况，原始文件的清理由finalizeTempFile处理
        }
}

// finalizeTempFile 完成临时文件处理（统一逻辑）
func (cf *ConversionFramework) finalizeTempFile(actualOutputPath, outputPath string) error <span class="cov0" title="0">{
        if actualOutputPath != outputPath </span><span class="cov0" title="0">{
                // 检查是否为原地转换
                isInPlace := cf.converter.config.Output.DirectoryTemplate == ""

                if isInPlace </span><span class="cov0" title="0">{
                        // 原地转换：删除原文件，重命名临时文件
                        // 注意：这里oldPath应该是原文件路径，outputPath是新文件路径
                        // 在原地转换中，actualOutputPath是临时文件，outputPath是最终文件
                        if err := cf.converter.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, true); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 非原地转换：直接重命名临时文件
                        if err := os.Rename(actualOutputPath, outputPath); err != nil </span><span class="cov0" title="0">{
                                return cf.converter.errorHandler.WrapError("failed to move temp file to final location", err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// 预定义的转换配置，消除重复的参数构建逻辑

// JXLConfig JXL转换配置
func (cf *ConversionFramework) JXLConfig() ConversionConfig <span class="cov0" title="0">{
        return ConversionConfig{
                OutputExtension: ".jxl",
                ToolPath:        cf.converter.config.Tools.CjxlPath,
                ArgsBuilder: func(input, output string, quality int) []string </span><span class="cov0" title="0">{
                        return []string{
                                input,
                                output,
                                "-q", strconv.Itoa(quality),
                                "--lossless_jpeg=1",
                        }
                }</span>,
                PreProcessor: cf.universalToJXLPreProcessor,
        }
}

// AVIFConfig AVIF转换配置
func (cf *ConversionFramework) AVIFConfig() ConversionConfig <span class="cov0" title="0">{
        return ConversionConfig{
                OutputExtension: ".avif",
                ToolPath:        cf.converter.config.Tools.AvifencPath,
                ArgsBuilder: func(input, output string, quality int) []string </span><span class="cov0" title="0">{
                        return []string{
                                // 修复参数：使用--qcolor而不是-q，并调整参数顺序
                                "--qcolor", strconv.Itoa(quality),
                                "-s", "4",
                                "-j", "all",
                                input,
                                output,
                        }
                }</span>,
                PreProcessor: cf.universalToAVIFPreProcessor,
        }
}

// universalToAVIFPreProcessor 通用AVIF预处理器，处理avifenc不兼容的格式
func (cf *ConversionFramework) universalToAVIFPreProcessor(inputPath string) (string, func(), error) <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(inputPath))

        // 需要预处理的格式列表
        incompatibleFormats := map[string]bool{
                ".gif":  true,
                ".webp": true,
                ".bmp":  true,
                ".tiff": true,
                ".tif":  true,
        }

        if !incompatibleFormats[ext] </span><span class="cov0" title="0">{
                return inputPath, nil, nil
        }</span>

        // 创建临时PNG文件
        <span class="cov0" title="0">tempFile := inputPath + ".temp.png"
        os.Remove(tempFile) // 清理可能存在的临时文件

        // 使用FFmpeg将不兼容格式转换为PNG
        args := []string{
                "-i", inputPath,
        }

        // 对于GIF文件，只取第一帧
        if ext == ".gif" </span><span class="cov0" title="0">{
                args = append(args, "-vframes", "1")
        }</span>

        <span class="cov0" title="0">args = append(args, "-c:v", "png", "-y", tempFile)

        output, err := cf.converter.toolManager.ExecuteWithPathValidation(cf.converter.config.Tools.FFmpegPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(tempFile)
                var errorBuilder strings.Builder
                errorBuilder.WriteString(strings.ToUpper(ext[1:]))
                errorBuilder.WriteString(" to PNG conversion failed")
                return "", nil, cf.converter.errorHandler.WrapErrorWithOutput(errorBuilder.String(), err, output)
        }</span>

        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{
                os.Remove(tempFile)
        }</span>

        <span class="cov0" title="0">return tempFile, cleanup, nil</span>
}

// universalToJXLPreProcessor 通用JXL预处理器：处理JXL编码器不直接支持的静态GIF（取第一帧转PNG）
func (cf *ConversionFramework) universalToJXLPreProcessor(inputPath string) (string, func(), error) <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(inputPath))

        // 目前仅对 GIF 进行预处理（提取第一帧为 PNG）
        if ext != ".gif" </span><span class="cov0" title="0">{
                return inputPath, nil, nil
        }</span>

        // 生成临时 PNG 文件路径
        <span class="cov0" title="0">tempFile := inputPath + ".temp.png"
        _ = os.Remove(tempFile) // 预清理

        // 使用 FFmpeg 提取第一帧为 PNG
        args := []string{
                "-i", inputPath,
                "-vframes", "1",
                "-c:v", "png",
                "-y", tempFile,
        }

        output, err := cf.converter.toolManager.ExecuteWithPathValidation(cf.converter.config.Tools.FFmpegPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tempFile)
                return "", nil, cf.converter.errorHandler.WrapErrorWithOutput("GIF to PNG conversion failed", err, output)
        }</span>

        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{ _ = os.Remove(tempFile) }</span>
        <span class="cov0" title="0">return tempFile, cleanup, nil</span>
}

// validateConversionResult 验证转换结果完整性
func (cf *ConversionFramework) validateConversionResult(inputPath, outputPath string) error <span class="cov0" title="0">{
        // 检查输出文件是否存在
        if _, err := os.Stat(outputPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("转换输出文件不存在: %s", outputPath)
        }</span>

        // 检查文件大小
        <span class="cov0" title="0">outputInfo, err := os.Stat(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法获取输出文件信息: %v", err)
        }</span>

        // 输出文件不能为0字节
        <span class="cov0" title="0">if outputInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("转换输出文件为空")
        }</span>

        // 使用ffprobe验证AVIF文件完整性
        <span class="cov0" title="0">if strings.HasSuffix(strings.ToLower(outputPath), ".avif") </span><span class="cov0" title="0">{
                cmd := exec.Command("ffprobe", "-v", "error", "-select_streams", "v:0", "-show_entries", "stream=width,height,codec_name", "-of", "csv=p=0", outputPath)
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("AVIF文件验证失败: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// completeConversionWithValidation 完成转换并验证结果
func (cf *ConversionFramework) completeConversionWithValidation(inputPath, outputPath string, conversionResult error) error <span class="cov0" title="0">{
        if conversionResult != nil </span><span class="cov0" title="0">{
                return conversionResult
        }</span>

        // 验证转换结果
        <span class="cov0" title="0">if err := cf.validateConversionResult(inputPath, outputPath); err != nil </span><span class="cov0" title="0">{
                return cf.converter.errorHandler.WrapError("转换结果验证失败", err)
        }</span>

        // 记录转换统计
        <span class="cov0" title="0">cf.converter.mutex.Lock()
        cf.converter.stats.SuccessfulFiles++
        cf.converter.mutex.Unlock()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package converter

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "pixly/config"
        "pixly/internal/theme"
        "pixly/internal/ui"

        "go.uber.org/zap"
)

// MediaType 媒体类型枚举
type MediaType string

const (
        TypeImage MediaType = "image"
        TypeVideo MediaType = "video"
        // TypeAudio 已删除 - 根据README要求，本程序不处理音频文件
        TypeUnknown MediaType = "unknown"
)

// MediaFile 媒体文件结构
type MediaFile struct {
        Path         string
        Name         string
        Size         int64
        Extension    string
        Type         MediaType
        ModTime      time.Time
        IsCorrupted  bool
        IsLowQuality bool
        // 添加编解码器和容器不兼容标记
        IsCodecIncompatible     bool
        IsContainerIncompatible bool
        SkipReason             string // 跳过原因，用于记录为何跳过此文件
}

// ConversionMode 转换模式枚举
type ConversionMode string

const (
        ModeAutoPlus ConversionMode = "auto+"
        ModeQuality  ConversionMode = "quality"
        ModeEmoji    ConversionMode = "emoji"
)

// ConversionStats 转换统计信息
type ConversionStats struct {
        TotalFiles       int
        ProcessedFiles   int
        SuccessfulFiles  int
        FailedFiles      int
        SkippedFiles     int // 跳过的文件数量
        TotalSize        int64
        CompressedSize   int64
        StartTime        time.Time
        TotalDuration    time.Duration
        CompressionRatio float64
}

// ConversionResult 转换结果
type ConversionResult struct {
        OriginalFile     *MediaFile
        OutputPath       string
        OriginalSize     int64
        CompressedSize   int64
        CompressionRatio float64
        Duration         time.Duration
        Success          bool
        Method           string
        Error            error
        Skipped          bool   // 文件是否被跳过
        SkipReason       string // 跳过原因
}

// Converter 转换器主结构
type Converter struct {
        config           *config.Config
        logger           *zap.Logger
        mode             ConversionMode
        themeManager     *theme.ThemeManager
        stats            *ConversionStats
        results          []*ConversionResult
        strategy         ConversionStrategy
        watchdog         *ProgressWatchdog
        atomicOps        *AtomicFileOperations
        metadataManager  *MetadataManager
        toolManager      *ToolManager
        fileTypeDetector *FileTypeDetector
        checkpointMgr    *CheckpointManager
        signalHandler    *SignalHandler
        fileOpHandler    *FileOperationHandler // 统一文件操作处理器
        errorHandler     *ErrorHandler         // 统一错误处理器
        memoryPool       *MemoryPool           // 内存池

        // 增强系统组件已删除 - 根据"好品味"原则，删除过度设计的复杂日志系统

        // 控制信号
        ctx    context.Context
        cancel context.CancelFunc
        wg     sync.WaitGroup

        // 并发控制

        advancedPool *AdvancedPool // 高级ants池管理器

        // 线程安全
        mutex sync.RWMutex
}

// NewConverter 创建新的转换器实例
func NewConverter(config *config.Config, logger *zap.Logger, mode string) (*Converter, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        // 创建主题管理器
        themeManager := theme.NewThemeManager()

        // 增强扫描器已移除，简化架构

        // 创建看门狗
        watchdogConfig := GetDefaultWatchdogConfig()
        watchdog := NewProgressWatchdog(watchdogConfig, logger)

        // 创建统一处理器
        errorHandler := NewErrorHandler(logger)
        fileOpHandler := NewFileOperationHandler(logger)

        // 创建高级ants池配置
        advancedPoolConfig := GetDefaultAdvancedPoolConfig()
        advancedPoolConfig.InitialSize = config.Concurrency.ConversionWorkers
        advancedPoolConfig.MaxSize = config.Concurrency.ConversionWorkers * 2
        advancedPoolConfig.MinSize = 2
        advancedPoolConfig.EnablePriority = true
        advancedPoolConfig.EnableMetrics = true

        // 创建高级ants池（统一并发控制）
        advancedPool, err := NewAdvancedPool(advancedPoolConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建高级ants池失败: %w", err)
        }</span>

        <span class="cov8" title="1">converter := &amp;Converter{
                config:           config,
                logger:           logger,
                mode:             ConversionMode(mode),
                themeManager:     themeManager,
                stats:            &amp;ConversionStats{},
                results:          make([]*ConversionResult, 0),
                watchdog:         watchdog,
                atomicOps:        NewAtomicFileOperations(logger, config, errorHandler),
                metadataManager:  NewMetadataManager(logger, config, errorHandler),
                toolManager:      NewToolManager(config, logger, errorHandler),
                fileTypeDetector: NewFileTypeDetector(config, logger, NewToolManager(config, logger, errorHandler)),
                errorHandler:     errorHandler,
                fileOpHandler:    fileOpHandler,
                memoryPool:       GetGlobalMemoryPool(logger),
                ctx:              ctx,
                cancel:           cancel,
                advancedPool:     advancedPool,
        }

        // 创建转换策略
        converter.strategy = NewStrategy(converter.mode, converter)

        // 移除传统channel池，统一使用高级ants池

        // 初始化checkpoint管理器
        checkpointMgr, err := NewCheckpointManager(logger, "", errorHandler)
        if err != nil </span><span class="cov0" title="0">{
                advancedPool.Close() // 清理高级ants池
                return nil, errorHandler.WrapError("初始化checkpoint管理器失败", err)
        }</span>
        <span class="cov8" title="1">converter.checkpointMgr = checkpointMgr

        // 初始化信号处理器
        signalHandler := NewSignalHandler(logger, converter, checkpointMgr)
        converter.signalHandler = signalHandler

        // 启动看门狗
        converter.watchdog.Start()

        return converter, nil</span>
}

// NewConverterWithWatchdog 创建新的转换器实例，支持自定义看门狗配置
func NewConverterWithWatchdog(config *config.Config, logger *zap.Logger, mode string, watchdogConfig *WatchdogConfig) (*Converter, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // 创建主题管理器
        themeManager := theme.NewThemeManager()

        // 创建统一错误处理器
        errorHandler := NewErrorHandler(logger)

        // 创建文件操作处理器
        fileOpHandler := NewFileOperationHandler(logger)

        // 创建看门狗
        watchdog := NewProgressWatchdog(watchdogConfig, logger)

        // 创建高级ants池配置
        advancedPoolConfig := GetDefaultAdvancedPoolConfig()
        advancedPoolConfig.InitialSize = config.Concurrency.ConversionWorkers
        advancedPoolConfig.MaxSize = config.Concurrency.ConversionWorkers * 2
        advancedPoolConfig.MinSize = 2
        advancedPoolConfig.EnablePriority = true
        advancedPoolConfig.EnableMetrics = true

        // 创建高级ants池（统一并发控制）
        advancedPool, err := NewAdvancedPool(advancedPoolConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建高级ants池失败: %w", err)
        }</span>

        <span class="cov0" title="0">converter := &amp;Converter{
                config:           config,
                logger:           logger,
                mode:             ConversionMode(mode),
                themeManager:     themeManager,
                stats:            &amp;ConversionStats{},
                results:          make([]*ConversionResult, 0),
                watchdog:         watchdog,
                atomicOps:        NewAtomicFileOperations(logger, config, errorHandler),
                metadataManager:  NewMetadataManager(logger, config, errorHandler),
                toolManager:      NewToolManager(config, logger, errorHandler),
                fileTypeDetector: NewFileTypeDetector(config, logger, NewToolManager(config, logger, errorHandler)),
                errorHandler:     errorHandler,
                fileOpHandler:    fileOpHandler,
                memoryPool:       GetGlobalMemoryPool(logger),
                ctx:              ctx,
                cancel:           cancel,
                advancedPool:     advancedPool,
        }

        // 创建转换策略
        converter.strategy = NewStrategy(converter.mode, converter)

        // 初始化checkpoint管理器
        checkpointMgr, err := NewCheckpointManager(logger, "", errorHandler)
        if err != nil </span><span class="cov0" title="0">{
                advancedPool.Close() // 清理高级ants池
                return nil, errorHandler.WrapError("初始化checkpoint管理器失败", err)
        }</span>
        <span class="cov0" title="0">converter.checkpointMgr = checkpointMgr

        // 初始化信号处理器
        signalHandler := NewSignalHandler(logger, converter, checkpointMgr)
        converter.signalHandler = signalHandler

        // 启动看门狗
        converter.watchdog.Start()

        return converter, nil</span>
}

// GetWorkerPool 获取工作池，用于批处理器的并发控制
func (c *Converter) GetWorkerPool() *AdvancedPool <span class="cov0" title="0">{
        return c.advancedPool
}</span>

// Convert 执行转换操作
func (c *Converter) Convert(inputDir string) error <span class="cov0" title="0">{
        // 启动信号处理器
        c.signalHandler.Start()
        defer c.signalHandler.Stop()

        // 检查是否有未完成的会话需要恢复
        sessions, err := c.checkpointMgr.ListSessions()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("检查断点会话失败", zap.Error(err))
        }</span> else<span class="cov0" title="0"> if len(sessions) &gt; 0 </span><span class="cov0" title="0">{
                // 找到未完成的会话，询问用户是否恢复
                for _, session := range sessions </span><span class="cov0" title="0">{
                        if session.TargetDir == inputDir &amp;&amp; session.Mode == string(c.mode) </span><span class="cov0" title="0">{
                                // 发现未完成的转换会话

                                // 恢复会话
                                _, err = c.checkpointMgr.ResumeSession(session.SessionID)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Warn("恢复会话失败，将启动新会话", zap.Error(err))
                                        break</span>
                                }

                                // 成功恢复转换会话，继续处理未完成的文件
                                <span class="cov0" title="0">return c.resumeConversion(inputDir)</span>
                        }
                }
        }

        // 检查路径权限
        <span class="cov0" title="0">if err := c.checkPathPermissions(inputDir); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("路径权限检查失败", err)
        }</span>

        // 初始化统计信息开始时间
        <span class="cov0" title="0">c.mutex.Lock()
        c.stats.StartTime = time.Now()
        c.mutex.Unlock()

        // 创建批处理器
        batchProcessor := NewBatchProcessor(c, c.logger)

        // 使用批处理器进行统一扫描和分析
        if err := batchProcessor.ScanAndAnalyze(inputDir); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("扫描和分析文件失败", err)
        }</span>

        // 检查是否有文件需要处理
        <span class="cov0" title="0">if c.stats.TotalFiles == 0 </span><span class="cov0" title="0">{
                c.logger.Info("没有找到需要转换的文件")
                return nil
        }</span>

        // 启动新的转换会话
        <span class="cov0" title="0">err = c.checkpointMgr.StartSession(inputDir, string(c.mode), c.stats.TotalFiles)
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("启动转换会话失败", err)
        }</span>

        // 处理损坏文件
        <span class="cov0" title="0">if err := batchProcessor.HandleCorruptedFiles(); err != nil </span><span class="cov0" title="0">{
                // 记录错误但不中断转换过程
                c.logger.Warn("处理损坏文件时出错", zap.Error(err))
        }</span>

        // 处理任务队列
        <span class="cov0" title="0">if err := batchProcessor.ProcessTaskQueue(); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("处理任务队列失败", err)
        }</span>

        // 等待所有goroutine完成
        <span class="cov0" title="0">c.wg.Wait()

        // 最终计算统计信息
        if !c.stats.StartTime.IsZero() </span><span class="cov0" title="0">{
                c.stats.TotalDuration = time.Since(c.stats.StartTime)
        }</span>

        // 生成报告
        <span class="cov0" title="0">if err := c.generateReport(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("生成报告失败", zap.Error(err))
        }</span>

        // 清理会话
        <span class="cov0" title="0">sessionInfo := c.checkpointMgr.GetSessionInfo()
        if sessionInfo != nil </span><span class="cov0" title="0">{
                if err := c.checkpointMgr.CleanupSession(sessionInfo.SessionID); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("清理会话失败", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkPathPermissions 检查路径权限和白名单
func (c *Converter) checkPathPermissions(inputDir string) error <span class="cov0" title="0">{
        // 创建路径安全检查器
        pathChecker := NewPathSecurityChecker(c.config, c.logger, c.errorHandler)

        // 使用统一的安全检查选项（允许文件或目录）
        options := SecurityCheckOptions{
                CheckRead:        true,
                CheckWrite:       c.config.Output.KeepOriginal || c.config.Output.GenerateReport,
                RequireDirectory: false,
                CheckWhitelist:   true,
                CheckBlacklist:   true,
        }

        err := pathChecker.ValidatePath(inputDir, options)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("路径权限检查失败", zap.String("path", inputDir), zap.Error(err))
                return err
        }</span>

        // 路径权限检查通过
        <span class="cov0" title="0">return nil</span>
}

// scanFiles 扫描目录中的文件
func (c *Converter) scanFiles(inputDir string) ([]*MediaFile, error) <span class="cov0" title="0">{
        // 简化文件扫描逻辑
        // 开始扫描文件

        // 使用现代化的 filepath.WalkDir 进行文件遍历
        var files []*MediaFile
        err := filepath.WalkDir(inputDir, func(path string, d os.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if !c.isMediaFile(path) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 获取文件信息
                <span class="cov0" title="0">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("获取文件信息失败", zap.String("路径", path), zap.Error(err))
                        return nil
                }</span>

                // 使用GlobalPathUtils处理路径
                <span class="cov0" title="0">normalizedPath, pathErr := GlobalPathUtils.NormalizePath(path)
                if pathErr != nil </span><span class="cov0" title="0">{
                        c.logger.Error("路径规范化失败", zap.String("路径", path), zap.Error(pathErr))
                        return nil
                }</span>
                <span class="cov0" title="0">mediaFile := &amp;MediaFile{
                        Path:      normalizedPath,
                        Name:      GlobalPathUtils.GetBaseName(normalizedPath),
                        Size:      info.Size(),
                        Extension: strings.ToLower(GlobalPathUtils.GetExtension(normalizedPath)),
                        Type:      c.getFileType(GlobalPathUtils.GetExtension(normalizedPath)),
                        ModTime:   info.ModTime(),
                }
                files = append(files, mediaFile)
                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("文件扫描失败", zap.Error(err))
                return nil, err
        }</span>

        // 文件扫描完成
        <span class="cov0" title="0">return files, nil</span>
}

// isMediaFile 检查是否为媒体文件
func (c *Converter) isMediaFile(path string) bool <span class="cov0" title="0">{
        // 使用GlobalPathUtils处理路径
        normalizedPath, err := GlobalPathUtils.NormalizePath(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">ext := strings.ToLower(GlobalPathUtils.GetExtension(normalizedPath))

        // 使用配置文件中的支持扩展名白名单
        for _, supportedExt := range c.config.Conversion.SupportedExtensions </span><span class="cov0" title="0">{
                // 确保扩展名格式一致（都以.开头）
                normalizedSupportedExt := strings.ToLower(supportedExt)
                if !strings.HasPrefix(normalizedSupportedExt, ".") </span><span class="cov0" title="0">{
                        normalizedSupportedExt = "." + normalizedSupportedExt
                }</span>
                <span class="cov0" title="0">if ext == normalizedSupportedExt </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// getFileType 获取文件类型
func (c *Converter) getFileType(filePath string) MediaType <span class="cov0" title="0">{
        ext := strings.ToLower(GlobalPathUtils.GetExtension(filePath))
        
        // 修复扩展名处理：确保点前缀
        if !strings.HasPrefix(ext, ".") </span><span class="cov0" title="0">{
                ext = "." + ext
        }</span>
        
        // 映射扩展名到统一格式
        <span class="cov0" title="0">switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return ".jpg"</span>
        case ".png":<span class="cov0" title="0">
                return ".png"</span>
        case ".gif":<span class="cov0" title="0">
                return ".gif"</span>
        case ".webp":<span class="cov0" title="0">
                return ".webp"</span>
        case ".avif":<span class="cov0" title="0">
                return ".avif"</span>
        case ".jxl", ".jpeg-xl":<span class="cov0" title="0">
                return ".jxl"</span>
        case ".jfif":<span class="cov0" title="0">
                return ".jpg"</span> // JFIF作为JPEG处理
        default:<span class="cov0" title="0">
                return MediaType(ext)</span>
        }
}

// processFiles 处理文件
func (c *Converter) processFiles(files []*MediaFile) error <span class="cov0" title="0">{
        // 注意：统计信息已由BatchProcessor在ScanAndAnalyze阶段设置
        // 启动转换进度条
        ui.StartDynamicProgress(int64(len(files)), "转换处理")
        defer ui.FinishDynamicProgress()
        // 开始处理文件

        // 创建结果通道
        resultChan := make(chan *ConversionResult, len(files))

        // 启动goroutine处理每个文件
        for _, file := range files </span><span class="cov0" title="0">{
                c.wg.Add(1)
                file := file // 避免闭包问题

                // 确定任务优先级（大文件优先处理）
                priority := PriorityNormal
                if file.Size &gt; 50*1024*1024 </span><span class="cov0" title="0">{ // 50MB以上的文件
                        priority = PriorityHigh
                }</span> else<span class="cov0" title="0"> if file.Size &lt; 1024*1024 </span><span class="cov0" title="0">{ // 1MB以下的文件
                        priority = PriorityLow
                }</span>

                // 使用统一的高级池进行并发控制
                <span class="cov0" title="0">var taskIDBuilder strings.Builder
                taskIDBuilder.WriteString("file_")
                taskIDBuilder.WriteString(filepath.Base(file.Path))
                taskIDBuilder.WriteString("_")
                taskIDBuilder.WriteString(strconv.FormatInt(time.Now().UnixNano(), 10))
                taskID := taskIDBuilder.String()
                err := c.advancedPool.SubmitWithPriority(func() </span><span class="cov0" title="0">{
                        defer c.wg.Done()
                        result := c.processFile(file)
                        resultChan &lt;- result
                }</span>, priority, taskID)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.wg.Done() // 如果提交失败，需要减少计数器
                        c.logger.Error("提交任务到高级池失败", zap.String("file", file.Path), zap.Error(err))
                        // 创建失败结果
                        result := &amp;ConversionResult{
                                OriginalFile: file,
                                OriginalSize: file.Size,
                                Error:        err,
                                Success:      false,
                        }
                        resultChan &lt;- result
                }</span>
        }

        // 收集结果
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                c.wg.Wait()
                close(resultChan)
        }</span>()

        // 处理结果
        <span class="cov0" title="0">processedCount := int64(0)
        for result := range resultChan </span><span class="cov0" title="0">{
                // 在归还到内存池之前，先创建快照，避免后续复用导致数据被清零
                snapshot := *result

                c.mutex.Lock()
                c.results = append(c.results, &amp;snapshot)
                c.mutex.Unlock()

                // 更新统计信息使用快照，保证一致性
                c.UpdateStats(&amp;snapshot)

                // 结果已复制，安全归还原对象到内存池
                c.memoryPool.PutConversionResult(result)

                // 更新进度
                processedCount++
                ui.UpdateDynamicProgress(int64(processedCount), "转换处理")

                // 记录处理结果
                if snapshot.Success </span>{<span class="cov0" title="0">
                        // 文件处理成功
                }</span> else<span class="cov0" title="0"> {
                        c.logger.Error("文件处理失败", zap.String("文件", snapshot.OriginalFile.Name), zap.Error(snapshot.Error))
                }</span>
        }

        // 等待所有goroutine完成
        <span class="cov0" title="0">c.wg.Wait()

        // 进度条完成由BatchProcessor统一管理

        c.stats.TotalDuration = time.Since(c.stats.StartTime)
        // 文件处理完成
        return nil</span>
}

// processFile 处理单个文件
func (c *Converter) processFile(file *MediaFile) *ConversionResult <span class="cov0" title="0">{
        startTime := time.Now()

        c.logger.Debug("开始处理文件", zap.String("file", file.Path), zap.String("type", string(file.Type)))

        // 标记文件开始处理
        if err := c.checkpointMgr.UpdateFileStatus(file.Path, StatusProcessing, "", ""); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("更新文件状态失败", zap.String("file", file.Path), zap.Error(err))
        }</span>

        // 从内存池获取ConversionResult对象
        <span class="cov0" title="0">result := c.memoryPool.GetConversionResult()
        result.OriginalFile = file
        result.OriginalSize = file.Size
        // 初始化CompressedSize为0
        result.CompressedSize = 0

        defer func() </span><span class="cov0" title="0">{
                result.Duration = time.Since(startTime)

                // 保存最终状态
                var status FileStatus
                var errorMsg string
                if result.Success </span><span class="cov0" title="0">{
                        status = StatusCompleted
                }</span> else<span class="cov0" title="0"> if result.Skipped </span><span class="cov0" title="0">{
                        status = StatusSkipped
                        errorMsg = result.SkipReason
                }</span> else<span class="cov0" title="0"> {
                        status = StatusFailed
                        if result.Error != nil </span><span class="cov0" title="0">{
                                errorMsg = result.Error.Error()
                        }</span>
                }

                <span class="cov0" title="0">if err := c.checkpointMgr.UpdateFileStatus(file.Path, status, errorMsg, result.OutputPath); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("保存文件最终状态失败", zap.String("file", file.Path), zap.Error(err))
                }</span>

                // 更新统计信息
                <span class="cov0" title="0">c.UpdateStats(result)

                c.logger.Debug("文件处理完成",
                        zap.String("file", file.Path),
                        zap.Bool("success", result.Success),
                        zap.String("output", result.OutputPath),
                        zap.Error(result.Error))</span>
        }()

        // 使用文件类型检测器精确识别文件类型
        <span class="cov0" title="0">if c.fileTypeDetector != nil </span><span class="cov0" title="0">{
                c.logger.Debug("开始文件类型检测", zap.String("file", file.Path))
                details, err := c.fileTypeDetector.DetectFileType(file.Path)
                if err == nil &amp;&amp; !details.IsCorrupted </span><span class="cov0" title="0">{
                        // 根据精确的文件类型更新文件信息
                        switch details.FileType </span>{
                        case FileTypeVideo:<span class="cov0" title="0">
                                file.Type = TypeVideo
                                c.logger.Debug("检测为视频文件", zap.String("file", file.Path))</span>
                        // 音频文件不再支持，跳过处理
                        case FileTypeAnimatedImage:<span class="cov0" title="0">
                                file.Type = TypeImage
                                c.logger.Debug("检测为动图文件", zap.String("file", file.Path))</span>
                                // 标记为动图
                                // 这里可以添加额外的标记逻辑
                        case FileTypeStaticImage:<span class="cov0" title="0">
                                file.Type = TypeImage
                                c.logger.Debug("检测为静态图片文件", zap.String("file", file.Path))</span>
                        }
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("文件类型检测失败", zap.String("file", file.Path), zap.Error(err))
                }</span> else<span class="cov0" title="0"> if details.IsCorrupted </span><span class="cov0" title="0">{
                        c.logger.Warn("检测到损坏文件", zap.String("file", file.Path))
                }</span>
        }

        // 直接处理文件，避免不必要的goroutine创建
        // 根据文件类型分发处理逻辑
        <span class="cov0" title="0">c.logger.Debug("开始文件类型分发处理", zap.String("file", file.Path), zap.String("type", string(file.Type)))
        switch file.Type </span>{
        case TypeImage:<span class="cov0" title="0">
                c.logger.Debug("开始图片转换处理", zap.String("file", file.Path))
                // 使用策略模式处理图片转换
                var err error
                var outputPath string

                // 调用对应的转换策略
                outputPath, err = c.strategy.ConvertImage(file)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("图片转换失败", zap.String("file", file.Path), zap.Error(err))
                        result.Error = c.errorHandler.WrapError("图片转换失败", err)
                        result.Success = false
                }</span> else<span class="cov0" title="0"> {
                        c.logger.Debug("图片转换成功", zap.String("file", file.Path), zap.String("output", outputPath))
                        result.OutputPath = outputPath
                        // 获取实际转换后的文件大小
                        if stat, err := os.Stat(outputPath); err == nil </span><span class="cov0" title="0">{
                                result.CompressedSize = stat.Size()
                                result.Success = true
                                c.logger.Debug("获取输出文件信息成功", zap.String("file", file.Path), zap.Int64("size", stat.Size()))
                        }</span> else<span class="cov0" title="0"> {
                                c.logger.Error("无法获取输出文件信息", zap.String("file", file.Path), zap.Error(err))
                                result.Error = c.errorHandler.WrapError("无法获取输出文件信息", err)
                                result.Success = false
                        }</span>
                }

        case TypeVideo:<span class="cov0" title="0">
                c.logger.Debug("开始视频转换处理", zap.String("file", file.Path))
                // 使用策略模式处理视频转换
                outputPath, err := c.strategy.ConvertVideo(file)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("视频转换失败", zap.String("file", file.Path), zap.Error(err))
                        result.Error = c.errorHandler.WrapError("视频转换失败", err)
                        result.Success = false
                }</span> else<span class="cov0" title="0"> {
                        c.logger.Debug("视频转换成功", zap.String("file", file.Path), zap.String("output", outputPath))
                        result.OutputPath = outputPath
                        // 获取实际转换后的文件大小
                        if stat, err := os.Stat(outputPath); err == nil </span><span class="cov0" title="0">{
                                result.CompressedSize = stat.Size()
                                result.Success = true
                                c.logger.Debug("获取输出文件信息成功", zap.String("file", file.Path), zap.Int64("size", stat.Size()))
                        }</span> else<span class="cov0" title="0"> {
                                c.logger.Error("无法获取输出文件信息", zap.String("file", file.Path), zap.Error(err))
                                result.Error = c.errorHandler.WrapError("无法获取输出文件信息", err)
                                result.Success = false
                        }</span>
                }

        default:<span class="cov0" title="0">
                var errorBuilder strings.Builder
                errorBuilder.WriteString("不支持的文件类型: ")
                errorBuilder.WriteString(string(file.Type))
                c.logger.Error("不支持的文件类型", zap.String("file", file.Path), zap.String("type", string(file.Type)))
                result.Error = c.errorHandler.WrapError(errorBuilder.String(), nil)
                result.Success = false</span>
                // 不支持的文件类型
        }

        <span class="cov0" title="0">return result</span>
}

// UpdateStats 更新统计信息
func (c *Converter) UpdateStats(result *ConversionResult) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        c.stats.ProcessedFiles++

        // 累加原始文件大小到总大小
        c.stats.TotalSize += result.OriginalSize

        if result.Success </span><span class="cov0" title="0">{
                if result.Skipped </span><span class="cov0" title="0">{
                        c.stats.SkippedFiles++
                        // 跳过的文件保持原始大小
                        c.stats.CompressedSize += result.OriginalSize
                }</span> else<span class="cov0" title="0"> {
                        c.stats.SuccessfulFiles++
                        c.stats.CompressedSize += result.CompressedSize
                }</span>
        } else<span class="cov0" title="0"> {
                c.stats.FailedFiles++
                // 失败的文件也累加原始大小到压缩后大小，以避免压缩率为负数
                c.stats.CompressedSize += result.OriginalSize
        }</span>

        // 计算压缩率
        <span class="cov0" title="0">if c.stats.TotalSize &gt; 0 </span><span class="cov0" title="0">{
                // 确保压缩率不会是负数，当压缩后大小大于原始大小时，压缩率为0
                if c.stats.CompressedSize &lt; c.stats.TotalSize </span><span class="cov0" title="0">{
                        c.stats.CompressionRatio = float64(c.stats.TotalSize-c.stats.CompressedSize) / float64(c.stats.TotalSize) * 100
                }</span> else<span class="cov0" title="0"> {
                        c.stats.CompressionRatio = 0
                }</span>
        } else<span class="cov0" title="0"> {
                c.stats.CompressionRatio = 0
        }</span>
}

// isTargetFormat 检查是否为目标格式
func (c *Converter) IsTargetFormat(ext string) bool <span class="cov0" title="0">{
        // 严格定义最终目标格式：只有.jxl、.avif、.mov是最终目标格式
        // 其他所有格式（包括.mp4、.webm、.avi等）都不是目标格式，需要被转换或跳过
        ext = strings.ToLower(ext)
        switch ext </span>{
        case ".jxl", ".avif", ".mov":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// convertToAVIFAnimated 转换动图为AVIF（使用ffmpeg）
func (c *Converter) ConvertToAVIFAnimated(file *MediaFile) (string, error) <span class="cov0" title="0">{
        outputPath := c.getOutputPath(file, ".avif")

        // 使用FFmpeg将动图转换为AVIF格式
        // 根据README规定：表情包模式下动图使用ffmpeg处理
        fps, err := c.getVideoFPS(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapError("获取视频帧率失败", err)
        }</span>

        <span class="cov0" title="0">args := []string{
                "-i", file.Path,
                "-c:v", "libaom-av1", // 使用libaom AV1编码器
                "-crf", "30", // 适度压缩
                "-b:v", "0", // 使用CRF模式
                "-pix_fmt", "yuv420p", // 像素格式
                "-auto-alt-ref", "0", // 禁用自动参考帧
                "-lag-in-frames", "0", // 禁用帧延迟
                "-r", fmt.Sprintf("%f", fps), // 转换为字符串
                "-y", // 覆盖输出文件
                outputPath,
        }

        cmd := exec.CommandContext(c.ctx, c.config.Tools.FFmpegPath, args...)

        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapErrorWithOutput("ffmpeg AVIF animation conversion failed", err, output)
        }</span>

        <span class="cov0" title="0">return outputPath, nil</span>
}

// HandleCodecIncompatibility 处理编解码器不兼容文件
func (c *Converter) HandleCodecIncompatibility(files []*MediaFile) error <span class="cov0" title="0">{
        incompatibleFiles := make([]*MediaFile, 0)
        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsCodecIncompatible </span><span class="cov0" title="0">{
                        incompatibleFiles = append(incompatibleFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(incompatibleFiles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 检查是否启用了自动处理策略
        <span class="cov0" title="0">strategy := c.config.ProblemFileHandling.CodecIncompatibilityStrategy
        if strategy != "" &amp;&amp; strategy != "ignore" </span><span class="cov0" title="0">{
                // 使用配置驱动的编解码器不兼容文件处理策略

                switch strategy </span>{
                case "force_process":<span class="cov0" title="0">
                        // 强制处理，将这些文件添加到任务队列
                        // 强制处理编解码器不兼容文件
                        // 这些文件已经在任务队列中，不需要额外操作
                        return nil</span>

                case "move_to_trash":<span class="cov0" title="0">
                        // 移动到垃圾箱
                        // 使用GlobalPathUtils处理路径
                        firstFilePath, err := GlobalPathUtils.NormalizePath(incompatibleFiles[0].Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("无法规范化文件路径", err)
                        }</span>
                        <span class="cov0" title="0">trashDir, err := GlobalPathUtils.JoinPath(GlobalPathUtils.GetDirName(firstFilePath), ".trash")
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("构建垃圾箱目录路径失败", zap.Error(err))
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err := os.MkdirAll(trashDir, 0755); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("创建垃圾箱目录失败", zap.String("dir", trashDir), zap.Error(err))
                                // 回退到忽略策略
                                return nil
                        }</span>

                        // 移动编解码器不兼容文件到垃圾箱
                        <span class="cov0" title="0">for _, file := range incompatibleFiles </span><span class="cov0" title="0">{
                                // 使用GlobalPathUtils处理文件路径
                                normalizedFilePath, err := GlobalPathUtils.NormalizePath(file.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("路径规范化失败", zap.String("路径", file.Path), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">trashPath, err := GlobalPathUtils.JoinPath(trashDir, GlobalPathUtils.GetBaseName(normalizedFilePath))
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("构建垃圾箱文件路径失败", zap.String("路径", normalizedFilePath), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := os.Rename(file.Path, trashPath); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("移动编解码器不兼容文件到垃圾箱失败", zap.String("file", file.Path), zap.String("trash_path", trashPath), zap.Error(err))
                                }</span> else <span class="cov0" title="0">{
                                        // 已移动编解码器不兼容文件到垃圾箱
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>

                case "delete":<span class="cov0" title="0">
                        // 删除文件
                        // 删除编解码器不兼容文件
                        for _, file := range incompatibleFiles </span><span class="cov0" title="0">{
                                if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("删除编解码器不兼容文件失败", zap.String("file", file.Path), zap.Error(err))
                                }</span> else <span class="cov0" title="0">{
                                        // 已删除编解码器不兼容文件
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // 默认忽略策略
        // 忽略编解码器不兼容文件
        <span class="cov0" title="0">return nil</span>
}

// HandleContainerIncompatibility 处理容器不兼容文件
func (c *Converter) HandleContainerIncompatibility(files []*MediaFile) error <span class="cov0" title="0">{
        incompatibleFiles := make([]*MediaFile, 0)
        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsContainerIncompatible </span><span class="cov0" title="0">{
                        incompatibleFiles = append(incompatibleFiles, file)
                }</span>
        }

        <span class="cov0" title="0">if len(incompatibleFiles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 检查是否启用了自动处理策略
        <span class="cov0" title="0">strategy := c.config.ProblemFileHandling.ContainerIncompatibilityStrategy
        if strategy != "" &amp;&amp; strategy != "ignore" </span><span class="cov0" title="0">{
                // 使用配置驱动的容器不兼容文件处理策略

                switch strategy </span>{
                case "force_process":<span class="cov0" title="0">
                        // 强制处理，将这些文件添加到任务队列
                        // 强制处理容器不兼容文件
                        // 这些文件已经在任务队列中，不需要额外操作
                        return nil</span>

                case "move_to_trash":<span class="cov0" title="0">
                        // 移动到垃圾箱
                        // 使用GlobalPathUtils处理路径
                        firstFilePath, err := GlobalPathUtils.NormalizePath(incompatibleFiles[0].Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("无法规范化文件路径", err)
                        }</span>
                        <span class="cov0" title="0">trashDir, err := GlobalPathUtils.JoinPath(GlobalPathUtils.GetDirName(firstFilePath), ".trash")
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("构建垃圾箱目录路径失败", zap.Error(err))
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err := os.MkdirAll(trashDir, 0755); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("创建垃圾箱目录失败", zap.String("dir", trashDir), zap.Error(err))
                                // 回退到忽略策略
                                return nil
                        }</span>

                        // 移动容器不兼容文件到垃圾箱
                        <span class="cov0" title="0">for _, file := range incompatibleFiles </span><span class="cov0" title="0">{
                                // 使用GlobalPathUtils处理文件路径
                                normalizedFilePath, err := GlobalPathUtils.NormalizePath(file.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("路径规范化失败", zap.String("路径", file.Path), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">trashPath, err := GlobalPathUtils.JoinPath(trashDir, GlobalPathUtils.GetBaseName(normalizedFilePath))
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("构建垃圾箱文件路径失败", zap.String("路径", normalizedFilePath), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := os.Rename(file.Path, trashPath); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("移动容器不兼容文件到垃圾箱失败", zap.String("file", file.Path), zap.String("trash_path", trashPath), zap.Error(err))
                                }</span> else <span class="cov0" title="0">{
                                        // 已移动容器不兼容文件到垃圾箱
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>

                case "delete":<span class="cov0" title="0">
                        // 删除文件
                        // 删除容器不兼容文件
                        for _, file := range incompatibleFiles </span><span class="cov0" title="0">{
                                if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("删除容器不兼容文件失败", zap.String("file", file.Path), zap.Error(err))
                                }</span> else <span class="cov0" title="0">{
                                        // 已删除容器不兼容文件
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // 默认忽略策略
        // 忽略容器不兼容文件
        <span class="cov0" title="0">return nil</span>
}

// 以下方法已在各自文件中实现，这里只保留声明
// hasTransparency 在image.go中实现
// isAnimated 在image.go中实现
// convertToJXLLossless 在image.go中实现
// convertToJXL 在image.go中实现
// convertToAVIF 在image.go中实现
// convertVideoContainer 在video.go中实现
// generateReport 在report.go中实现

// GetOutputPathForTest 用于测试的getOutputPath包装函数
func (c *Converter) GetOutputPathForTest(file *MediaFile, newExt string) string <span class="cov0" title="0">{
        return c.getOutputPath(file, newExt)
}</span>

// IsAnimatedForTest 用于测试的isAnimated包装函数
func (c *Converter) IsAnimatedForTest(path string) bool <span class="cov0" title="0">{
        return c.isAnimated(path)
}</span>

// ConvertToJXLLosslessForTest 用于测试的convertToJXLLossless包装函数
func (c *Converter) ConvertToJXLLosslessForTest(file *MediaFile) (string, error) <span class="cov0" title="0">{
        return c.convertToJXLLossless(file)
}</span>

// RequestStop 请求停止转换器 - 优雅停止
func (c *Converter) RequestStop() <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // 收到停止请求，开始优雅停止转换器

        // 取消上下文，通知所有goroutine停止
        c.cancel()
}</span>

// Close 关闭转换器
func (c *Converter) Close() error <span class="cov8" title="1">{
        // 取消上下文
        c.cancel()

        // 等待所有goroutine完成
        c.wg.Wait()

        // 关闭高级ants池
        if c.advancedPool != nil </span><span class="cov8" title="1">{
                if err := c.advancedPool.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("关闭高级ants池失败", zap.Error(err))
                }</span>
        }

        // 停止看门狗
        <span class="cov8" title="1">if c.watchdog != nil </span><span class="cov8" title="1">{
                c.watchdog.Stop()
        }</span>

        // 停止信号处理器
        <span class="cov8" title="1">if c.signalHandler != nil </span><span class="cov8" title="1">{
                c.signalHandler.Stop()
        }</span>

        // 关闭checkpoint管理器
        <span class="cov8" title="1">if c.checkpointMgr != nil </span><span class="cov8" title="1">{
                if err := c.checkpointMgr.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("关闭checkpoint管理器失败", zap.Error(err))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ProcessFileForTest 用于测试的文件处理方法
func (c *Converter) ProcessFileForTest(filePath string) *ConversionResult <span class="cov0" title="0">{
        // 创建媒体文件对象
        file := &amp;MediaFile{
                Path:      filePath,
                Name:      filepath.Base(filePath),
                Extension: filepath.Ext(filePath),
                Type:      c.getFileType(filepath.Ext(filePath)),
        }

        // 获取文件信息
        if info, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                file.Size = info.Size()
                file.ModTime = info.ModTime()
        }</span>

        // 处理文件
        <span class="cov0" title="0">result := c.processFile(file)

        // 更新统计信息
        c.UpdateStats(result)

        return result</span>
}

// GetFileType 获取文件类型
func (c *Converter) GetFileType(ext string) MediaType <span class="cov0" title="0">{
        return c.getFileType(ext)
}</span>

// GetStats 获取转换统计信息
func (c *Converter) GetStats() *ConversionStats <span class="cov0" title="0">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        // 更新统计信息
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        // 计算压缩比
        if c.stats.TotalSize &gt; 0 </span><span class="cov0" title="0">{
                // 确保压缩率不会是负数，当压缩后大小大于原始大小时，压缩率为0
                if c.stats.CompressedSize &lt; c.stats.TotalSize </span><span class="cov0" title="0">{
                        c.stats.CompressionRatio = float64(c.stats.TotalSize-c.stats.CompressedSize) / float64(c.stats.TotalSize) * 100
                }</span> else<span class="cov0" title="0"> {
                        c.stats.CompressionRatio = 0
                }</span>
        } else<span class="cov0" title="0"> {
                c.stats.CompressionRatio = 0
        }</span>

        // 计算总耗时
        <span class="cov0" title="0">if !c.stats.StartTime.IsZero() </span><span class="cov0" title="0">{
                c.stats.TotalDuration = time.Since(c.stats.StartTime)
        }</span>

        // 返回统计信息的副本
        <span class="cov0" title="0">stats := *c.stats
        return &amp;stats</span>
}

// GetPoolMetrics 获取高级池的监控指标
func (c *Converter) GetPoolMetrics() *PoolMetrics <span class="cov0" title="0">{
        if c.advancedPool != nil </span><span class="cov0" title="0">{
                return c.advancedPool.GetMetrics()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetPoolInfo 获取池的详细信息
func (c *Converter) GetPoolInfo() map[string]interface{} <span class="cov0" title="0">{
        info := make(map[string]interface{})

        // 高级池信息
        if c.advancedPool != nil </span><span class="cov0" title="0">{
                advancedInfo := c.advancedPool.GetPoolInfo()
                for k, v := range advancedInfo </span><span class="cov0" title="0">{
                        info[k] = v
                }</span>
        }

        <span class="cov0" title="0">return info</span>
}

// TunePoolSize 动态调整池大小
func (c *Converter) TunePoolSize(size int) <span class="cov0" title="0">{
        if c.advancedPool != nil </span><span class="cov0" title="0">{
                c.advancedPool.Tune(size)
                // 动态调整高级池大小
        }</span>
}

// GetMetadataManager 获取元数据管理器
func (c *Converter) GetMetadataManager() *MetadataManager <span class="cov0" title="0">{
        return c.metadataManager
}</span>

// resumeConversion 恢复未完成的转换会话
func (c *Converter) resumeConversion(inputDir string) error <span class="cov0" title="0">{
        // 获取会话信息并设置统计数据
        sessionInfo := c.checkpointMgr.GetSessionInfo()
        if sessionInfo != nil </span><span class="cov0" title="0">{
                c.mutex.Lock()
                c.stats.TotalFiles = sessionInfo.TotalFiles
                c.stats.StartTime = sessionInfo.StartTime
                c.mutex.Unlock()
                // 从会话恢复统计信息
        }</span>

        // 获取未完成的文件列表
        <span class="cov0" title="0">pendingFiles, err := c.checkpointMgr.GetPendingFiles()
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("获取未完成文件列表失败", err)
        }</span>

        <span class="cov0" title="0">if len(pendingFiles) == 0 </span><span class="cov0" title="0">{
                // 所有文件已完成，清理会话
                if sessionInfo != nil </span><span class="cov0" title="0">{
                        if err := c.checkpointMgr.CleanupSession(sessionInfo.SessionID); err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn("清理会话失败",
                                        zap.String("sessionID", sessionInfo.SessionID),
                                        zap.Error(err))
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        // 继续处理未完成的文件

        // 将文件路径转换为MediaFile对象
        <span class="cov0" title="0">var mediaFiles []*MediaFile
        for _, filePath := range pendingFiles </span><span class="cov0" title="0">{
                // 检查文件是否仍然存在
                if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        c.logger.Warn("文件不存在，跳过", zap.String("file", filePath))
                        if err := c.checkpointMgr.UpdateFileStatus(filePath, StatusSkipped, "文件不存在", ""); err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn("更新文件状态失败",
                                        zap.String("file", filePath),
                                        zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // 创建MediaFile对象
                <span class="cov0" title="0">mediaFile := &amp;MediaFile{
                        Path: filePath,
                        Name: filepath.Base(filePath),
                }

                // 获取文件信息
                if info, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        mediaFile.Size = info.Size()
                        mediaFile.ModTime = info.ModTime()
                }</span>

                // 确定文件类型
                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(filePath))
                mediaFile.Extension = ext
                mediaFile.Type = c.getFileType(ext)

                mediaFiles = append(mediaFiles, mediaFile)</span>
        }

        <span class="cov0" title="0">if len(mediaFiles) == 0 </span><span class="cov0" title="0">{
                // 没有有效的未完成文件
                return nil
        }</span>

        // 检查路径权限
        <span class="cov0" title="0">if err := c.checkPathPermissions(inputDir); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("路径权限检查失败", err)
        }</span>

        // 处理文件
        // 启动动态进度条
        <span class="cov0" title="0">ui.StartDynamicProgress(int64(len(mediaFiles)), "转换进度")
        
        return c.processFiles(mediaFiles)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package converter

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// ErrorType 定义错误类型
type ErrorType string

const (
        // 文件操作错误
        ErrorTypeFileOperation ErrorType = "FILE_OPERATION"
        // 转换错误
        ErrorTypeConversion ErrorType = "CONVERSION"
        // 工具执行错误
        ErrorTypeToolExecution ErrorType = "TOOL_EXECUTION"
        // 配置错误
        ErrorTypeConfiguration ErrorType = "CONFIGURATION"
        // 系统资源错误
        ErrorTypeSystemResource ErrorType = "SYSTEM_RESOURCE"
        // 用户输入错误
        ErrorTypeUserInput ErrorType = "USER_INPUT"
        // 未知错误
        ErrorTypeUnknown ErrorType = "UNKNOWN"
)

// ErrorSeverity 定义错误严重程度
type ErrorSeverity string

const (
        SeverityLow      ErrorSeverity = "LOW"
        SeverityMedium   ErrorSeverity = "MEDIUM"
        SeverityHigh     ErrorSeverity = "HIGH"
        SeverityCritical ErrorSeverity = "CRITICAL"
)

// ErrorContext 泛型错误上下文
type ErrorContext[T any] struct {
        Data map[string]T `json:"data,omitempty"`
}

// NewErrorContext 创建新的错误上下文
func NewErrorContext[T any]() *ErrorContext[T] <span class="cov0" title="0">{
        return &amp;ErrorContext[T]{
                Data: make(map[string]T),
        }
}</span>

// Set 设置上下文值
func (ec *ErrorContext[T]) Set(key string, value T) <span class="cov0" title="0">{
        ec.Data[key] = value
}</span>

// Get 获取上下文值
func (ec *ErrorContext[T]) Get(key string) (T, bool) <span class="cov0" title="0">{
        value, exists := ec.Data[key]
        return value, exists
}</span>

// PixlyError 增强的错误结构
type PixlyError struct {
        ID         string             `json:"id"`
        Type       ErrorType          `json:"type"`
        Severity   ErrorSeverity      `json:"severity"`
        Message    string             `json:"message"`
        Operation  string             `json:"operation"`
        FilePath   string             `json:"file_path,omitempty"`
        Timestamp  time.Time          `json:"timestamp"`
        StackTrace string             `json:"stack_trace,omitempty"`
        Cause      error              `json:"-"`
        Retryable  bool               `json:"retryable"`
        Context    *ErrorContext[any] `json:"context,omitempty"`
}

// Error 实现error接口
func (pe *PixlyError) Error() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("[")
        builder.WriteString(string(pe.Type))
        builder.WriteString(":")
        builder.WriteString(string(pe.Severity))
        builder.WriteString("] ")
        builder.WriteString(pe.Message)
        builder.WriteString(" (operation: ")
        builder.WriteString(pe.Operation)
        if pe.FilePath != "" </span><span class="cov0" title="0">{
                builder.WriteString(", file: ")
                builder.WriteString(pe.FilePath)
        }</span>
        <span class="cov0" title="0">builder.WriteString(")")
        return builder.String()</span>
}

// Unwrap 支持错误链
func (pe *PixlyError) Unwrap() error <span class="cov0" title="0">{
        return pe.Cause
}</span>

// ErrorHandler 统一的错误处理器
type ErrorHandler struct {
        logger       *zap.Logger
        errorCounter map[string]int
        retryPolicy  *RetryPolicy
}

// RetryPolicy 重试策略
type RetryPolicy struct {
        MaxRetries    int
        BaseDelay     time.Duration
        MaxDelay      time.Duration
        BackoffFactor float64
}

// DefaultRetryPolicy 默认重试策略
func DefaultRetryPolicy() *RetryPolicy <span class="cov8" title="1">{
        return &amp;RetryPolicy{
                MaxRetries:    3,
                BaseDelay:     100 * time.Millisecond,
                MaxDelay:      5 * time.Second,
                BackoffFactor: 2.0,
        }
}</span>

// NewErrorHandler 创建新的错误处理器
func NewErrorHandler(logger *zap.Logger) *ErrorHandler <span class="cov8" title="1">{
        return &amp;ErrorHandler{
                logger:       logger,
                errorCounter: make(map[string]int),
                retryPolicy:  DefaultRetryPolicy(),
        }
}</span>

// NewPixlyError 创建新的Pixly错误
func (eh *ErrorHandler) NewPixlyError(errorType ErrorType, severity ErrorSeverity, operation, message string, cause error) *PixlyError <span class="cov0" title="0">{
        errorID := eh.generateErrorID(errorType, operation)

        pe := &amp;PixlyError{
                ID:        errorID,
                Type:      errorType,
                Severity:  severity,
                Message:   message,
                Operation: operation,
                Timestamp: time.Now(),
                Cause:     cause,
                Retryable: eh.isRetryable(errorType, cause),
                Context:   NewErrorContext[any](),
        }

        // 只在Critical级别错误时添加堆栈跟踪，减少日志污染
        if severity == SeverityCritical </span><span class="cov0" title="0">{
                pe.StackTrace = eh.getStackTrace()
        }</span>

        <span class="cov0" title="0">eh.errorCounter[errorID]++
        return pe</span>
}

// generateErrorID 生成错误ID
func (eh *ErrorHandler) generateErrorID(errorType ErrorType, operation string) string <span class="cov0" title="0">{
        // 简化操作名称作为ID的一部分
        opName := strings.ReplaceAll(strings.ToUpper(operation), " ", "_")
        var idBuilder strings.Builder
        idBuilder.WriteString(string(errorType))
        idBuilder.WriteString("_")
        idBuilder.WriteString(opName)
        return idBuilder.String()
}</span>

// isRetryable 判断错误是否可重试
func (eh *ErrorHandler) isRetryable(errorType ErrorType, cause error) bool <span class="cov0" title="0">{
        if cause == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 根据错误类型和原因判断是否可重试
        <span class="cov0" title="0">switch errorType </span>{
        case ErrorTypeFileOperation:<span class="cov0" title="0">
                // 文件操作错误通常可重试
                return !os.IsNotExist(cause) &amp;&amp; !os.IsPermission(cause)</span>
        case ErrorTypeToolExecution:<span class="cov0" title="0">
                // 工具执行错误可能可重试
                return true</span>
        case ErrorTypeSystemResource:<span class="cov0" title="0">
                // 系统资源错误可能可重试
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// getStackTrace 获取堆栈跟踪
func (eh *ErrorHandler) getStackTrace() string <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        return string(buf[:n])
}</span>

// WrapError 统一的错误包装函数
func (eh *ErrorHandler) WrapError(operation string, err error, details ...interface{}) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 构建详细信息字符串
        <span class="cov0" title="0">var detailStr string
        if len(details) &gt; 0 </span><span class="cov0" title="0">{
                var builder strings.Builder
                builder.WriteString(", details: ")
                // 使用字符串构建器代替fmt.Sprintf
                for i, detail := range details </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                builder.WriteString(", ")
                        }</span>
                        <span class="cov0" title="0">builder.WriteString(fmt.Sprint(detail))</span>
                }
                <span class="cov0" title="0">detailStr = builder.String()</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("%s failed: %w%s", operation, err, detailStr)</span>
}

// WrapErrorWithType 使用类型化错误包装
func (eh *ErrorHandler) WrapErrorWithType(errorType ErrorType, severity ErrorSeverity, operation, message string, cause error) *PixlyError <span class="cov0" title="0">{
        pe := eh.NewPixlyError(errorType, severity, operation, message, cause)
        eh.logError(pe)
        return pe
}</span>

// logError 记录错误日志
func (eh *ErrorHandler) logError(pe *PixlyError) <span class="cov0" title="0">{
        // 基础字段，减少详细信息
        fields := []zap.Field{
                zap.String("error_type", string(pe.Type)),
                zap.String("operation", pe.Operation),
        }

        // 只在Critical级别时添加详细信息
        if pe.Severity == SeverityCritical </span><span class="cov0" title="0">{
                fields = append(fields,
                        zap.String("error_id", pe.ID),
                        zap.String("severity", string(pe.Severity)),
                        zap.Bool("retryable", pe.Retryable),
                        zap.Time("timestamp", pe.Timestamp),
                )

                if pe.FilePath != "" </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("file_path", pe.FilePath))
                }</span>

                <span class="cov0" title="0">if pe.Cause != nil </span><span class="cov0" title="0">{
                        fields = append(fields, zap.Error(pe.Cause))
                }</span>

                <span class="cov0" title="0">if pe.StackTrace != "" </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("stack_trace", pe.StackTrace))
                }</span>
        } else<span class="cov0" title="0"> {
                // 非Critical级别只记录基本错误信息
                if pe.Cause != nil </span><span class="cov0" title="0">{
                        fields = append(fields, zap.String("cause", pe.Cause.Error()))
                }</span>
        }

        // 根据严重程度选择日志级别，提高阈值减少输出
        <span class="cov0" title="0">switch pe.Severity </span>{
        case SeverityLow:<span class="cov0" title="0">
                // Low级别错误不记录日志，避免污染
                return</span>
        case SeverityMedium:<span class="cov0" title="0">
                // Medium级别只在Debug模式下记录
                if eh.logger.Core().Enabled(zap.DebugLevel) </span>{<span class="cov0" title="0">
                        // eh.logger.Debug(pe.Message, fields...)
                }</span>
        case SeverityHigh:<span class="cov0" title="0">
                eh.logger.Warn(pe.Message, fields...)</span>
        case SeverityCritical:<span class="cov0" title="0">
                eh.logger.Error(pe.Message, fields...)</span>
        }
}

// RetryWithBackoff 使用退避策略重试操作
func (eh *ErrorHandler) RetryWithBackoff(operation func() error, errorType ErrorType, operationName string) error <span class="cov0" title="0">{
        var lastErr error
        delay := eh.retryPolicy.BaseDelay

        for attempt := 0; attempt &lt;= eh.retryPolicy.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // 等待退避时间
                        // 重试操作
                        time.Sleep(delay)

                        // 计算下次退避时间
                        delay = time.Duration(float64(delay) * eh.retryPolicy.BackoffFactor)
                        if delay &gt; eh.retryPolicy.MaxDelay </span><span class="cov0" title="0">{
                                delay = eh.retryPolicy.MaxDelay
                        }</span>
                }

                <span class="cov0" title="0">err := operation()
                if err == nil </span><span class="cov0" title="0">{
                        if attempt &gt; 0 </span>{<span class="cov0" title="0">
                                // 操作重试成功
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err

                // 检查是否可重试
                if !eh.isRetryable(errorType, err) </span><span class="cov0" title="0">{
                        // 错误不可重试
                        break</span>
                }

                <span class="cov0" title="0">eh.logger.Warn("Operation failed, will retry",
                        zap.String("operation", operationName),
                        zap.Int("attempt", attempt+1),
                        zap.Int("max_retries", eh.retryPolicy.MaxRetries),
                        zap.Duration("next_delay", delay),
                        zap.Error(err))</span>
        }

        // 所有重试都失败了
        <span class="cov0" title="0">eh.logger.Error("操作重试全部失败",
                zap.String("operation", operationName),
                zap.Int("max_retries", eh.retryPolicy.MaxRetries),
                zap.Error(lastErr))
        var builder strings.Builder
        builder.WriteString("Operation failed after ")
        builder.WriteString(strconv.Itoa(eh.retryPolicy.MaxRetries + 1))
        builder.WriteString(" attempts")
        return eh.WrapErrorWithType(errorType, SeverityHigh, operationName, builder.String(), lastErr)</span>
}

// GetErrorStats 获取错误统计信息
func (eh *ErrorHandler) GetErrorStats() map[string]int <span class="cov0" title="0">{
        stats := make(map[string]int)
        for k, v := range eh.errorCounter </span><span class="cov0" title="0">{
                stats[k] = v
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// ResetErrorStats 重置错误统计
func (eh *ErrorHandler) ResetErrorStats() <span class="cov0" title="0">{
        eh.errorCounter = make(map[string]int)
}</span>

// WrapErrorWithOutput 包装带输出信息的错误
func (eh *ErrorHandler) WrapErrorWithOutput(operation string, err error, output []byte) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var errorBuilder strings.Builder
        errorBuilder.WriteString(operation)
        errorBuilder.WriteString(" failed: ")
        errorBuilder.WriteString(err.Error())
        errorBuilder.WriteString(", output: ")
        errorBuilder.WriteString(string(output))
        return fmt.Errorf("%s", errorBuilder.String())</span>
}

// LogAndWrapError 记录日志并包装错误
func (eh *ErrorHandler) LogAndWrapError(operation string, err error, fields ...zap.Field) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logFields := append([]zap.Field{zap.Error(err)}, fields...)
        eh.logger.Error(operation+" failed", logFields...)

        return fmt.Errorf("%s failed: %w", operation, err)</span>
}

// FileOperationHandler 统一的文件操作处理器
type FileOperationHandler struct {
        errorHandler *ErrorHandler
        logger       *zap.Logger
}

// NewFileOperationHandler 创建新的文件操作处理器
func NewFileOperationHandler(logger *zap.Logger) *FileOperationHandler <span class="cov8" title="1">{
        return &amp;FileOperationHandler{
                errorHandler: NewErrorHandler(logger),
                logger:       logger,
        }
}</span>

// SafeCreateDir 安全创建目录
func (foh *FileOperationHandler) SafeCreateDir(dirPath string) error <span class="cov0" title="0">{
        if err := os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapError("create directory", err, dirPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SafeRemoveFile 安全删除文件
func (foh *FileOperationHandler) SafeRemoveFile(filePath string) error <span class="cov0" title="0">{
        if err := os.Remove(filePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapError("remove file", err, filePath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SafeRenameFile 安全重命名文件
func (foh *FileOperationHandler) SafeRenameFile(oldPath, newPath string) error <span class="cov0" title="0">{
        if err := os.Rename(oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                var builder strings.Builder
                builder.WriteString(oldPath)
                builder.WriteString(" -&gt; ")
                builder.WriteString(newPath)
                return foh.errorHandler.WrapError("rename file", err, builder.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AtomicFileReplace 原子性文件替换
func (foh *FileOperationHandler) AtomicFileReplace(tempPath, finalPath string, isInPlace bool) error <span class="cov0" title="0">{
        // 预检查：确保临时文件存在
        if _, err := os.Stat(tempPath); err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapErrorWithType(ErrorTypeFileOperation, SeverityHigh, "AtomicFileReplace",
                        "临时文件不存在或无法访问", err)
        }</span>

        // 预检查：确保目标目录存在
        <span class="cov0" title="0">targetDir := filepath.Dir(finalPath)
        if err := foh.SafeCreateDir(targetDir); err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapErrorWithType(ErrorTypeFileOperation, SeverityHigh, "AtomicFileReplace",
                        "无法创建目标目录", err)
        }</span>

        // 执行原子替换操作
        <span class="cov0" title="0">var replaceFunc func() error
        if isInPlace </span><span class="cov0" title="0">{
                // 原地替换：删除原文件，重命名临时文件
                replaceFunc = func() error </span><span class="cov0" title="0">{
                        if err := foh.SafeRemoveFile(finalPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := foh.SafeRenameFile(tempPath, finalPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        } else<span class="cov0" title="0"> {
                // 非原地替换：直接重命名临时文件
                replaceFunc = func() error </span><span class="cov0" title="0">{
                        if err := foh.SafeRenameFile(tempPath, finalPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // 使用重试机制执行替换操作
        <span class="cov0" title="0">if err := foh.errorHandler.RetryWithBackoff(replaceFunc, ErrorTypeFileOperation, "AtomicFileReplace"); err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapErrorWithType(ErrorTypeFileOperation, SeverityHigh, "AtomicFileReplace",
                        "原子文件替换失败", err)
        }</span>

        // Atomic file replace completed

        <span class="cov0" title="0">return nil</span>
}

// MoveToTrash 移动文件到垃圾箱
func (foh *FileOperationHandler) MoveToTrash(filePath string) error <span class="cov0" title="0">{
        // 规范化文件路径
        normalizedPath, err := GlobalPathUtils.NormalizePath(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapError("normalize file path", err, filePath)
        }</span>

        // 构建垃圾箱目录路径
        <span class="cov0" title="0">trashDir, err := GlobalPathUtils.JoinPath(GlobalPathUtils.GetDirName(normalizedPath), ".trash")
        if err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapError("build trash directory path", err)
        }</span>

        // 创建垃圾箱目录
        <span class="cov0" title="0">if err := foh.SafeCreateDir(trashDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 构建垃圾箱文件路径
        <span class="cov0" title="0">filename := GlobalPathUtils.GetBaseName(normalizedPath)
        trashPath, err := GlobalPathUtils.JoinPath(trashDir, filename)
        if err != nil </span><span class="cov0" title="0">{
                return foh.errorHandler.WrapError("build trash file path", err)
        }</span>

        // 移动文件到垃圾箱
        <span class="cov0" title="0">if err := foh.SafeRenameFile(normalizedPath, trashPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // File moved to trash

        <span class="cov0" title="0">return nil</span>
}

// BatchFileOperation 批量文件操作结果
type BatchFileOperation struct {
        SuccessCount int
        FailureCount int
        Errors       []error
}

// BatchRemoveFiles 批量删除文件
func (foh *FileOperationHandler) BatchRemoveFiles(filePaths []string) *BatchFileOperation <span class="cov0" title="0">{
        result := &amp;BatchFileOperation{
                Errors: make([]error, 0),
        }

        for _, filePath := range filePaths </span><span class="cov0" title="0">{
                if err := foh.SafeRemoveFile(filePath); err != nil </span><span class="cov0" title="0">{
                        result.FailureCount++
                        result.Errors = append(result.Errors, err)
                }</span> else<span class="cov0" title="0"> {
                        result.SuccessCount++
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// BatchMoveToTrash 批量移动文件到垃圾箱
func (foh *FileOperationHandler) BatchMoveToTrash(filePaths []string) *BatchFileOperation <span class="cov0" title="0">{
        result := &amp;BatchFileOperation{
                Errors: make([]error, 0),
        }

        for _, filePath := range filePaths </span><span class="cov0" title="0">{
                if err := foh.MoveToTrash(filePath); err != nil </span><span class="cov0" title="0">{
                        result.FailureCount++
                        result.Errors = append(result.Errors, err)
                }</span> else<span class="cov0" title="0"> {
                        result.SuccessCount++
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// EnsureOutputDirectory 确保输出目录存在
func (foh *FileOperationHandler) EnsureOutputDirectory(outputPath string) error <span class="cov0" title="0">{
        dirPath := filepath.Dir(outputPath)
        return foh.SafeCreateDir(dirPath)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package converter

import (
        "encoding/json"
        "strconv"
        "strings"

        "pixly/config"

        "go.uber.org/zap"
)

// FileType 文件类型枚举
type FileType string

const (
        FileTypeStaticImage   FileType = "static_image"
        FileTypeAnimatedImage FileType = "animated_image"
        FileTypeVideo         FileType = "video"
        // FileTypeAudio 已删除 - 根据README要求，本程序不处理音频文件
        FileTypeLivePhoto  FileType = "live_photo"  // Live Photo
        FileTypeBurstPhoto FileType = "burst_photo" // 连拍照片
        FileTypePanorama   FileType = "panorama"    // 全景照片
        FileTypeUnknown    FileType = "unknown"
)

// MediaDetails 媒体文件详细信息
type MediaDetails struct {
        FileType    FileType
        Codec       string
        Container   string
        FrameCount  int
        Duration    float64
        Width       int
        Height      int
        IsCorrupted bool
}

// FileTypeDetector 文件类型检测器
type FileTypeDetector struct {
        config      *config.Config
        logger      *zap.Logger
        toolManager *ToolManager
}

// NewFileTypeDetector 创建新的文件类型检测器
func NewFileTypeDetector(config *config.Config, logger *zap.Logger, toolManager *ToolManager) *FileTypeDetector <span class="cov8" title="1">{
        return &amp;FileTypeDetector{
                config:      config,
                logger:      logger,
                toolManager: toolManager,
        }
}</span>

// DetectFileType 精确检测文件类型
func (fd *FileTypeDetector) DetectFileType(filePath string) (*MediaDetails, error) <span class="cov0" title="0">{
        // 使用FFprobe获取媒体信息
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_format",
                "-show_streams",
                filePath,
        }

        // 使用工具管理器执行命令，支持路径验证
        output, err := fd.toolManager.ExecuteWithPathValidation(fd.config.Tools.FFprobePath, args...)
        if err != nil </span><span class="cov0" title="0">{
                // 如果FFprobe失败，标记为损坏文件
                return &amp;MediaDetails{
                        FileType:    FileTypeUnknown,
                        IsCorrupted: true,
                }, nil
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Format struct {
                        FormatName string `json:"format_name"`
                        Duration   string `json:"duration"`
                        BitRate    string `json:"bit_rate"`
                } `json:"format"`
                Streams []struct {
                        CodecName  string `json:"codec_name"`
                        CodecType  string `json:"codec_type"`
                        Width      int    `json:"width"`
                        Height     int    `json:"height"`
                        RFrameRate string `json:"r_frame_rate"`
                        NbFrames   string `json:"nb_frames"`
                        Duration   string `json:"duration"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil </span><span class="cov0" title="0">{
                fd.logger.Warn("解析FFprobe输出失败", zap.String("file", filePath), zap.Error(err))
                return &amp;MediaDetails{
                        FileType:    FileTypeUnknown,
                        IsCorrupted: true,
                }, nil
        }</span>

        // 创建媒体详情对象
        <span class="cov0" title="0">details := &amp;MediaDetails{
                Container: probeData.Format.FormatName,
        }

        // 解析持续时间
        if probeData.Format.Duration != "" </span><span class="cov0" title="0">{
                if duration, err := strconv.ParseFloat(probeData.Format.Duration, 64); err == nil </span><span class="cov0" title="0">{
                        details.Duration = duration
                }</span>
        }

        // 分析流信息
        <span class="cov0" title="0">type StreamInfo struct {
                CodecName  string `json:"codec_name"`
                CodecType  string `json:"codec_type"`
                Width      int    `json:"width,omitempty"`
                Height     int    `json:"height,omitempty"`
                RFrameRate string `json:"r_frame_rate,omitempty"`
                NbFrames   string `json:"nb_frames,omitempty"`
                Duration   string `json:"duration,omitempty"`
        }

        var videoStream *StreamInfo
        var audioStream *StreamInfo

        // 查找视频和音频流
        for i := range probeData.Streams </span><span class="cov0" title="0">{
                stream := probeData.Streams[i]
                switch stream.CodecType </span>{
                case "video":<span class="cov0" title="0">
                        videoStream = &amp;StreamInfo{
                                CodecName:  stream.CodecName,
                                CodecType:  stream.CodecType,
                                Width:      stream.Width,
                                Height:     stream.Height,
                                RFrameRate: stream.RFrameRate,
                                NbFrames:   stream.NbFrames,
                                Duration:   stream.Duration,
                        }</span>
                case "audio":<span class="cov0" title="0">
                        audioStream = &amp;StreamInfo{
                                CodecName: stream.CodecName,
                                CodecType: stream.CodecType,
                        }</span>
                }
        }

        // 根据流类型确定文件类型
        <span class="cov0" title="0">if videoStream != nil </span><span class="cov0" title="0">{
                // 有视频流，先判断是否为视频文件
                details.Codec = videoStream.CodecName
                details.Width = videoStream.Width
                details.Height = videoStream.Height

                // 解析帧数
                if videoStream.NbFrames != "" </span><span class="cov0" title="0">{
                        if frames, err := strconv.Atoi(videoStream.NbFrames); err == nil </span><span class="cov0" title="0">{
                                details.FrameCount = frames
                        }</span>
                } else<span class="cov0" title="0"> if videoStream.RFrameRate != "" </span><span class="cov0" title="0">{
                        // 如果没有明确的帧数，通过帧率和持续时间计算
                        if duration := details.Duration; duration &gt; 0 </span><span class="cov0" title="0">{
                                if frameRate := fd.parseFrameRate(videoStream.RFrameRate); frameRate &gt; 0 </span><span class="cov0" title="0">{
                                        details.FrameCount = int(duration * frameRate)
                                }</span>
                        }
                }

                // 判断是视频还是图片：基于持续时间和文件扩展名
                <span class="cov0" title="0">fileExt := strings.ToLower(filePath[strings.LastIndex(filePath, "."):])
                videoExts := map[string]bool{".mp4": true, ".mov": true, ".avi": true, ".mkv": true, ".webm": true, ".flv": true, ".wmv": true, ".m4v": true}

                if videoExts[fileExt] || details.Duration &gt; 3.0 </span><span class="cov0" title="0">{
                        // 视频文件扩展名或持续时间超过3秒，判断为视频
                        details.FileType = FileTypeVideo

                        // 检查是否为 Live Photo
                        if fd.isLivePhoto(filePath, details) </span><span class="cov0" title="0">{
                                details.FileType = FileTypeLivePhoto
                        }</span>
                } else<span class="cov0" title="0"> {
                        // 否则判断为图片文件
                        // 判断是静图还是动图
                        if details.FrameCount &gt; 1 </span><span class="cov0" title="0">{
                                details.FileType = FileTypeAnimatedImage
                        }</span> else<span class="cov0" title="0"> {
                                // 特殊处理：某些格式即使帧数为1也可能是动图
                                if fd.isAnimatedFormat(filePath) </span><span class="cov0" title="0">{
                                        details.FileType = FileTypeAnimatedImage
                                        details.FrameCount = 10 // 估计帧数
                                }</span> else<span class="cov0" title="0"> {
                                        details.FileType = FileTypeStaticImage
                                        details.FrameCount = 1
                                }</span>
                        }

                        // 检查是否为特殊图片类型
                        <span class="cov0" title="0">if fd.isPanorama(details) </span><span class="cov0" title="0">{
                                details.FileType = FileTypePanorama
                        }</span> else<span class="cov0" title="0"> if fd.isBurstPhoto(filePath) </span><span class="cov0" title="0">{
                                details.FileType = FileTypeBurstPhoto
                        }</span>
                }
        } else<span class="cov0" title="0"> if audioStream != nil </span><span class="cov0" title="0">{
                // 只有音频流，根据README要求不处理音频文件，标记为未知类型
                details.FileType = FileTypeUnknown
                details.Codec = audioStream.CodecName
        }</span> else<span class="cov0" title="0"> {
                // 没有识别出有效的流，判断为未知类型
                details.FileType = FileTypeUnknown
        }</span>

        <span class="cov0" title="0">return details, nil</span>
}

// parseFrameRate 解析帧率字符串
func (fd *FileTypeDetector) parseFrameRate(frameRateStr string) float64 <span class="cov0" title="0">{
        parts := strings.Split(frameRateStr, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">numerator, err1 := strconv.ParseFloat(parts[0], 64)
        denominator, err2 := strconv.ParseFloat(parts[1], 64)

        if err1 != nil || err2 != nil || denominator == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return numerator / denominator</span>
}

// isAnimatedFormat 检查是否为动图格式
func (fd *FileTypeDetector) isAnimatedFormat(filePath string) bool <span class="cov0" title="0">{
        // 获取文件扩展名
        ext := strings.ToLower(filePath)

        // 支持动画的图片格式（与batch_processor.go中的animatedFormats保持一致）
        animatedFormats := []string{
                ".gif", ".webp", ".avif", ".apng",
                ".flif", ".mng", ".jng", ".jxl", ".tiff", ".tif",
        }

        for _, format := range animatedFormats </span><span class="cov0" title="0">{
                if strings.HasSuffix(ext, format) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// isLivePhoto 检查是否为 Live Photo
func (fd *FileTypeDetector) isLivePhoto(filePath string, details *MediaDetails) bool <span class="cov0" title="0">{
        // Live Photo 特征：
        // 1. 时长很短（通常小于3秒）
        // 2. 有音频轨道
        // 3. 文件名可能包含 "IMG_" 和 "MOV" 等特征

        // 检查时长
        if details.Duration &gt; 3.0 || details.Duration &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查文件名特征（iOS Live Photo 通常有相似的文件名）
        <span class="cov0" title="0">fileName := strings.ToLower(filePath)
        if strings.Contains(fileName, "img_") &amp;&amp; strings.Contains(fileName, ".mov") </span><span class="cov0" title="0">{
                return true
        }</span>

        // 检查元数据中的特殊标记（这里简化处理）
        // 在实际实现中，可能需要检查 EXIF 或其他元数据
        <span class="cov0" title="0">return false</span>
}

// isPanorama 检查是否为全景照片
func (fd *FileTypeDetector) isPanorama(details *MediaDetails) bool <span class="cov0" title="0">{
        // 全景照片特征：
        // 1. 宽高比很大（通常大于2:1）
        // 2. 分辨率很高

        if details.Width &lt;= 0 || details.Height &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // 计算宽高比
        <span class="cov0" title="0">aspectRatio := float64(details.Width) / float64(details.Height)

        // 如果宽高比大于2:1，认为是全景照片
        return aspectRatio &gt; 2.0</span>
}

// isBurstPhoto 检查是否为连拍照片
func (fd *FileTypeDetector) isBurstPhoto(filePath string) bool <span class="cov0" title="0">{
        // 连拍照片特征：
        // 1. 文件名可能包含 "BURST" 或类似的标记
        // 2. 文件大小相对较小

        fileName := strings.ToUpper(filePath)
        if strings.Contains(fileName, "BURST") </span><span class="cov0" title="0">{
                return true
        }</span>

        // 检查文件大小（连拍照片通常较小）
        // 这里简化处理，实际实现中可能需要更复杂的逻辑
        <span class="cov0" title="0">return false</span>
}

// IsCorrupted 检查文件是否损坏
func (fd *FileTypeDetector) IsCorrupted(filePath string) bool <span class="cov0" title="0">{
        // 使用FFprobe检查文件是否可读
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_format",
                "-show_streams",
                filePath,
        }

        // 使用工具管理器执行命令，支持路径验证
        _, err := fd.toolManager.ExecuteWithPathValidation(fd.config.Tools.FFprobePath, args...)
        return err != nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package converter

import (
        "os"
        "path/filepath"
        "strings"

        "go.uber.org/zap"
)

// convertToJXL 转换为JPEG XL格式
func (c *Converter) convertToJXL(file *MediaFile, quality int) (string, error) <span class="cov0" title="0">{
        framework := NewConversionFramework(c)
        return framework.Execute(file, framework.JXLConfig(), quality)
}</span>

// convertToAVIF 转换为AVIF格式
func (c *Converter) convertToAVIF(file *MediaFile, quality int) (string, error) <span class="cov0" title="0">{
        framework := NewConversionFramework(c)
        return framework.Execute(file, framework.AVIFConfig(), quality)
}</span>

// 辅助函数

// hasTransparency 检查图片是否有透明度
func (c *Converter) hasTransparency(path string) bool <span class="cov0" title="0">{
        // 使用FFprobe检查透明度
        args := []string{
                "-v", "quiet",
                "-select_streams", "v:0",
                "-show_entries", "stream=pix_fmt",
                "-of", "csv=p=0",
                path,
        }

        // 使用工具管理器执行命令，支持路径验证
        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFprobePath, args...)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">pixFmt := strings.TrimSpace(string(output))
        // 常见的带透明度的像素格式
        transparentFormats := []string{"rgba", "argb", "bgra", "abgr", "yuva", "gbra"}

        for _, format := range transparentFormats </span><span class="cov0" title="0">{
                if strings.Contains(pixFmt, format) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// isAnimated 检查是否为动图
func (c *Converter) isAnimated(path string) bool <span class="cov0" title="0">{
        // 使用FFprobe检查帧数
        args := []string{
                "-v", "quiet",
                "-select_streams", "v:0",
                "-count_frames",
                "-show_entries", "stream=nb_read_frames",
                "-of", "csv=p=0",
                path,
        }

        // 使用工具管理器执行命令，支持路径验证
        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFprobePath, args...)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">frames := strings.TrimSpace(string(output))
        // 如果帧数大于1，则为动图
        return frames != "1" &amp;&amp; frames != "0" &amp;&amp; frames != ""</span>
}

// getOutputPath 获取输出文件路径 - 支持原地转换和指定目录输出
func (c *Converter) getOutputPath(file *MediaFile, newExt string) string <span class="cov0" title="0">{
        // 路径计算逻辑

        // 使用GlobalPathUtils处理路径
        normalizedPath, err := GlobalPathUtils.NormalizePath(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">dir := GlobalPathUtils.GetDirName(normalizedPath)
        baseName := GlobalPathUtils.GetBaseName(normalizedPath)
        ext := GlobalPathUtils.GetExtension(normalizedPath)
        name := strings.TrimSuffix(baseName, ext)

        // 核心逻辑：默认原地转换，只有指定输出目录时才使用输出目录
        if c.config.Output.DirectoryTemplate != "" </span><span class="cov0" title="0">{
                // 指定了输出目录，使用输出目录
                dir = c.config.Output.DirectoryTemplate
                // 确保输出目录存在
                if err := c.fileOpHandler.SafeCreateDir(dir); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Failed to create output directory", zap.String("dir", dir), zap.Error(err))
                }</span>
        } else <span class="cov0" title="0">{
                // 默认原地转换：使用原文件所在目录
                // dir 已经是原文件目录，无需修改
        }</span>

        <span class="cov0" title="0">outputPath, err := GlobalPathUtils.JoinPath(dir, name+newExt)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        // 规范化输出路径
        <span class="cov0" title="0">normalizedOutput, err := GlobalPathUtils.NormalizePath(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return outputPath // 如果规范化失败，返回原路径
        }</span>
        <span class="cov0" title="0">return normalizedOutput</span>
}

// verifyOutputFile 验证输出文件
func (c *Converter) verifyOutputFile(outputPath string, originalSize int64) bool <span class="cov0" title="0">{
        c.logger.Debug("开始验证输出文件", zap.String("outputPath", outputPath), zap.Int64("originalSize", originalSize))

        stat, err := os.Stat(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Debug("无法获取输出文件信息", zap.String("outputPath", outputPath), zap.Error(err))
                return false
        }</span>

        // 检查文件大小是否合理（不能为0）
        <span class="cov0" title="0">if stat.Size() == 0 </span><span class="cov0" title="0">{
                c.logger.Debug("输出文件大小为0", zap.String("outputPath", outputPath), zap.Int64("size", stat.Size()))
                return false
        }</span>

        // 对于WebP到JXL的转换，允许更大的文件大小
        // WebP是有损压缩格式，而JXL是无损压缩，所以文件大小增加是正常的
        // 只有当文件大小超过原文件10倍时才认为异常
        <span class="cov0" title="0">if stat.Size() &gt; originalSize*10 </span><span class="cov0" title="0">{
                c.logger.Debug("输出文件大小超过原文件10倍", zap.String("outputPath", outputPath), zap.Int64("size", stat.Size()), zap.Int64("originalSize", originalSize))
                return false
        }</span>

        <span class="cov0" title="0">c.logger.Debug("文件大小检查通过", zap.String("outputPath", outputPath), zap.Int64("size", stat.Size()))

        // 使用FFprobe验证文件的实际有效性
        if !c.verifyFileIntegrity(outputPath) </span><span class="cov0" title="0">{
                c.logger.Debug("文件完整性验证失败", zap.String("outputPath", outputPath))
                return false
        }</span>

        <span class="cov0" title="0">c.logger.Debug("输出文件验证成功", zap.String("outputPath", outputPath))
        return true</span>
}

// verifyFileIntegrity 使用FFprobe验证文件的实际有效性
func (c *Converter) verifyFileIntegrity(filePath string) bool <span class="cov0" title="0">{
        // 使用FFprobe检查文件是否为有效的媒体文件
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_format",
                filePath,
        }

        // 使用工具管理器执行命令，支持路径验证
        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFprobePath, args...)
        if err != nil </span><span class="cov0" title="0">{
                // File integrity verification failed - ffprobe failed
                return false
        }</span>

        // 检查输出是否包含有效的格式信息
        <span class="cov0" title="0">outputStr := string(output)
        if len(outputStr) &lt; 10 || !strings.Contains(outputStr, "format") </span><span class="cov0" title="0">{
                // File integrity verification failed - invalid format info
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// RepackagingConfig 重新包装配置
type RepackagingConfig struct {
        SupportedExts []string
        CjxlArgs      []string
        NeedsFFmpeg   bool
        FFmpegFormat  string
}

// convertToJXLRepackaging 统一的JXL重新包装函数
func (c *Converter) convertToJXLRepackaging(file *MediaFile, config RepackagingConfig) (string, error) <span class="cov0" title="0">{
        outputPath := c.getOutputPath(file, ".jxl")
        ext := strings.ToLower(file.Extension)

        // 检查文件格式支持
        supported := false
        for _, supportedExt := range config.SupportedExts </span><span class="cov0" title="0">{
                if ext == supportedExt </span><span class="cov0" title="0">{
                        supported = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !supported </span><span class="cov0" title="0">{
                var formatErrorBuilder strings.Builder
                formatErrorBuilder.WriteString("unsupported file format for repackaging: ")
                formatErrorBuilder.WriteString(ext)
                return "", c.errorHandler.WrapError(formatErrorBuilder.String(), nil)
        }</span>

        // 检查是否为原地转换
        <span class="cov0" title="0">isInPlace := c.config.Output.DirectoryTemplate == ""
        var actualOutputPath string
        if isInPlace </span><span class="cov0" title="0">{
                actualOutputPath = outputPath + ".tmp"
        }</span> else<span class="cov0" title="0"> {
                actualOutputPath = outputPath + ".tmp"
                if err := c.fileOpHandler.SafeCreateDir(filepath.Dir(outputPath)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">var inputPath string
        var tempFile string

        // 如果需要FFmpeg预处理
        if config.NeedsFFmpeg </span><span class="cov0" title="0">{
                tempFile = actualOutputPath + ".temp.png"
                if err := c.fileOpHandler.SafeRemoveFile(tempFile); err != nil </span>{<span class="cov0" title="0">
                        // Failed to remove existing temp file
                }</span>

                // 使用FFmpeg转换
                <span class="cov0" title="0">ffmpegArgs := []string{
                        "-i", file.Path,
                        "-y",
                        tempFile,
                }

                output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFmpegPath, ffmpegArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        if removeErr := c.fileOpHandler.SafeRemoveFile(tempFile); removeErr != nil </span>{<span class="cov0" title="0">
                                // Failed to cleanup temp file after FFmpeg error
                        }</span>
                        <span class="cov0" title="0">return "", c.errorHandler.WrapError("FFmpeg conversion", err, "output", string(output))</span>
                }
                <span class="cov0" title="0">inputPath = tempFile
                defer func() </span><span class="cov0" title="0">{
                        if err := c.fileOpHandler.SafeRemoveFile(tempFile); err != nil </span>{<span class="cov0" title="0">
                                // Failed to cleanup temp file
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                inputPath = file.Path
        }</span>

        // 构建cjxl参数
        <span class="cov0" title="0">args := []string{inputPath, actualOutputPath}
        args = append(args, config.CjxlArgs...)

        // cjxl 会自动处理透明度，无需额外参数

        // 执行cjxl转换
        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.CjxlPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                if removeErr := c.fileOpHandler.SafeRemoveFile(actualOutputPath); removeErr != nil </span>{<span class="cov0" title="0">
                        // Failed to cleanup output file after cjxl error
                }</span>
                <span class="cov0" title="0">return "", c.errorHandler.WrapError("cjxl execution", err, "output", string(output))</span>
        }

        // 验证输出文件
        <span class="cov0" title="0">if !c.verifyOutputFile(actualOutputPath, file.Size) </span><span class="cov0" title="0">{
                if removeErr := c.fileOpHandler.SafeRemoveFile(actualOutputPath); removeErr != nil </span>{<span class="cov0" title="0">
                        // Failed to cleanup invalid output file
                }</span>
                <span class="cov0" title="0">var verifyErrorBuilder strings.Builder
                verifyErrorBuilder.WriteString("output file verification failed: ")
                verifyErrorBuilder.WriteString(actualOutputPath)
                return "", c.errorHandler.WrapError(verifyErrorBuilder.String(), nil)</span>
        }

        // 原子性替换文件
        <span class="cov0" title="0">if err := c.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, isInPlace); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // JXL repackaging completed

        <span class="cov0" title="0">return outputPath, nil</span>
}

// convertJPEGToJXLRepackaging JPEG到JXL的无损重新包装
// 只有jpeg才能重新包装为Jxl!
func (c *Converter) convertJPEGToJXLRepackaging(file *MediaFile) (string, error) <span class="cov0" title="0">{
        config := RepackagingConfig{
                SupportedExts: []string{".jpg", ".jpeg", ".jpe"},
                CjxlArgs:      []string{"--lossless_jpeg=1", "--effort=9"},
                NeedsFFmpeg:   false,
        }
        return c.convertToJXLRepackaging(file, config)
}</span>

// convertPNGToJXLRepackaging PNG到JXL的无损转换
func (c *Converter) convertPNGToJXLRepackaging(file *MediaFile) (string, error) <span class="cov0" title="0">{
        config := RepackagingConfig{
                SupportedExts: []string{".png"},
                CjxlArgs:      []string{"--distance=0", "--effort=9"},
                NeedsFFmpeg:   false,
        }
        return c.convertToJXLRepackaging(file, config)
}</span>

// convertWebPToJXLRepackaging WebP到JXL的数学无损转换
func (c *Converter) convertWebPToJXLRepackaging(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // WebP动图检测
        if c.isAnimated(file.Path) </span><span class="cov0" title="0">{
                var animatedErrorBuilder strings.Builder
                animatedErrorBuilder.WriteString("animated WebP files are not supported for repackaging: ")
                animatedErrorBuilder.WriteString(file.Path)
                return "", c.errorHandler.WrapError(animatedErrorBuilder.String(), nil)
        }</span>

        <span class="cov0" title="0">config := RepackagingConfig{
                SupportedExts: []string{".webp"},
                CjxlArgs:      []string{"--distance=0", "--effort=9"},
                NeedsFFmpeg:   true,
                FFmpegFormat:  "png",
        }
        return c.convertToJXLRepackaging(file, config)</span>
}

// convertToJXLMathematicalLossless JXL数学无损压缩
func (c *Converter) convertToJXLMathematicalLossless(file *MediaFile) (string, error) <span class="cov0" title="0">{
        outputPath := c.getOutputPath(file, ".jxl")

        // 检查是否为原地转换
        isInPlace := c.config.Output.DirectoryTemplate == ""
        var actualOutputPath string
        if isInPlace </span><span class="cov0" title="0">{
                actualOutputPath = outputPath + ".tmp"
        }</span> else<span class="cov0" title="0"> {
                actualOutputPath = outputPath + ".tmp"
                if err := c.fileOpHandler.SafeCreateDir(filepath.Dir(outputPath)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // 使用FFmpeg进行数学无损压缩（distance=0）
        <span class="cov0" title="0">args := []string{
                "-i", file.Path,
                "-c:v", "libjxl",
                "-distance", "0", // distance=0表示数学无损
                "-effort", "9", // 最高压缩效率
                "-y",
                actualOutputPath,
        }

        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFmpegPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                if removeErr := c.fileOpHandler.SafeRemoveFile(actualOutputPath); removeErr != nil </span>{<span class="cov0" title="0">
                        // Failed to cleanup output file after FFmpeg error
                }</span>
                <span class="cov0" title="0">return "", c.errorHandler.WrapError("mathematical lossless JXL conversion", err, "output", string(output))</span>
        }

        // 验证输出文件
        <span class="cov0" title="0">if !c.verifyOutputFile(actualOutputPath, file.Size) </span><span class="cov0" title="0">{
                if removeErr := c.fileOpHandler.SafeRemoveFile(actualOutputPath); removeErr != nil </span>{<span class="cov0" title="0">
                        // Failed to cleanup invalid output file
                }</span>
                <span class="cov0" title="0">var mathVerifyErrorBuilder strings.Builder
                mathVerifyErrorBuilder.WriteString("output file verification failed: ")
                mathVerifyErrorBuilder.WriteString(actualOutputPath)
                return "", c.errorHandler.WrapError(mathVerifyErrorBuilder.String(), nil)</span>
        }

        // 原地转换处理
        <span class="cov0" title="0">if isInPlace </span><span class="cov0" title="0">{
                if err := c.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, true); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Mathematical lossless JXL conversion completed
                <span class="cov0" title="0">return outputPath, nil</span>
        }

        // 非原地转换
        <span class="cov0" title="0">if err := c.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, false); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return outputPath, nil</span>
}

// convertToJXLLossless JXL无损转换
func (c *Converter) convertToJXLLossless(file *MediaFile) (string, error) <span class="cov0" title="0">{
        outputPath := c.getOutputPath(file, ".jxl")
        ext := strings.ToLower(file.Extension)

        // 检查是否为原地转换 - 只有未指定输出目录时才是原地转换
        isInPlace := c.config.Output.DirectoryTemplate == ""

        c.logger.Debug("开始JXL无损转换",
                zap.String("file", file.Path),
                zap.String("outputPath", outputPath),
                zap.Bool("isInPlace", isInPlace))

        // 为原地转换创建临时输出文件
        var actualOutputPath string
        if isInPlace </span><span class="cov0" title="0">{
                actualOutputPath = outputPath + ".tmp"
                defer func() </span><span class="cov0" title="0">{
                        if actualOutputPath != outputPath </span><span class="cov0" title="0">{
                                if err := c.fileOpHandler.SafeRemoveFile(actualOutputPath); err != nil </span>{<span class="cov0" title="0">
                                        // Failed to cleanup temp output file
                                }</span>
                        }
                }()
        } else<span class="cov0" title="0"> {
                actualOutputPath = outputPath + ".tmp" // 始终使用临时文件
                if err := c.fileOpHandler.SafeCreateDir(filepath.Dir(outputPath)); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">c.logger.Debug("临时输出路径", zap.String("actualOutputPath", actualOutputPath))

        // 对于WebP格式，需要先转换为PNG然后再用cjxl处理
        var inputPath string
        var tempFile string

        if ext == ".webp" </span><span class="cov0" title="0">{
                // WebP动图检测
                if c.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        var animatedErrorBuilder strings.Builder
                        animatedErrorBuilder.WriteString("animated WebP files are not supported for JXL conversion: ")
                        animatedErrorBuilder.WriteString(file.Path)
                        return "", c.errorHandler.WrapError(animatedErrorBuilder.String(), nil)
                }</span>

                // 创建临时PNG文件
                <span class="cov0" title="0">tempFile = outputPath + ".temp.png"
                if err := c.fileOpHandler.SafeRemoveFile(tempFile); err != nil </span>{<span class="cov0" title="0">
                        // Failed to remove existing temp file
                }</span>

                <span class="cov0" title="0">c.logger.Debug("开始WebP到PNG转换", zap.String("tempFile", tempFile))

                // 使用FFmpeg将WebP转换为PNG
                args := []string{
                        "-i", file.Path,
                        "-y",
                        tempFile,
                }

                // 使用工具管理器执行命令，支持路径验证
                output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFmpegPath, args...)
                if err != nil </span><span class="cov0" title="0">{
                        if removeErr := c.fileOpHandler.SafeRemoveFile(tempFile); removeErr != nil </span>{<span class="cov0" title="0">
                                // Failed to cleanup temp file after FFmpeg error
                        }</span>
                        <span class="cov0" title="0">return "", c.errorHandler.WrapError("WebP to PNG conversion", err, "output", string(output))</span>
                }

                <span class="cov0" title="0">inputPath = tempFile
                c.logger.Debug("WebP到PNG转换完成")</span>
                // Converted WebP to PNG for cjxl processing
        } else<span class="cov0" title="0"> {
                inputPath = file.Path
        }</span>

        // 清理函数，确保临时文件被清理
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tempFile != "" </span><span class="cov0" title="0">{
                        if err := c.fileOpHandler.SafeRemoveFile(tempFile); err != nil </span>{<span class="cov0" title="0">
                                // Failed to cleanup temp file
                        }</span>
                }
        }()

        // 构建cjxl无损命令
        <span class="cov0" title="0">args := []string{
                inputPath,
                actualOutputPath,
                "--lossless_jpeg=1", // 对于JPEG使用lossless_jpeg
                "-e", "9",           // 固定JXL压缩参数为-e 9
        }

        // 对于非JPEG文件，使用distance参数实现无损
        if ext != ".jpg" &amp;&amp; ext != ".jpeg" </span><span class="cov0" title="0">{
                // 移除lossless_jpeg参数，使用distance=0实现无损
                args = []string{
                        inputPath,
                        actualOutputPath,
                        "--distance=0", // distance=0表示无损
                        "-e", "9",      // 固定JXL压缩参数为-e 9
                }
        }</span>

        <span class="cov0" title="0">c.logger.Debug("执行cjxl命令", zap.Strings("args", args))

        // 首选cjxl工具进行无损JXL转换
        output, err := c.toolManager.ExecuteWithPathValidation(c.config.Tools.CjxlPath, args...)
        if err != nil </span><span class="cov0" title="0">{
                // cjxl失败，使用FFmpeg作为备选方案
                // cjxl lossless conversion failed, trying FFmpeg as fallback

                c.logger.Debug("cjxl转换失败，尝试FFmpeg作为备选方案")

                // 构建FFmpeg无损命令作为备选
                ffmpegArgs := []string{
                        "-i", inputPath,
                        "-c:v", "libjxl",
                        "-distance", "0", // distance=0表示无损
                        "-effort", "9",
                        "-y",
                        actualOutputPath,
                }

                // 使用FFmpeg执行无损转换
                output, err = c.toolManager.ExecuteWithPathValidation(c.config.Tools.FFmpegPath, ffmpegArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        return "", c.errorHandler.WrapError("both cjxl and FFmpeg lossless JXL conversion failed", err, "output", string(output))
                }</span>
        }

        <span class="cov0" title="0">c.logger.Debug("cjxl转换成功")

        // 验证输出文件
        if !c.verifyOutputFile(actualOutputPath, file.Size) </span><span class="cov0" title="0">{
                var verifyErrorBuilder strings.Builder
                verifyErrorBuilder.WriteString("output file verification failed: ")
                verifyErrorBuilder.WriteString(actualOutputPath)
                return "", c.errorHandler.WrapError(verifyErrorBuilder.String(), nil)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("输出文件验证成功")

        // 原地转换：使用原子文件替换
        if isInPlace </span><span class="cov0" title="0">{
                c.logger.Debug("执行原地转换")
                // 使用原子文件替换
                if err := c.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, true); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">c.logger.Debug("原子操作替换成功", zap.String("outputPath", outputPath))
                // Atomically replaced original file
                c.logger.Debug("原地转换完成，返回输出路径", zap.String("outputPath", outputPath))
                return outputPath, nil</span> // 原地转换返回新文件路径
        } else<span class="cov0" title="0"> {
                c.logger.Debug("执行非原地转换")
                // 非原地转换：重命名临时文件到最终位置
                if err := c.fileOpHandler.AtomicFileReplace(actualOutputPath, outputPath, false); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">c.logger.Debug("非原地转换完成", zap.String("outputPath", outputPath))</span>
                }

        <span class="cov0" title="0">c.logger.Debug("转换完成", zap.String("outputPath", outputPath))
        return outputPath, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package converter

import (
        "sync"
        "sync/atomic"
        "time"

        "go.uber.org/zap"
)

// TypedPool 泛型内存池，提供类型安全的对象池
type TypedPool[T any] struct {
        pool    sync.Pool
        newFunc func() T
}

// NewTypedPool 创建新的泛型内存池
func NewTypedPool[T any](newFunc func() T) *TypedPool[T] <span class="cov8" title="1">{
        return &amp;TypedPool[T]{
                pool: sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return newFunc()
                        }</span>,
                },
                newFunc: newFunc,
        }
}

// Get 获取对象，类型安全
func (tp *TypedPool[T]) Get() T <span class="cov0" title="0">{
        if obj := tp.pool.Get(); obj != nil </span><span class="cov0" title="0">{
                if typed, ok := obj.(T); ok </span><span class="cov0" title="0">{
                        return typed
                }</span>
        }
        // 如果类型断言失败，创建新对象
        <span class="cov0" title="0">return tp.newFunc()</span>
}

// Put 归还对象
func (tp *TypedPool[T]) Put(obj T) <span class="cov0" title="0">{
        tp.pool.Put(obj)
}</span>

// MemoryPool 内存池管理器 - 使用Go 1.25+泛型特性
type MemoryPool struct {
        bufferPool    *TypedPool[*[]byte]
        metadataPool  *TypedPool[*MediaInfo]
        resultPool    *TypedPool[*ConversionResult]
        logger        *zap.Logger
        maxBufferSize int
        stats         *MemoryPoolStats
        mutex         sync.RWMutex
}

// MemoryPoolStats 内存池统计信息
type MemoryPoolStats struct {
        BufferHits     int64
        BufferMisses   int64
        MetadataHits   int64
        MetadataMisses int64
        ResultHits     int64
        ResultMisses   int64
        TotalAllocated int64
        TotalReleased  int64
        LastReset      time.Time
}

// NewMemoryPool 创建内存池
func NewMemoryPool(logger *zap.Logger, maxBufferSize int) *MemoryPool <span class="cov8" title="1">{
        mp := &amp;MemoryPool{
                logger:        logger,
                maxBufferSize: maxBufferSize,
                stats:         &amp;MemoryPoolStats{LastReset: time.Now()},
        }

        // 初始化缓冲区池 - 使用泛型
        mp.bufferPool = NewTypedPool(func() *[]byte </span><span class="cov0" title="0">{
                mp.stats.BufferMisses++
                buf := make([]byte, 0, maxBufferSize)
                return &amp;buf
        }</span>)

        // 初始化元数据池 - 使用泛型
        <span class="cov8" title="1">mp.metadataPool = NewTypedPool(func() *MediaInfo </span><span class="cov0" title="0">{
                mp.stats.MetadataMisses++
                return &amp;MediaInfo{}
        }</span>)

        // 初始化结果池 - 使用泛型
        <span class="cov8" title="1">mp.resultPool = NewTypedPool(func() *ConversionResult </span><span class="cov0" title="0">{
                mp.stats.ResultMisses++
                return &amp;ConversionResult{}
        }</span>)

        <span class="cov8" title="1">return mp</span>
}

// GetBuffer 获取缓冲区 - 使用泛型，类型安全
func (mp *MemoryPool) GetBuffer() []byte <span class="cov0" title="0">{
        // 使用原子操作减少锁竞争
        atomic.AddInt64(&amp;mp.stats.BufferHits, 1)
        atomic.AddInt64(&amp;mp.stats.TotalAllocated, 1)

        // 使用泛型池，类型安全
        bufPtr := mp.bufferPool.Get()
        return (*bufPtr)[:0] // 重置长度但保留容量
}</span>

// PutBuffer 归还缓冲区 - 使用泛型，类型安全
func (mp *MemoryPool) PutBuffer(buf []byte) <span class="cov0" title="0">{
        if cap(buf) &gt; mp.maxBufferSize </span><span class="cov0" title="0">{
                // 缓冲区太大，不放回池中
                return
        }</span>

        // 使用原子操作减少锁竞争
        <span class="cov0" title="0">atomic.AddInt64(&amp;mp.stats.TotalReleased, 1)

        // 使用泛型池，类型安全
        mp.bufferPool.Put(&amp;buf)</span>
}

// GetMediaInfo 获取媒体信息对象 - 使用泛型，类型安全
func (mp *MemoryPool) GetMediaInfo() *MediaInfo <span class="cov0" title="0">{
        // 使用原子操作减少锁竞争
        atomic.AddInt64(&amp;mp.stats.MetadataHits, 1)
        atomic.AddInt64(&amp;mp.stats.TotalAllocated, 1)

        // 使用泛型池，类型安全
        info := mp.metadataPool.Get()
        // 重置对象
        *info = MediaInfo{}
        return info
}</span>

// PutMediaInfo 归还媒体信息对象 - 使用泛型，类型安全
func (mp *MemoryPool) PutMediaInfo(info *MediaInfo) <span class="cov0" title="0">{
        if info == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 使用原子操作减少锁竞争
        <span class="cov0" title="0">atomic.AddInt64(&amp;mp.stats.TotalReleased, 1)

        mp.metadataPool.Put(info)</span>
}

// GetConversionResult 获取转换结果对象 - 使用泛型，类型安全
func (mp *MemoryPool) GetConversionResult() *ConversionResult <span class="cov0" title="0">{
        // 使用原子操作减少锁竞争
        atomic.AddInt64(&amp;mp.stats.ResultHits, 1)
        atomic.AddInt64(&amp;mp.stats.TotalAllocated, 1)

        // 使用泛型池，类型安全
        result := mp.resultPool.Get()
        // 重置对象
        *result = ConversionResult{}
        return result
}</span>

// PutConversionResult 归还转换结果对象 - 使用泛型，类型安全
func (mp *MemoryPool) PutConversionResult(result *ConversionResult) <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 使用原子操作减少锁竞争
        <span class="cov0" title="0">atomic.AddInt64(&amp;mp.stats.TotalReleased, 1)

        mp.resultPool.Put(result)</span>
}

// GetStats 获取内存池统计信息
func (mp *MemoryPool) GetStats() *MemoryPoolStats <span class="cov0" title="0">{
        mp.mutex.RLock()
        defer mp.mutex.RUnlock()
        return mp.stats
}</span>

// ResetStats 重置统计信息
func (mp *MemoryPool) ResetStats() <span class="cov0" title="0">{
        mp.mutex.Lock()
        defer mp.mutex.Unlock()

        mp.stats = &amp;MemoryPoolStats{LastReset: time.Now()}
}</span>

// GetHitRate 获取命中率
func (mp *MemoryPool) GetHitRate() (bufferHitRate, metadataHitRate, resultHitRate float64) <span class="cov0" title="0">{
        mp.mutex.RLock()
        defer mp.mutex.RUnlock()

        totalBufferRequests := mp.stats.BufferHits + mp.stats.BufferMisses
        if totalBufferRequests &gt; 0 </span><span class="cov0" title="0">{
                bufferHitRate = float64(mp.stats.BufferHits) / float64(totalBufferRequests)
        }</span>

        <span class="cov0" title="0">totalMetadataRequests := mp.stats.MetadataHits + mp.stats.MetadataMisses
        if totalMetadataRequests &gt; 0 </span><span class="cov0" title="0">{
                metadataHitRate = float64(mp.stats.MetadataHits) / float64(totalMetadataRequests)
        }</span>

        <span class="cov0" title="0">totalResultRequests := mp.stats.ResultHits + mp.stats.ResultMisses
        if totalResultRequests &gt; 0 </span><span class="cov0" title="0">{
                resultHitRate = float64(mp.stats.ResultHits) / float64(totalResultRequests)
        }</span>

        <span class="cov0" title="0">return</span>
}

// LogStats 记录统计信息
func (mp *MemoryPool) LogStats() {<span class="cov0" title="0">
        // 内存池统计信息
}</span>

// Cleanup 清理内存池 - 使用泛型重新初始化
func (mp *MemoryPool) Cleanup() <span class="cov0" title="0">{
        // 强制GC以清理未使用的对象，使用泛型重新初始化
        mp.bufferPool = NewTypedPool(func() *[]byte </span><span class="cov0" title="0">{
                buf := make([]byte, 0, mp.maxBufferSize)
                return &amp;buf
        }</span>)
        <span class="cov0" title="0">mp.metadataPool = NewTypedPool(func() *MediaInfo </span><span class="cov0" title="0">{
                return &amp;MediaInfo{}
        }</span>)
        <span class="cov0" title="0">mp.resultPool = NewTypedPool(func() *ConversionResult </span><span class="cov0" title="0">{
                return &amp;ConversionResult{}
        }</span>)

        // 内存池已清理
}

// 全局内存池实例
var (
        globalMemoryPool *MemoryPool
        memoryPoolOnce   sync.Once
)

// GetGlobalMemoryPool 获取全局内存池
func GetGlobalMemoryPool(logger *zap.Logger) *MemoryPool <span class="cov8" title="1">{
        memoryPoolOnce.Do(func() </span><span class="cov8" title="1">{
                globalMemoryPool = NewMemoryPool(logger, 1024*1024) // 1MB 默认缓冲区大小
        }</span>)
        <span class="cov8" title="1">return globalMemoryPool</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package converter

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "pixly/config"

        "go.uber.org/zap"
)

// MetadataManager 元数据管理器
type MetadataManager struct {
        logger       *zap.Logger
        config       *config.Config
        errorHandler *ErrorHandler
}

// NewMetadataManager 创建元数据管理器实例
func NewMetadataManager(logger *zap.Logger, config *config.Config, errorHandler *ErrorHandler) *MetadataManager <span class="cov8" title="1">{
        return &amp;MetadataManager{
                logger:       logger,
                config:       config,
                errorHandler: errorHandler,
        }
}</span>

// MigrateMetadata 使用exiftool迁移元数据
func (mm *MetadataManager) MigrateMetadata(sourcePath, targetPath string) error <span class="cov0" title="0">{
        // 开始元数据迁移

        // 检查exiftool是否可用
        if _, err := exec.LookPath(mm.config.Tools.ExiftoolPath); err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("exiftool不可用", err)
        }</span>

        // 使用exiftool迁移所有元数据
        // 命令: exiftool -TagsFromFile source -all:all target
        <span class="cov0" title="0">args := []string{
                "-TagsFromFile", sourcePath,
                "-all:all",
                "-overwrite_original",
                targetPath,
        }

        cmd := exec.Command(mm.config.Tools.ExiftoolPath, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapErrorWithOutput("exiftool元数据迁移失败", err, output)
        }</span>

        // 元数据迁移完成

        <span class="cov0" title="0">return nil</span>
}

// CopyMetadata 复制元数据（高级选项）
func (mm *MetadataManager) CopyMetadata(sourcePath, targetPath string, options ...MetadataCopyOption) error <span class="cov0" title="0">{
        // 开始复制元数据

        // 检查exiftool是否可用
        if _, err := exec.LookPath(mm.config.Tools.ExiftoolPath); err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("exiftool不可用", err)
        }</span>

        // 构建命令参数
        <span class="cov0" title="0">args := []string{
                "-TagsFromFile", sourcePath,
        }

        // 应用选项
        for _, option := range options </span><span class="cov0" title="0">{
                args = append(args, option.Args()...)
        }</span>

        // 添加目标文件
        <span class="cov0" title="0">args = append(args, targetPath)

        cmd := exec.Command(mm.config.Tools.ExiftoolPath, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapErrorWithOutput("exiftool元数据复制失败", err, output)
        }</span>

        // 元数据复制完成

        <span class="cov0" title="0">return nil</span>
}

// MetadataCopyOption 元数据复制选项接口
type MetadataCopyOption interface {
        Args() []string
}

// MetadataType 元数据类型枚举 - 消除特殊情况的好品味设计
type MetadataType int

const (
        MetadataAll MetadataType = iota
        MetadataEXIF
        MetadataIPTC
        MetadataXMP
)

// metadataArgs 元数据类型到参数的映射 - 数据驱动，无条件分支
var metadataArgs = map[MetadataType][]string{
        MetadataAll:  {"-all:all"},
        MetadataEXIF: {"-EXIF:all"},
        MetadataIPTC: {"-IPTC:all"},
        MetadataXMP:  {"-XMP:all"},
}

// MetadataOption 统一的元数据选项 - 替代4个重复结构体
type MetadataOption struct {
        Type MetadataType
}

func (o MetadataOption) Args() []string <span class="cov0" title="0">{
        return metadataArgs[o.Type]
}</span>

// 便利构造函数 - 保持API简洁
func CopyAllOption() MetadataOption  <span class="cov0" title="0">{ return MetadataOption{MetadataAll} }</span>
func CopyEXIFOption() MetadataOption <span class="cov0" title="0">{ return MetadataOption{MetadataEXIF} }</span>
func CopyIPTCOption() MetadataOption <span class="cov0" title="0">{ return MetadataOption{MetadataIPTC} }</span>
func CopyXMPOption() MetadataOption  <span class="cov0" title="0">{ return MetadataOption{MetadataXMP} }</span>

// ExcludeOption 排除特定元数据选项
type ExcludeOption struct {
        Tags []string
}

func (o ExcludeOption) Args() []string <span class="cov0" title="0">{
        var args []string
        for _, tag := range o.Tags </span><span class="cov0" title="0">{
                args = append(args, "-"+tag+"=")
        }</span>
        <span class="cov0" title="0">return args</span>
}

// OverwriteOption 覆盖选项
type OverwriteOption struct {
        Overwrite bool
}

func (o OverwriteOption) Args() []string <span class="cov0" title="0">{
        if o.Overwrite </span><span class="cov0" title="0">{
                return []string{"-overwrite_original"}
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

// PreserveDatesOption 保留日期选项
type PreserveDatesOption struct {
        Preserve bool
}

func (o PreserveDatesOption) Args() []string <span class="cov0" title="0">{
        if o.Preserve </span><span class="cov0" title="0">{
                return []string{"-FileModifyDate&lt;DateTimeOriginal"}
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

// GetMetadata 获取文件元数据
func (mm *MetadataManager) GetMetadata(filePath string) (map[string]string, error) <span class="cov0" title="0">{
        // 获取文件元数据

        // 检查exiftool是否可用
        if _, err := exec.LookPath(mm.config.Tools.ExiftoolPath); err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("exiftool不可用", err)
        }</span>

        // 使用exiftool获取元数据
        // 命令: exiftool -j -all:all file (JSON格式输出)
        <span class="cov0" title="0">args := []string{
                "-j",       // JSON输出格式
                "-all:all", // 所有元数据
                filePath,
        }

        cmd := exec.Command(mm.config.Tools.ExiftoolPath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取元数据失败", err)
        }</span>

        // 解析JSON输出
        <span class="cov0" title="0">var jsonData []map[string]interface{}
        if err := json.Unmarshal(output, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("解析元数据JSON失败", err)
        }</span>

        // 转换为字符串映射
        <span class="cov0" title="0">metadata := make(map[string]string)
        if len(jsonData) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range jsonData[0] </span><span class="cov0" title="0">{
                        metadata[key] = fmt.Sprint(value)
                }</span>
        }

        // 元数据获取完成
        <span class="cov0" title="0">return metadata, nil</span>
}

// ValidateMetadata 验证元数据完整性
func (mm *MetadataManager) ValidateMetadata(filePath string) error <span class="cov0" title="0">{
        // 验证元数据完整性

        // 检查exiftool是否可用
        if _, err := exec.LookPath(mm.config.Tools.ExiftoolPath); err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("exiftool不可用", err)
        }</span>

        // 使用exiftool验证文件
        // 命令: exiftool -validate file
        <span class="cov0" title="0">args := []string{
                "-validate",
                filePath,
        }

        cmd := exec.Command(mm.config.Tools.ExiftoolPath, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // 检查是否是元数据问题而不是执行问题
                if strings.Contains(string(output), "Warning") || strings.Contains(string(output), "Error") </span><span class="cov0" title="0">{
                        return mm.errorHandler.WrapErrorWithOutput("元数据验证失败", mm.errorHandler.WrapError("validation failed", nil), output)
                }</span>
                // 如果只是执行错误，返回原始错误
                <span class="cov0" title="0">return mm.errorHandler.WrapErrorWithOutput("exiftool执行失败", err, output)</span>
        }

        // 元数据验证完成
        <span class="cov0" title="0">return nil</span>
}

// FileInfo 增强的文件信息结构
type FileInfo struct {
        Path         string            `json:"path"`
        Size         int64             `json:"size"`
        ModTime      time.Time         `json:"mod_time"`
        MimeType     string            `json:"mime_type"`
        Width        int               `json:"width,omitempty"`
        Height       int               `json:"height,omitempty"`
        ColorSpace   string            `json:"color_space,omitempty"`
        BitDepth     int               `json:"bit_depth,omitempty"`
        Compression  string            `json:"compression,omitempty"`
        Orientation  int               `json:"orientation,omitempty"`
        CreateDate   *time.Time        `json:"create_date,omitempty"`
        CameraModel  string            `json:"camera_model,omitempty"`
        LensModel    string            `json:"lens_model,omitempty"`
        ISO          int               `json:"iso,omitempty"`
        ExposureTime string            `json:"exposure_time,omitempty"`
        FNumber      string            `json:"f_number,omitempty"`
        GPSLatitude  string            `json:"gps_latitude,omitempty"`
        GPSLongitude string            `json:"gps_longitude,omitempty"`
        Metadata     map[string]string `json:"metadata,omitempty"`
}

// ExtractFileInfo 提取增强的文件信息
func (mm *MetadataManager) ExtractFileInfo(filePath string) (*FileInfo, error) <span class="cov0" title="0">{
        // 提取文件信息

        // 获取基本文件信息
        stat, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取文件状态失败", err)
        }</span>

        <span class="cov0" title="0">fileInfo := &amp;FileInfo{
                Path:    filePath,
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
        }

        // 获取详细元数据
        metadata, err := mm.GetMetadata(filePath)
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Warn("获取元数据失败，使用基本信息",
                        zap.String("file", filePath),
                        zap.Error(err))
                return fileInfo, nil
        }</span>

        <span class="cov0" title="0">fileInfo.Metadata = metadata

        // 解析关键元数据字段
        mm.parseMetadataFields(fileInfo, metadata)

        // 文件信息提取完成

        return fileInfo, nil</span>
}

// parseMetadataFields 解析元数据字段
func (mm *MetadataManager) parseMetadataFields(fileInfo *FileInfo, metadata map[string]string) <span class="cov0" title="0">{
        // MIME类型
        if mimeType, ok := metadata["MIMEType"]; ok </span><span class="cov0" title="0">{
                fileInfo.MimeType = mimeType
        }</span>

        // 图像尺寸
        <span class="cov0" title="0">if width, ok := metadata["ImageWidth"]; ok </span><span class="cov0" title="0">{
                if w, err := strconv.Atoi(width); err == nil </span><span class="cov0" title="0">{
                        fileInfo.Width = w
                }</span>
        }
        <span class="cov0" title="0">if height, ok := metadata["ImageHeight"]; ok </span><span class="cov0" title="0">{
                if h, err := strconv.Atoi(height); err == nil </span><span class="cov0" title="0">{
                        fileInfo.Height = h
                }</span>
        }

        // 颜色空间
        <span class="cov0" title="0">if colorSpace, ok := metadata["ColorSpace"]; ok </span><span class="cov0" title="0">{
                fileInfo.ColorSpace = colorSpace
        }</span>

        // 位深度
        <span class="cov0" title="0">if bitDepth, ok := metadata["BitsPerSample"]; ok </span><span class="cov0" title="0">{
                if bd, err := strconv.Atoi(strings.Split(bitDepth, " ")[0]); err == nil </span><span class="cov0" title="0">{
                        fileInfo.BitDepth = bd
                }</span>
        }

        // 压缩方式
        <span class="cov0" title="0">if compression, ok := metadata["Compression"]; ok </span><span class="cov0" title="0">{
                fileInfo.Compression = compression
        }</span>

        // 方向
        <span class="cov0" title="0">if orientation, ok := metadata["Orientation"]; ok </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(orientation); err == nil </span><span class="cov0" title="0">{
                        fileInfo.Orientation = o
                }</span>
        }

        // 创建日期
        <span class="cov0" title="0">if createDate, ok := metadata["CreateDate"]; ok </span><span class="cov0" title="0">{
                if cd, err := time.Parse("2006:01:02 15:04:05", createDate); err == nil </span><span class="cov0" title="0">{
                        fileInfo.CreateDate = &amp;cd
                }</span>
        }

        // 相机信息
        <span class="cov0" title="0">if camera, ok := metadata["Model"]; ok </span><span class="cov0" title="0">{
                fileInfo.CameraModel = camera
        }</span>
        <span class="cov0" title="0">if lens, ok := metadata["LensModel"]; ok </span><span class="cov0" title="0">{
                fileInfo.LensModel = lens
        }</span>

        // 拍摄参数
        <span class="cov0" title="0">if iso, ok := metadata["ISO"]; ok </span><span class="cov0" title="0">{
                if i, err := strconv.Atoi(iso); err == nil </span><span class="cov0" title="0">{
                        fileInfo.ISO = i
                }</span>
        }
        <span class="cov0" title="0">if exposureTime, ok := metadata["ExposureTime"]; ok </span><span class="cov0" title="0">{
                fileInfo.ExposureTime = exposureTime
        }</span>
        <span class="cov0" title="0">if fNumber, ok := metadata["FNumber"]; ok </span><span class="cov0" title="0">{
                fileInfo.FNumber = fNumber
        }</span>

        // GPS信息
        <span class="cov0" title="0">if gpsLat, ok := metadata["GPSLatitude"]; ok </span><span class="cov0" title="0">{
                fileInfo.GPSLatitude = gpsLat
        }</span>
        <span class="cov0" title="0">if gpsLon, ok := metadata["GPSLongitude"]; ok </span><span class="cov0" title="0">{
                fileInfo.GPSLongitude = gpsLon
        }</span>
}

// PreserveTimestamp 保留文件时间戳（增强版）
func (mm *MetadataManager) PreserveTimestamp(sourcePath, targetPath string) error <span class="cov0" title="0">{
        // 保留文件时间戳

        // 获取源文件信息
        sourceInfo, err := os.Stat(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("获取源文件信息失败", err)
        }</span>

        // 验证目标文件存在
        <span class="cov0" title="0">if _, err := os.Stat(targetPath); err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("目标文件不存在", err)
        }</span>

        // 记录原始时间戳
        <span class="cov0" title="0">originalModTime := sourceInfo.ModTime()
        originalAccessTime := sourceInfo.ModTime() // 使用修改时间作为访问时间

        // 设置目标文件时间戳（使用高精度时间戳）
        if err := os.Chtimes(targetPath, originalAccessTime, originalModTime); err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("设置文件时间戳失败", err)
        }</span>

        // 验证时间戳设置是否成功
        <span class="cov0" title="0">targetInfo, err := os.Stat(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("验证目标文件信息失败", err)
        }</span>

        // 检查时间戳精度（允许1秒误差）
        <span class="cov0" title="0">timeDiff := targetInfo.ModTime().Unix() - originalModTime.Unix()
        if timeDiff &gt; 1 || timeDiff &lt; -1 </span><span class="cov0" title="0">{
                mm.logger.Warn("时间戳精度警告",
                        zap.String("target", targetPath),
                        zap.Time("expected", originalModTime),
                        zap.Time("actual", targetInfo.ModTime()),
                        zap.Int64("diff_seconds", timeDiff))
        }</span>

        // 文件时间戳保留成功

        <span class="cov0" title="0">return nil</span>
}

// PreserveTimestampWithValidation 带验证的时间戳保留
func (mm *MetadataManager) PreserveTimestampWithValidation(sourcePath, targetPath string, tolerance time.Duration) error <span class="cov0" title="0">{
        // 带验证的时间戳保留

        // 执行基本时间戳保留
        if err := mm.PreserveTimestamp(sourcePath, targetPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 获取源文件和目标文件信息进行验证
        <span class="cov0" title="0">sourceInfo, err := os.Stat(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("获取源文件信息失败", err)
        }</span>

        <span class="cov0" title="0">targetInfo, err := os.Stat(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("获取目标文件信息失败", err)
        }</span>

        // 精确验证时间戳
        <span class="cov0" title="0">timeDiff := targetInfo.ModTime().Sub(sourceInfo.ModTime())
        if timeDiff &gt; tolerance || timeDiff &lt; -tolerance </span><span class="cov0" title="0">{
                return mm.errorHandler.WrapError("时间戳验证失败",
                        fmt.Errorf("时间差超出容忍范围: %v (容忍: %v)", timeDiff, tolerance))
        }</span>

        // 时间戳验证通过

        <span class="cov0" title="0">return nil</span>
}

// CompareMetadata 比较两个文件的元数据（增强版）
func (mm *MetadataManager) CompareMetadata(file1, file2 string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // 比较文件元数据

        // 获取两个文件的基本信息
        info1, err := os.Stat(file1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取文件1信息失败", err)
        }</span>

        <span class="cov0" title="0">info2, err := os.Stat(file2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取文件2信息失败", err)
        }</span>

        // 获取两个文件的元数据
        <span class="cov0" title="0">metadata1, err := mm.GetMetadata(file1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取文件1元数据失败", err)
        }</span>

        <span class="cov0" title="0">metadata2, err := mm.GetMetadata(file2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, mm.errorHandler.WrapError("获取文件2元数据失败", err)
        }</span>

        // 比较结果
        <span class="cov0" title="0">comparison := map[string]interface{}{
                "file1":            filepath.Base(file1),
                "file2":            filepath.Base(file2),
                "identical":        true,
                "differences":      make(map[string]map[string]string),
                "missing_in_file1": make([]string, 0),
                "missing_in_file2": make([]string, 0),
                "file_info": map[string]interface{}{
                        "file1": map[string]interface{}{
                                "size":           info1.Size(),
                                "mod_time":       info1.ModTime(),
                                "metadata_count": len(metadata1),
                        },
                        "file2": map[string]interface{}{
                                "size":           info2.Size(),
                                "mod_time":       info2.ModTime(),
                                "metadata_count": len(metadata2),
                        },
                },
                "timestamp_comparison": map[string]interface{}{
                        "timestamps_match":  info1.ModTime().Equal(info2.ModTime()),
                        "time_diff_seconds": info2.ModTime().Sub(info1.ModTime()).Seconds(),
                },
        }

        differences := comparison["differences"].(map[string]map[string]string)
        missingInFile1 := comparison["missing_in_file1"].([]string)
        missingInFile2 := comparison["missing_in_file2"].([]string)

        // 检查file1中的字段
        for key, value1 := range metadata1 </span><span class="cov0" title="0">{
                if value2, exists := metadata2[key]; exists </span><span class="cov0" title="0">{
                        if value1 != value2 </span><span class="cov0" title="0">{
                                differences[key] = map[string]string{
                                        "file1": value1,
                                        "file2": value2,
                                }
                                comparison["identical"] = false
                        }</span>
                } else<span class="cov0" title="0"> {
                        missingInFile2 = append(missingInFile2, key)
                        comparison["identical"] = false
                }</span>
        }

        // 检查file2中独有的字段
        <span class="cov0" title="0">for key := range metadata2 </span><span class="cov0" title="0">{
                if _, exists := metadata1[key]; !exists </span><span class="cov0" title="0">{
                        missingInFile1 = append(missingInFile1, key)
                        comparison["identical"] = false
                }</span>
        }

        <span class="cov0" title="0">comparison["missing_in_file1"] = missingInFile1
        comparison["missing_in_file2"] = missingInFile2

        // 检查时间戳是否匹配
        timestampsMatch := comparison["timestamp_comparison"].(map[string]interface{})["timestamps_match"].(bool)
        if !timestampsMatch </span><span class="cov0" title="0">{
                comparison["identical"] = false
        }</span>

        // 元数据比较完成

        <span class="cov0" title="0">return comparison, nil</span>
}

// ValidateTimestampPreservation 验证时间戳保留功能
func (mm *MetadataManager) ValidateTimestampPreservation(originalPath, processedPath string, tolerance time.Duration) (bool, error) <span class="cov0" title="0">{
        // 验证时间戳保留

        // 获取原始文件信息
        originalInfo, err := os.Stat(originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, mm.errorHandler.WrapError("获取原始文件信息失败", err)
        }</span>

        // 获取处理后文件信息
        <span class="cov0" title="0">processedInfo, err := os.Stat(processedPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, mm.errorHandler.WrapError("获取处理后文件信息失败", err)
        }</span>

        // 计算时间差
        <span class="cov0" title="0">timeDiff := processedInfo.ModTime().Sub(originalInfo.ModTime())
        isPreserved := timeDiff &lt;= tolerance &amp;&amp; timeDiff &gt;= -tolerance

        // 时间戳保留验证结果

        return isPreserved, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package converter

import (
        "fmt"
        "os"
        "strings"

        "pixly/config"

        "go.uber.org/zap"
)

// PathSecurityChecker 路径安全检查器
type PathSecurityChecker struct {
        config       *config.Config
        logger       *zap.Logger
        errorHandler *ErrorHandler
}

// NewPathSecurityChecker 创建路径安全检查器
func NewPathSecurityChecker(config *config.Config, logger *zap.Logger, errorHandler *ErrorHandler) *PathSecurityChecker <span class="cov0" title="0">{
        return &amp;PathSecurityChecker{
                config:       config,
                logger:       logger,
                errorHandler: errorHandler,
        }
}</span>

// SecurityCheckOptions 安全检查选项
type SecurityCheckOptions struct {
        CheckRead        bool // 检查读权限
        CheckWrite       bool // 检查写权限
        RequireDirectory bool // 要求是目录
        CheckWhitelist   bool // 检查白名单
        CheckBlacklist   bool // 检查黑名单
}

// DefaultSecurityOptions 默认安全检查选项
func DefaultSecurityOptions() SecurityCheckOptions <span class="cov0" title="0">{
        return SecurityCheckOptions{
                CheckRead:        true,
                CheckWrite:       false,
                RequireDirectory: true,
                CheckWhitelist:   true,
                CheckBlacklist:   true,
        }
}</span>

// ValidatePath 统一的路径验证函数
func (psc *PathSecurityChecker) ValidatePath(inputPath string, options SecurityCheckOptions) error <span class="cov0" title="0">{
        // 开始路径安全检查

        // 1. 规范化路径
        normalizedPath, err := GlobalPathUtils.NormalizePath(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return psc.errorHandler.WrapError("路径规范化失败", err)
        }</span>

        // 2. 检查路径存在性和基本属性
        <span class="cov0" title="0">info, err := os.Stat(normalizedPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("路径不存在: %s", normalizedPath)
                }</span>
                <span class="cov0" title="0">return psc.errorHandler.WrapError("无法访问路径", err)</span>
        }

        // 3. 检查是否为目录（如果需要）- 这个检查应该在白名单检查之前
        <span class="cov0" title="0">if options.RequireDirectory &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("指定路径不是目录: %s", normalizedPath)
        }</span>

        // 4. 检查白名单
        <span class="cov0" title="0">if options.CheckWhitelist </span><span class="cov0" title="0">{
                if err := psc.checkWhitelist(normalizedPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 5. 检查黑名单
        <span class="cov0" title="0">if options.CheckBlacklist </span><span class="cov0" title="0">{
                if err := psc.checkBlacklist(normalizedPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 6. 检查读权限
        <span class="cov0" title="0">if options.CheckRead </span><span class="cov0" title="0">{
                if err := psc.checkReadPermission(normalizedPath, info.IsDir()); err != nil </span><span class="cov0" title="0">{
                        return psc.errorHandler.WrapError("路径无读权限", err)
                }</span>
        }

        // 7. 检查写权限
        <span class="cov0" title="0">if options.CheckWrite </span><span class="cov0" title="0">{
                if err := psc.checkWritePermission(normalizedPath, info.IsDir()); err != nil </span><span class="cov0" title="0">{
                        return psc.errorHandler.WrapError("路径无写权限", err)
                }</span>
        }

        // 路径安全检查通过
        <span class="cov0" title="0">return nil</span>
}

// checkWhitelist 检查白名单
func (psc *PathSecurityChecker) checkWhitelist(normalizedPath string) error <span class="cov0" title="0">{
        if len(psc.config.Security.AllowedDirectories) == 0 </span><span class="cov0" title="0">{
                return nil // 没有白名单限制
        }</span>

        <span class="cov0" title="0">for _, allowedDir := range psc.config.Security.AllowedDirectories </span><span class="cov0" title="0">{
                normalizedAllowedDir, err := GlobalPathUtils.NormalizePath(allowedDir)
                if err != nil </span><span class="cov0" title="0">{
                        psc.logger.Warn("白名单路径规范化失败", zap.String("path", allowedDir), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if psc.isPathInDirectory(normalizedPath, normalizedAllowedDir) </span><span class="cov0" title="0">{
                        return nil // 在白名单中
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("路径不在允许的目录白名单中: %s", normalizedPath)</span>
}

// checkBlacklist 检查黑名单
func (psc *PathSecurityChecker) checkBlacklist(normalizedPath string) error <span class="cov0" title="0">{
        for _, forbiddenDir := range psc.config.Security.ForbiddenDirectories </span><span class="cov0" title="0">{
                normalizedForbiddenDir, err := GlobalPathUtils.NormalizePath(forbiddenDir)
                if err != nil </span><span class="cov0" title="0">{
                        psc.logger.Warn("黑名单路径规范化失败", zap.String("path", forbiddenDir), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if psc.isPathInDirectory(normalizedPath, normalizedForbiddenDir) </span><span class="cov0" title="0">{
                        return fmt.Errorf("路径在禁止访问的目录中: %s", normalizedPath)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isPathInDirectory 检查路径是否在指定目录内
func (psc *PathSecurityChecker) isPathInDirectory(path, directory string) bool <span class="cov0" title="0">{
        normalizedPath, err := GlobalPathUtils.NormalizePath(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">normalizedDir, err := GlobalPathUtils.NormalizePath(directory)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查路径是否相等或者是子路径
        <span class="cov0" title="0">if normalizedPath == normalizedDir </span><span class="cov0" title="0">{
                return true
        }</span>

        // 使用 strings.HasPrefix 检查是否为子路径
        // 确保目录路径以 / 结尾，避免误匹配
        <span class="cov0" title="0">dirWithSlash := normalizedDir
        if !strings.HasSuffix(dirWithSlash, "/") </span><span class="cov0" title="0">{
                dirWithSlash += "/"
        }</span>

        <span class="cov0" title="0">return strings.HasPrefix(normalizedPath, dirWithSlash)</span>
}

// checkReadPermission 检查读权限
func (psc *PathSecurityChecker) checkReadPermission(path string, isDir bool) error <span class="cov0" title="0">{
        if isDir </span><span class="cov0" title="0">{
                // 目录读权限检查 - 直接使用 os.ReadDir，无需手动打开文件
                _, err := os.ReadDir(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                // 文件读权限检查
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                psc.logger.Warn("Failed to close file during read permission check",
                                        zap.String("path", path),
                                        zap.Error(err))
                        }</span>
                }()
        }
        <span class="cov0" title="0">return nil</span>
}

// checkWritePermission 检查写权限
func (psc *PathSecurityChecker) checkWritePermission(path string, isDir bool) error <span class="cov0" title="0">{
        normalizedPath, err := GlobalPathUtils.NormalizePath(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var testPath string
        if isDir </span><span class="cov0" title="0">{
                // 在目录中创建临时文件测试写权限
                testPath, err = GlobalPathUtils.JoinPath(normalizedPath, ".pixly_write_test")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // 对于文件，测试其父目录的写权限
                parentDir := GlobalPathUtils.GetDirName(normalizedPath)
                testPath, err = GlobalPathUtils.JoinPath(parentDir, ".pixly_write_test")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">file, err := os.Create(testPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 关闭并删除临时文件
        <span class="cov0" title="0">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                psc.logger.Warn("Failed to close temporary file during write permission check",
                        zap.String("testPath", testPath),
                        zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := os.Remove(testPath); err != nil </span><span class="cov0" title="0">{
                psc.logger.Warn("Failed to remove temporary file during write permission check",
                        zap.String("testPath", testPath),
                        zap.Error(err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package converter

import (
        "io"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "unicode/utf8"

        "golang.org/x/text/encoding/simplifiedchinese"
        "golang.org/x/text/transform"
)

// PathUtils 路径处理工具
type PathUtils struct{}

// NormalizePath 彻底的路径规范化
func (pu *PathUtils) NormalizePath(input string) (string, error) <span class="cov8" title="1">{
        // 1. 跳过URI解码 - 这是破坏中文文件名的罪魁祸首！
        // 只有当路径明确包含%编码时才进行解码
        decodedPath := input
        if strings.Contains(input, "%") </span><span class="cov0" title="0">{
                // 只对真正的URL编码路径进行解码
                if decoded, err := url.QueryUnescape(input); err == nil </span><span class="cov0" title="0">{
                        // 验证解码后的路径是否合理
                        if utf8.ValidString(decoded) </span><span class="cov0" title="0">{
                                decodedPath = decoded
                        }</span>
                }
        }

        // 2. 处理 ~ 符号
        <span class="cov8" title="1">if strings.HasPrefix(decodedPath, "~") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">decodedPath = filepath.Join(homeDir, decodedPath[1:])</span>
        }

        // 3. 转换为绝对路径
        <span class="cov8" title="1">absPath, err := filepath.Abs(decodedPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 4. 处理反斜杠（Windows路径）
        <span class="cov8" title="1">absPath = strings.ReplaceAll(absPath, "\\", string(filepath.Separator))

        // 5. 验证 UTF-8 编码
        if !utf8.ValidString(absPath) </span><span class="cov0" title="0">{
                // 尝试修复编码问题
                fixedPath := pu.detectAndFixEncoding(absPath)
                absPath = fixedPath
        }</span>

        <span class="cov8" title="1">return absPath, nil</span>
}

// detectAndFixEncoding 智能检测并修复路径编码问题
func (pu *PathUtils) detectAndFixEncoding(path string) string <span class="cov0" title="0">{
        // 如果已经是有效的UTF-8，直接返回
        if utf8.ValidString(path) </span><span class="cov0" title="0">{
                return path
        }</span>

        // 尝试多种编码检测和转换
        <span class="cov0" title="0">encodings := []struct {
                name    string
                decoder transform.Transformer
        }{
                {"GBK", simplifiedchinese.GBK.NewDecoder()},
                {"GB18030", simplifiedchinese.GB18030.NewDecoder()},
        }

        for _, enc := range encodings </span><span class="cov0" title="0">{
                // 将无效UTF-8字符串的字节重新解释为指定编码
                reader := transform.NewReader(strings.NewReader(path), enc.decoder)
                decoded, err := io.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // 尝试下一种编码
                }

                <span class="cov0" title="0">decodedStr := string(decoded)
                // 检查解码结果是否合理（包含可打印字符且为有效UTF-8）
                if utf8.ValidString(decodedStr) &amp;&amp; len(strings.TrimSpace(decodedStr)) &gt; 0 </span><span class="cov0" title="0">{
                        return decodedStr
                }</span>
        }

        // 如果所有编码都失败，返回原始路径
        <span class="cov0" title="0">return path</span>
}

// ValidatePath 验证路径是否有效
func (pu *PathUtils) ValidatePath(path string) bool <span class="cov0" title="0">{
        // 检查路径是否为空
        if path == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查路径是否只包含点（当前目录）
        <span class="cov0" title="0">if path == "." </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查路径是否包含真正的非法字符（控制字符，除了文件系统允许的字符）
        // 只禁止真正的危险字符，如空字符和换行符
        <span class="cov0" title="0">illegalChars := []string{"\x00", "\n", "\r"}
        for _, char := range illegalChars </span><span class="cov0" title="0">{
                if strings.Contains(path, char) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// IsPathSafe 检查路径是否安全（防止路径遍历攻击）
func (pu *PathUtils) IsPathSafe(basePath, targetPath string) bool <span class="cov0" title="0">{
        // 解析并清理路径
        cleanTargetPath, err := filepath.Abs(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">cleanBasePath, err := filepath.Abs(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查目标路径是否在基础路径内
        <span class="cov0" title="0">relPath, err := filepath.Rel(cleanBasePath, cleanTargetPath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查相对路径是否包含 ".."
        <span class="cov0" title="0">return !strings.HasPrefix(relPath, "..")</span>
}

// GetPathInfo 获取路径信息
func (pu *PathUtils) GetPathInfo(path string) (os.FileInfo, error) <span class="cov0" title="0">{
        // 规范化路径
        normalizedPath, err := pu.NormalizePath(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 获取文件信息
        <span class="cov0" title="0">info, err := os.Stat(normalizedPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// JoinPath 连接路径并规范化
func (pu *PathUtils) JoinPath(elem ...string) (string, error) <span class="cov8" title="1">{
        if len(elem) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // 使用filepath.Join连接路径
        <span class="cov8" title="1">joinedPath := filepath.Join(elem...)

        // 规范化连接后的路径
        return pu.NormalizePath(joinedPath)</span>
}

// GetBaseName 获取路径的基础名称
func (pu *PathUtils) GetBaseName(path string) string <span class="cov0" title="0">{
        return filepath.Base(path)
}</span>

// GetDirName 获取路径的目录名称
func (pu *PathUtils) GetDirName(path string) string <span class="cov0" title="0">{
        return filepath.Dir(path)
}</span>

// GetExtension 获取文件扩展名
func (pu *PathUtils) GetExtension(path string) string <span class="cov0" title="0">{
        return filepath.Ext(path)
}</span>

// IsAbsPath 检查路径是否为绝对路径
func (pu *PathUtils) IsAbsPath(path string) bool <span class="cov0" title="0">{
        return filepath.IsAbs(path)
}</span>

// CleanPath 清理路径
func (pu *PathUtils) CleanPath(path string) string <span class="cov0" title="0">{
        return filepath.Clean(path)
}</span>

// RelPath 获取相对路径
func (pu *PathUtils) RelPath(basepath, targpath string) (string, error) <span class="cov0" title="0">{
        // 先规范化两个路径
        normalizedBase, err := pu.NormalizePath(basepath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">normalizedTarget, err := pu.NormalizePath(targpath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Rel(normalizedBase, normalizedTarget)</span>
}

// SplitPath 分割路径
func (pu *PathUtils) SplitPath(path string) (dir, file string) <span class="cov0" title="0">{
        return filepath.Split(path)
}</span>

// WalkPath 遍历目录
func (pu *PathUtils) WalkPath(root string, walkFn filepath.WalkFunc) error <span class="cov0" title="0">{
        // 先规范化根路径
        normalizedRoot, err := pu.NormalizePath(root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return filepath.Walk(normalizedRoot, walkFn)</span>
}

// WalkDirPath 遍历目录（使用WalkDir）
func (pu *PathUtils) WalkDirPath(root string, walkDirFn func(path string, d os.DirEntry, err error) error) error <span class="cov0" title="0">{
        // 先规范化根路径
        normalizedRoot, err := pu.NormalizePath(root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return filepath.WalkDir(normalizedRoot, walkDirFn)</span>
}

// GlobalPathUtils 全局路径处理工具实例
var GlobalPathUtils = &amp;PathUtils{}
</pre>
		
		<pre class="file" id="file13" style="display: none">package converter

import (
        "context"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/disk"
        "github.com/shirou/gopsutil/v3/host"
        "github.com/shirou/gopsutil/v3/load"
        "github.com/shirou/gopsutil/v3/mem"
        "github.com/shirou/gopsutil/v3/net"
        "go.uber.org/zap"
)

// PerformanceOptimizer 性能优化器
type PerformanceOptimizer struct {
        logger          *zap.Logger
        maxWorkers      int32
        currentWorkers  int32
        memoryThreshold float64 // 内存使用阈值 (0.0-1.0)
        cpuThreshold    float64 // CPU使用阈值 (0.0-1.0)
        monitorInterval time.Duration
        ctx             context.Context
        cancel          context.CancelFunc
        mutex           sync.RWMutex

        // 性能指标
        metrics    *PerformanceMetrics
        memoryPool *MemoryPool

        // 动态调整参数
        adjustmentFactor     float64
        lastAdjustment       time.Time
        minWorkers           int32
        maxMemoryMB          int64
        optimizationCooldown time.Duration
}

// PerformanceMetrics 性能指标
type PerformanceMetrics struct {
        TotalProcessed  int64
        AverageTime     time.Duration
        MemoryUsage     float64
        MemoryAvailable uint64
        MemoryTotal     uint64
        CPUUsage        float64
        CPUCores        int
        GoroutineCount  int
        GCPauseTime     time.Duration
        Throughput      float64 // 文件/秒
        ProcessingRate  float64
        ErrorRate       float64
        // 磁盘监控
        DiskUsagePercent float64
        DiskReadBytes    uint64
        DiskWriteBytes   uint64
        DiskIOPS         float64
        // 网络监控
        NetworkSentBytes uint64
        NetworkRecvBytes uint64
        NetworkPackets   uint64
        // 系统负载
        LoadAverage1  float64
        LoadAverage5  float64
        LoadAverage15 float64
        // 系统信息
        Uptime       uint64
        ProcessCount uint64
        LastUpdate   time.Time
        mutex        sync.RWMutex
}

// NewPerformanceOptimizer 创建性能优化器
func NewPerformanceOptimizer(logger *zap.Logger, maxWorkers int, memoryLimitMB int64) *PerformanceOptimizer <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        optimizer := &amp;PerformanceOptimizer{
                logger:               logger,
                maxWorkers:           int32(maxWorkers),
                currentWorkers:       int32(maxWorkers / 2), // 从一半开始
                memoryThreshold:      0.75,                  // 75%内存阈值
                cpuThreshold:         0.8,                   // 80%CPU阈值
                monitorInterval:      time.Second * 3,       // 更频繁的监控
                ctx:                  ctx,
                cancel:               cancel,
                metrics:              &amp;PerformanceMetrics{},
                memoryPool:           GetGlobalMemoryPool(logger),
                adjustmentFactor:     1.2,
                minWorkers:           int32(max(1, runtime.NumCPU()/2)),
                maxMemoryMB:          memoryLimitMB,
                optimizationCooldown: time.Second * 10,
        }

        // 启动监控协程
        go optimizer.monitor()

        return optimizer
}</span>

// GetOptimalWorkerCount 获取最优工作线程数
func (po *PerformanceOptimizer) GetOptimalWorkerCount() int <span class="cov0" title="0">{
        return int(atomic.LoadInt32(&amp;po.currentWorkers))
}</span>

// AdjustWorkerCount 调整工作线程数
func (po *PerformanceOptimizer) AdjustWorkerCount(delta int) <span class="cov0" title="0">{
        po.mutex.Lock()
        defer po.mutex.Unlock()

        newCount := po.currentWorkers + int32(delta)
        if newCount &lt; po.minWorkers </span><span class="cov0" title="0">{
                newCount = po.minWorkers
        }</span> else<span class="cov0" title="0"> if newCount &gt; po.maxWorkers </span><span class="cov0" title="0">{
                newCount = po.maxWorkers
        }</span>

        <span class="cov0" title="0">if newCount != po.currentWorkers </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;po.currentWorkers, newCount)
                po.lastAdjustment = time.Now()
                // 调整工作线程数
        }</span>
}

// monitor 监控系统性能并动态调整
func (po *PerformanceOptimizer) monitor() <span class="cov0" title="0">{
        ticker := time.NewTicker(po.monitorInterval)
        defer ticker.Stop()

        // 内存池统计定时器
        memoryPoolTicker := time.NewTicker(time.Minute * 5)
        defer memoryPoolTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-po.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        memInfo, err := mem.VirtualMemory()
                        if err != nil </span><span class="cov0" title="0">{
                                po.logger.Error("获取内存信息失败", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">po.updateMetrics(memInfo)
                        if time.Since(po.lastAdjustment) &gt;= po.optimizationCooldown </span><span class="cov0" title="0">{
                                po.performOptimization()
                        }</span>
                case &lt;-memoryPoolTicker.C:<span class="cov0" title="0">
                        po.memoryPool.LogStats()</span>
                }
        }
}

// performOptimization 执行性能优化
func (po *PerformanceOptimizer) performOptimization() <span class="cov0" title="0">{
        // 获取内存使用情况
        memInfo, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                po.logger.Warn("获取内存信息失败", zap.Error(err))
                return
        }</span>

        // 更新性能指标
        <span class="cov0" title="0">po.updateMetrics(memInfo)

        // 检查是否需要调整
        if time.Since(po.lastAdjustment) &lt; time.Minute </span><span class="cov0" title="0">{
                return // 避免频繁调整
        }</span>

        <span class="cov0" title="0">currentMemoryUsage := memInfo.UsedPercent / 100.0
        currentWorkers := atomic.LoadInt32(&amp;po.currentWorkers)

        // 获取CPU使用率
        po.metrics.mutex.RLock()
        cpuUsage := po.metrics.CPUUsage
        goroutineCount := po.metrics.GoroutineCount
        gcPauseTime := po.metrics.GCPauseTime
        po.metrics.mutex.RUnlock()

        // 内存压力过大，减少工作线程
        if currentMemoryUsage &gt; po.memoryThreshold </span><span class="cov0" title="0">{
                reduction := int(float64(currentWorkers) * 0.2) // 减少20%
                if reduction &lt; 1 </span><span class="cov0" title="0">{
                        reduction = 1
                }</span>
                <span class="cov0" title="0">po.AdjustWorkerCount(-reduction)
                // 内存压力过大，减少工作线程

                // 清理内存池
                po.memoryPool.Cleanup()
                // 强制GC
                runtime.GC()
                return</span>
        }

        // CPU压力过大，减少工作线程
        <span class="cov0" title="0">if cpuUsage &gt; po.cpuThreshold </span><span class="cov0" title="0">{
                reduction := int(float64(currentWorkers) * 0.15) // 减少15%
                if reduction &lt; 1 </span><span class="cov0" title="0">{
                        reduction = 1
                }</span>
                <span class="cov0" title="0">po.AdjustWorkerCount(-reduction)
                // CPU压力过大，减少工作线程
                return</span>
        }

        // 内存使用较低且性能良好，可以增加工作线程
        <span class="cov0" title="0">if currentMemoryUsage &lt; 0.6 &amp;&amp; cpuUsage &lt; 0.6 &amp;&amp; currentWorkers &lt; po.maxWorkers </span><span class="cov0" title="0">{
                // 检查吞吐量是否稳定
                po.metrics.mutex.RLock()
                throughput := po.metrics.Throughput
                po.metrics.mutex.RUnlock()

                if throughput &gt; 0 </span><span class="cov0" title="0">{ // 有活跃处理
                        increase := int(float64(currentWorkers) * 0.1) // 增加10%
                        if increase &lt; 1 </span><span class="cov0" title="0">{
                                increase = 1
                        }</span>
                        <span class="cov0" title="0">po.AdjustWorkerCount(increase)</span>
                        // 性能良好，增加工作线程
                }
        }

        // 检查GC压力和Goroutine数量
        <span class="cov0" title="0">if gcPauseTime &gt; time.Millisecond*50 || goroutineCount &gt; runtime.NumCPU()*100 </span><span class="cov0" title="0">{
                // GC暂停时间过长或Goroutine数量过多，减少工作线程
                reduction := int(float64(currentWorkers) * 0.1)
                if reduction &lt; 1 </span><span class="cov0" title="0">{
                        reduction = 1
                }</span>
                <span class="cov0" title="0">po.AdjustWorkerCount(-reduction)</span>
        }
}

// updateMetrics 更新性能指标
func (po *PerformanceOptimizer) updateMetrics(memInfo *mem.VirtualMemoryStat) <span class="cov0" title="0">{
        po.metrics.mutex.Lock()
        defer po.metrics.mutex.Unlock()

        // 获取CPU信息
        cpuPercent, err := cpu.Percent(time.Millisecond*100, false)
        if err != nil </span><span class="cov0" title="0">{
                po.logger.Warn("获取CPU信息失败", zap.Error(err))
                // 回退到基于Goroutine的估算
                po.metrics.CPUUsage = float64(runtime.NumGoroutine()) / float64(runtime.NumCPU()*10)
                if po.metrics.CPUUsage &gt; 1.0 </span><span class="cov0" title="0">{
                        po.metrics.CPUUsage = 1.0
                }</span>
        } else<span class="cov0" title="0"> if len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                po.metrics.CPUUsage = cpuPercent[0] / 100.0
        }</span>

        // 获取CPU核心数
        <span class="cov0" title="0">po.metrics.CPUCores = runtime.NumCPU()

        // 获取运行时信息
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        po.metrics.MemoryUsage = memInfo.UsedPercent / 100.0
        po.metrics.MemoryAvailable = memInfo.Available
        po.metrics.MemoryTotal = memInfo.Total
        po.metrics.GoroutineCount = runtime.NumGoroutine()
        po.metrics.GCPauseTime = time.Duration(m.PauseNs[(m.NumGC+255)%256])

        // 获取磁盘使用情况
        if diskStat, err := disk.Usage("/"); err == nil </span><span class="cov0" title="0">{
                po.metrics.DiskUsagePercent = diskStat.UsedPercent
        }</span>

        // 获取磁盘IO统计
        <span class="cov0" title="0">if diskIOStats, err := disk.IOCounters(); err == nil </span><span class="cov0" title="0">{
                var totalReadBytes, totalWriteBytes uint64
                var totalIOPS float64
                for _, stat := range diskIOStats </span><span class="cov0" title="0">{
                        totalReadBytes += stat.ReadBytes
                        totalWriteBytes += stat.WriteBytes
                        totalIOPS += float64(stat.ReadCount + stat.WriteCount)
                }</span>
                <span class="cov0" title="0">po.metrics.DiskReadBytes = totalReadBytes
                po.metrics.DiskWriteBytes = totalWriteBytes
                po.metrics.DiskIOPS = totalIOPS</span>
        }

        // 获取网络统计
        <span class="cov0" title="0">if netIOStats, err := net.IOCounters(false); err == nil &amp;&amp; len(netIOStats) &gt; 0 </span><span class="cov0" title="0">{
                var totalSent, totalRecv, totalPackets uint64
                for _, stat := range netIOStats </span><span class="cov0" title="0">{
                        totalSent += stat.BytesSent
                        totalRecv += stat.BytesRecv
                        totalPackets += stat.PacketsSent + stat.PacketsRecv
                }</span>
                <span class="cov0" title="0">po.metrics.NetworkSentBytes = totalSent
                po.metrics.NetworkRecvBytes = totalRecv
                po.metrics.NetworkPackets = totalPackets</span>
        }

        // 获取系统负载
        <span class="cov0" title="0">if loadStat, err := load.Avg(); err == nil </span><span class="cov0" title="0">{
                po.metrics.LoadAverage1 = loadStat.Load1
                po.metrics.LoadAverage5 = loadStat.Load5
                po.metrics.LoadAverage15 = loadStat.Load15
        }</span>

        // 获取系统信息
        <span class="cov0" title="0">if hostInfo, err := host.Info(); err == nil </span><span class="cov0" title="0">{
                po.metrics.Uptime = hostInfo.Uptime
                po.metrics.ProcessCount = uint64(hostInfo.Procs)
        }</span>

        <span class="cov0" title="0">po.metrics.LastUpdate = time.Now()

        // 计算处理速率（如果有历史数据）
        if po.metrics.TotalProcessed &gt; 0 </span><span class="cov0" title="0">{
                elapsed := time.Since(po.metrics.LastUpdate)
                if elapsed &gt; 0 </span><span class="cov0" title="0">{
                        po.metrics.ProcessingRate = float64(po.metrics.TotalProcessed) / elapsed.Seconds()
                }</span>
        }
}

// RecordProcessing 记录处理性能
func (po *PerformanceOptimizer) RecordProcessing(duration time.Duration) <span class="cov0" title="0">{
        po.metrics.mutex.Lock()
        defer po.metrics.mutex.Unlock()

        po.metrics.TotalProcessed++

        // 计算平均处理时间
        if po.metrics.AverageTime == 0 </span><span class="cov0" title="0">{
                po.metrics.AverageTime = duration
        }</span> else<span class="cov0" title="0"> {
                // 使用指数移动平均
                alpha := 0.1
                po.metrics.AverageTime = time.Duration(float64(po.metrics.AverageTime)*(1-alpha) + float64(duration)*alpha)
        }</span>

        // 计算吞吐量 (最近5分钟)
        <span class="cov0" title="0">now := time.Now()
        if now.Sub(po.metrics.LastUpdate) &gt; 0 </span><span class="cov0" title="0">{
                po.metrics.Throughput = float64(po.metrics.TotalProcessed) / now.Sub(po.metrics.LastUpdate).Seconds()
        }</span>
}

// GetMetrics 获取性能指标
func (po *PerformanceOptimizer) GetMetrics() PerformanceMetrics <span class="cov0" title="0">{
        po.metrics.mutex.RLock()
        defer po.metrics.mutex.RUnlock()

        // 返回不包含锁的副本
        return PerformanceMetrics{
                TotalProcessed:   po.metrics.TotalProcessed,
                AverageTime:      po.metrics.AverageTime,
                MemoryUsage:      po.metrics.MemoryUsage,
                MemoryAvailable:  po.metrics.MemoryAvailable,
                MemoryTotal:      po.metrics.MemoryTotal,
                CPUUsage:         po.metrics.CPUUsage,
                CPUCores:         po.metrics.CPUCores,
                GoroutineCount:   po.metrics.GoroutineCount,
                GCPauseTime:      po.metrics.GCPauseTime,
                Throughput:       po.metrics.Throughput,
                ProcessingRate:   po.metrics.ProcessingRate,
                ErrorRate:        po.metrics.ErrorRate,
                DiskUsagePercent: po.metrics.DiskUsagePercent,
                DiskReadBytes:    po.metrics.DiskReadBytes,
                DiskWriteBytes:   po.metrics.DiskWriteBytes,
                DiskIOPS:         po.metrics.DiskIOPS,
                NetworkSentBytes: po.metrics.NetworkSentBytes,
                NetworkRecvBytes: po.metrics.NetworkRecvBytes,
                NetworkPackets:   po.metrics.NetworkPackets,
                LoadAverage1:     po.metrics.LoadAverage1,
                LoadAverage5:     po.metrics.LoadAverage5,
                LoadAverage15:    po.metrics.LoadAverage15,
                Uptime:           po.metrics.Uptime,
                ProcessCount:     po.metrics.ProcessCount,
                LastUpdate:       po.metrics.LastUpdate,
        }
}</span>

// Shutdown 关闭优化器
func (po *PerformanceOptimizer) Shutdown() <span class="cov0" title="0">{
        po.cancel()
        // 性能优化器已关闭
}</span>

// IsMemoryPressureHigh 检查内存压力是否过高
func (po *PerformanceOptimizer) IsMemoryPressureHigh() bool <span class="cov0" title="0">{
        memInfo, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return memInfo.UsedPercent/100.0 &gt; po.memoryThreshold</span>
}

// GetRecommendedBatchSize 获取推荐的批处理大小
func (po *PerformanceOptimizer) GetRecommendedBatchSize() int <span class="cov0" title="0">{
        currentWorkers := atomic.LoadInt32(&amp;po.currentWorkers)
        memInfo, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return int(currentWorkers) * 2
        }</span>

        // 根据内存使用情况调整批处理大小
        <span class="cov0" title="0">memoryUsage := memInfo.UsedPercent / 100.0
        if memoryUsage &gt; 0.8 </span><span class="cov0" title="0">{
                return int(currentWorkers) // 高内存压力时减少批处理大小
        }</span> else<span class="cov0" title="0"> if memoryUsage &lt; 0.5 </span><span class="cov0" title="0">{
                return int(currentWorkers) * 3 // 低内存使用时增加批处理大小
        }</span>
        <span class="cov0" title="0">return int(currentWorkers) * 2</span> // 默认批处理大小
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package converter

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// DetailedReport 详细转换报告
type DetailedReport struct {
        StartTime        time.Time              `json:"start_time"`
        EndTime          time.Time              `json:"end_time"`
        Duration         time.Duration          `json:"duration"`
        SourceDirectory  string                 `json:"source_directory"`
        TotalFiles       int                    `json:"total_files"`
        ProcessedFiles   int                    `json:"processed_files"`
        SuccessfulFiles  int                    `json:"successful_files"`
        FailedFiles      int                    `json:"failed_files"`
        SkippedFiles     int                    `json:"skipped_files"`
        TotalSizeBefore  int64                  `json:"total_size_before"`
        TotalSizeAfter   int64                  `json:"total_size_after"`
        SpaceSaved       int64                  `json:"space_saved"`
        CompressionRatio float64                `json:"compression_ratio"`
        ConversionMode   string                 `json:"conversion_mode"`
        FileDetails      []FileConversionDetail `json:"file_details"`
        FormatSummary    map[string]FormatStats `json:"format_summary"`
        SystemInfo       SystemInfo             `json:"system_info"`
        Errors           []ConversionError      `json:"errors"`
}

// FileConversionDetail 文件转换详细信息
type FileConversionDetail struct {
        OriginalPath     string        `json:"original_path"`
        OutputPath       string        `json:"output_path"`
        OriginalSize     int64         `json:"original_size"`
        OutputSize       int64         `json:"output_size"`
        CompressionRatio float64       `json:"compression_ratio"`
        OriginalFormat   string        `json:"original_format"`
        OutputFormat     string        `json:"output_format"`
        ProcessingTime   time.Duration `json:"processing_time"`
        Method           string        `json:"method"`
        Success          bool          `json:"success"`
        Skipped          bool          `json:"skipped"`               // 文件是否被跳过
        SkipReason       string        `json:"skip_reason,omitempty"` // 跳过原因
        Error            string        `json:"error,omitempty"`
        MediaInfo        *MediaInfo    `json:"media_info,omitempty"`
}

// MediaInfo 媒体文件详细信息
type MediaInfo struct {
        // README中定义的字段
        FullPath       string    `json:"full_path,omitempty"`       // 规范化后的绝对路径
        FileSize       int64     `json:"file_size,omitempty"`       // 文件大小（字节）
        ModTime        time.Time `json:"mod_time,omitempty"`        // 文件最后修改时间
        SHA256Hash     string    `json:"sha256_hash,omitempty"`     // 文件内容的 SHA256 哈希值，用于状态跟踪
        Codec          string    `json:"codec,omitempty"`           // 主要编解码器名称
        FrameCount     int       `json:"frame_count,omitempty"`     // 帧数，用于区分动图和静图
        IsAnimated     bool      `json:"is_animated,omitempty"`     // 是否为动图或视频
        IsCorrupted    bool      `json:"is_corrupted,omitempty"`    // 是否检测为损坏文件
        InitialQuality int       `json:"initial_quality,omitempty"` // 预估的初始质量（1-100）

        // 怀疑度评分制度 - README要求的关键功能
        SuspicionScore   int      `json:"suspicion_score,omitempty"`   // 可疑特征累计评分（0-100），达到阈值才进行深度分析
        SuspicionReasons []string `json:"suspicion_reasons,omitempty"` // 可疑特征列表，用于调试和日志

        // Magic Number 检测和扩展名修正字段
        DetectedFormat           string `json:"detected_format,omitempty"`            // 通过Magic Number检测到的实际格式
        NeedsExtensionCorrection bool   `json:"needs_extension_correction,omitempty"` // 是否需要扩展名修正

        // 新增字段用于批处理器
        Container               string `json:"container,omitempty"`                 // 容器格式
        IsCodecIncompatible     bool   `json:"is_codec_incompatible,omitempty"`     // 编解码器是否不兼容
        IsContainerIncompatible bool   `json:"is_container_incompatible,omitempty"` // 容器是否不兼容

        // 现有字段
        Width      int     `json:"width,omitempty"`
        Height     int     `json:"height,omitempty"`
        Duration   float64 `json:"duration,omitempty"`
        Bitrate    int     `json:"bitrate,omitempty"`
        FrameRate  float64 `json:"frame_rate,omitempty"`
        HasAudio   bool    `json:"has_audio,omitempty"`
        ColorSpace string  `json:"color_space,omitempty"`
}

// FormatStats 格式统计
type FormatStats struct {
        Count              int     `json:"count"`
        TotalSizeBefore    int64   `json:"total_size_before"`
        TotalSizeAfter     int64   `json:"total_size_after"`
        AverageCompression float64 `json:"average_compression"`
}

// SystemInfo 系统信息
type SystemInfo struct {
        OS          string `json:"os"`
        Arch        string `json:"arch"`
        CPUCores    int    `json:"cpu_cores"`
        Concurrency int    `json:"concurrency"`
        MemoryUsed  uint64 `json:"memory_used_mb"`
}

// ConversionError 转换错误
type ConversionError struct {
        File  string    `json:"file"`
        Error string    `json:"error"`
        Time  time.Time `json:"time"`
}

// generateReport 生成详细转换报告
func (c *Converter) generateReport() error <span class="cov0" title="0">{
        // 生成详细转换报告

        endTime := time.Now()
        startTime := endTime.Add(-c.stats.TotalDuration)

        report := DetailedReport{
                StartTime:        startTime,
                EndTime:          endTime,
                Duration:         c.stats.TotalDuration,
                SourceDirectory:  c.getSourceDirectory(),
                TotalFiles:       c.stats.TotalFiles,
                ProcessedFiles:   c.stats.ProcessedFiles,
                SuccessfulFiles:  c.stats.SuccessfulFiles,
                FailedFiles:      c.stats.FailedFiles,
                SkippedFiles:     c.stats.SkippedFiles,
                TotalSizeBefore:  c.stats.TotalSize,
                TotalSizeAfter:   c.stats.CompressedSize,
                SpaceSaved:       c.stats.TotalSize - c.stats.CompressedSize,
                CompressionRatio: c.stats.CompressionRatio,
                ConversionMode:   string(c.mode),
                FileDetails:      c.generateFileDetails(),
                FormatSummary:    c.generateFormatSummary(),
                SystemInfo:       c.getSystemInfo(),
                Errors:           c.collectErrors(),
        }

        // 保存JSON报告
        if err := c.saveJSONReport(report); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("保存JSON报告失败", zap.Error(err))
        }</span>

        // 生成可读报告
        <span class="cov0" title="0">if err := c.generateReadableReport(report); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("生成可读报告失败", zap.Error(err))
        }</span>

        // 验证转换结果
        <span class="cov0" title="0">if err := c.verifyConversionResults(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("验证转换结果失败", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateFileDetails 生成文件详细信息
func (c *Converter) generateFileDetails() []FileConversionDetail <span class="cov0" title="0">{
        var details []FileConversionDetail

        for _, result := range c.results </span><span class="cov0" title="0">{
                detail := FileConversionDetail{
                        OriginalPath:     result.OriginalFile.Path,
                        OriginalSize:     result.OriginalSize,
                        OutputSize:       result.CompressedSize,
                        CompressionRatio: result.CompressionRatio,
                        OriginalFormat:   result.OriginalFile.Extension,
                        ProcessingTime:   result.Duration,
                        Method:           result.Method,
                        Success:          result.Success,
                        Skipped:          result.Skipped,
                        SkipReason:       result.SkipReason,
                }

                // 处理跳过的文件
                if result.Skipped </span><span class="cov0" title="0">{
                        // 跳过的文件输出路径为原路径，输出格式为原格式
                        detail.OutputPath = result.OriginalFile.Path
                        detail.OutputFormat = result.OriginalFile.Extension
                }</span> else<span class="cov0" title="0"> {
                        // 正常转换的文件
                        detail.OutputPath = result.OutputPath
                        detail.OutputFormat = GlobalPathUtils.GetExtension(result.OutputPath)
                }</span>

                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        detail.Error = result.Error.Error()
                }</span>

                // 获取媒体信息
                <span class="cov0" title="0">if result.Success &amp;&amp; !result.Skipped &amp;&amp; (result.OriginalFile.Type == TypeImage || result.OriginalFile.Type == TypeVideo) </span><span class="cov0" title="0">{
                        if mediaInfo := c.getMediaInfo(result.OutputPath); mediaInfo != nil </span><span class="cov0" title="0">{
                                detail.MediaInfo = mediaInfo
                        }</span>
                }

                <span class="cov0" title="0">details = append(details, detail)</span>
        }

        <span class="cov0" title="0">return details</span>
}

// generateFormatSummary 生成格式统计
func (c *Converter) generateFormatSummary() map[string]FormatStats <span class="cov0" title="0">{
        formatStats := make(map[string]FormatStats)

        for _, result := range c.results </span><span class="cov0" title="0">{
                if !result.Success || result.Skipped </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">format := result.OriginalFile.Extension
                stats := formatStats[format]

                stats.Count++
                stats.TotalSizeBefore += result.OriginalSize
                stats.TotalSizeAfter += result.CompressedSize

                if stats.TotalSizeBefore &gt; 0 </span><span class="cov0" title="0">{
                        stats.AverageCompression = float64(stats.TotalSizeBefore-stats.TotalSizeAfter) / float64(stats.TotalSizeBefore) * 100
                }</span>

                <span class="cov0" title="0">formatStats[format] = stats</span>
        }

        <span class="cov0" title="0">return formatStats</span>
}

// getMediaInfo 获取媒体文件信息
func (c *Converter) getMediaInfo(filePath string) *MediaInfo <span class="cov0" title="0">{
        if !c.isMediaFile(filePath) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 首先尝试从内存池获取缓存的媒体信息
        <span class="cov0" title="0">if cachedMediaInfo := c.memoryPool.GetMediaInfo(); cachedMediaInfo != nil &amp;&amp; cachedMediaInfo.FullPath == filePath </span><span class="cov0" title="0">{
                return cachedMediaInfo
        }</span>

        // 使用FFprobe获取媒体信息
        <span class="cov0" title="0">args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_format",
                "-show_streams",
                filePath,
        }

        cmd := exec.Command(c.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Format struct {
                        Duration string `json:"duration"`
                        BitRate  string `json:"bit_rate"`
                } `json:"format"`
                Streams []struct {
                        CodecName  string `json:"codec_name"`
                        CodecType  string `json:"codec_type"`
                        Width      int    `json:"width"`
                        Height     int    `json:"height"`
                        RFrameRate string `json:"r_frame_rate"`
                        ColorSpace string `json:"color_space"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mediaInfo := &amp;MediaInfo{}

        // 填充基本文件信息
        mediaInfo.FullPath = filePath

        // 获取文件信息
        if fileInfo, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                mediaInfo.FileSize = fileInfo.Size()
                mediaInfo.ModTime = fileInfo.ModTime()
        }</span>

        // 解析格式信息
        <span class="cov0" title="0">if probeData.Format.Duration != "" </span><span class="cov0" title="0">{
                if duration, err := strconv.ParseFloat(probeData.Format.Duration, 64); err == nil </span><span class="cov0" title="0">{
                        mediaInfo.Duration = duration
                }</span>
        }

        <span class="cov0" title="0">if probeData.Format.BitRate != "" </span><span class="cov0" title="0">{
                if bitrate, err := strconv.Atoi(probeData.Format.BitRate); err == nil </span><span class="cov0" title="0">{
                        mediaInfo.Bitrate = bitrate
                }</span>
        }

        // 解析流信息
        <span class="cov0" title="0">for _, stream := range probeData.Streams </span><span class="cov0" title="0">{
                switch stream.CodecType </span>{
                case "video":<span class="cov0" title="0">
                        mediaInfo.Width = stream.Width
                        mediaInfo.Height = stream.Height
                        mediaInfo.Codec = stream.CodecName
                        mediaInfo.ColorSpace = stream.ColorSpace

                        // 解析帧率
                        if stream.RFrameRate != "" &amp;&amp; strings.Contains(stream.RFrameRate, "/") </span><span class="cov0" title="0">{
                                parts := strings.Split(stream.RFrameRate, "/")
                                if len(parts) == 2 </span><span class="cov0" title="0">{
                                        if num, err := strconv.ParseFloat(parts[0], 64); err == nil </span><span class="cov0" title="0">{
                                                if den, err := strconv.ParseFloat(parts[1], 64); err == nil &amp;&amp; den &gt; 0 </span><span class="cov0" title="0">{
                                                        mediaInfo.FrameRate = num / den
                                                }</span>
                                        }
                                }
                        }

                case "audio":<span class="cov0" title="0">
                        mediaInfo.HasAudio = true</span>
                }
        }

        // 将获取到的媒体信息放入内存池
        <span class="cov0" title="0">c.memoryPool.PutMediaInfo(mediaInfo)

        return mediaInfo</span>
}

// getSystemInfo 获取系统信息
func (c *Converter) getSystemInfo() SystemInfo <span class="cov0" title="0">{
        return SystemInfo{
                OS:          "darwin", // 简化版本
                Arch:        "arm64",
                CPUCores:    c.config.Concurrency.ScanWorkers,
                Concurrency: c.config.Concurrency.ConversionWorkers,
                MemoryUsed:  0, // 可以通过gopsutil获取
        }
}</span>

// collectErrors 收集错误信息
func (c *Converter) collectErrors() []ConversionError <span class="cov0" title="0">{
        var errors []ConversionError

        for _, result := range c.results </span><span class="cov0" title="0">{
                if !result.Success &amp;&amp; result.Error != nil </span><span class="cov0" title="0">{
                        errors = append(errors, ConversionError{
                                File:  result.OriginalFile.Path,
                                Error: result.Error.Error(),
                                Time:  time.Now(), // 简化版本
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// ensureReportsDir 确保reports目录结构存在
func (c *Converter) ensureReportsDir() error <span class="cov0" title="0">{
        // 创建主reports目录
        if err := os.MkdirAll("reports", 0755); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("创建reports目录失败", err)
        }</span>

        // 创建子目录
        <span class="cov0" title="0">subDirs := []string{"conversion", "analysis", "test", "archive"}
        for _, subDir := range subDirs </span><span class="cov0" title="0">{
                path, err := GlobalPathUtils.JoinPath("reports", subDir)
                if err != nil </span><span class="cov0" title="0">{
                        var errBuilder strings.Builder
                errBuilder.WriteString("构建reports子目录路径失败 ")
                errBuilder.WriteString(subDir)
                return c.errorHandler.WrapError(errBuilder.String(), err)
                }</span>
                <span class="cov0" title="0">if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                        var errBuilder strings.Builder
                errBuilder.WriteString("创建reports子目录失败 ")
                errBuilder.WriteString(subDir)
                return c.errorHandler.WrapError(errBuilder.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// saveJSONReport 保存JSON格式报告
func (c *Converter) saveJSONReport(report DetailedReport) error <span class="cov0" title="0">{
        // 确保目录存在
        if err := c.ensureReportsDir(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("20060102_150405")
        var filenameBuilder strings.Builder
        filenameBuilder.WriteString("pixly_detailed_report_")
        filenameBuilder.WriteString(timestamp)
        filenameBuilder.WriteString(".json")
        filename, err := GlobalPathUtils.JoinPath("reports", "conversion", filenameBuilder.String())
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("构建报告文件路径失败", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("序列化报告失败", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("保存JSON报告失败", err)
        }</span>

        // JSON报告已保存
        <span class="cov0" title="0">return nil</span>
}

// generateReadableReport 生成可读报告
func (c *Converter) generateReadableReport(report DetailedReport) error <span class="cov0" title="0">{
        // 确保目录存在
        if err := c.ensureReportsDir(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("20060102_150405")
        var filenameBuilder strings.Builder
        filenameBuilder.WriteString("pixly_report_")
        filenameBuilder.WriteString(timestamp)
        filenameBuilder.WriteString(".txt")
        filename, err := GlobalPathUtils.JoinPath("reports", "conversion", filenameBuilder.String())
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("构建报告文件路径失败", err)
        }</span>

        <span class="cov0" title="0">file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("创建报告文件失败", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("关闭报告文件失败", zap.Error(err))
                }</span>
        }()

        // 写入报告头部
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "=== Pixly 媒体转换详细报告 ===\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("写入报告头部失败", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "生成时间: %s\n", report.EndTime.Format("2006-01-02 15:04:05")); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("写入生成时间失败", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "转换模式: %s\n", report.ConversionMode); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("写入转换模式失败", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "源目录: %s\n", report.SourceDirectory); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("写入源目录失败", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "处理时长: %v\n", report.Duration); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write duration to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write newline to report", err)
        }</span>

        // 写入统计信息
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "=== 转换统计 ===\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write statistics header to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "总文件数: %d\n", report.TotalFiles); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write total files to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "处理文件数: %d\n", report.ProcessedFiles); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write processed files to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "成功转换: %d\n", report.SuccessfulFiles); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write successful files to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "转换失败: %d\n", report.FailedFiles); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write failed files to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "跳过文件: %d\n", report.SkippedFiles); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write skipped files to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "总压缩率: %.2f%%\n", report.CompressionRatio); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write compression ratio to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "节省空间: %.2f MB\n", float64(report.SpaceSaved)/(1024*1024)); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write space saved to report", err)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write newline to report", err)
        }</span>

        // 写入格式统计
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "=== 格式统计 ===\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write format statistics header to report", err)
        }</span>
        <span class="cov0" title="0">for format, stats := range report.FormatSummary </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "%s: %d个文件, 平均压缩率: %.2f%%\n",
                        format, stats.Count, stats.AverageCompression); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write format statistics to report", err)
                }</span>
        }
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write newline to report", err)
        }</span>

        // 写入文件详情（限制前20个）
        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "=== 文件转换详情 (前20个) ===\n"); err != nil </span><span class="cov0" title="0">{
                return c.errorHandler.WrapError("write file details header to report", err)
        }</span>
        <span class="cov0" title="0">for i, detail := range report.FileDetails </span><span class="cov0" title="0">{
                if i &gt;= 20 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">status := "✅ 成功"
                if !detail.Success </span><span class="cov0" title="0">{
                        status = "❌ 失败"
                }</span>

                <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "%s - %s\n", status, GlobalPathUtils.GetBaseName(detail.OriginalPath)); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write file status to report", err)
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "  原始大小: %.2f MB\n", float64(detail.OriginalSize)/(1024*1024)); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write original size to report", err)
                }</span>
                <span class="cov0" title="0">if detail.Success </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(file, "  输出大小: %.2f MB\n", float64(detail.OutputSize)/(1024*1024)); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write output size to report", err)
                        }</span>
                        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "  压缩率: %.2f%%\n", detail.CompressionRatio); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write compression ratio to report", err)
                        }</span>
                        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "  格式: %s → %s\n", detail.OriginalFormat, detail.OutputFormat); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write format conversion to report", err)
                        }</span>

                        <span class="cov0" title="0">if detail.MediaInfo != nil </span><span class="cov0" title="0">{
                                if detail.MediaInfo.Width &gt; 0 </span><span class="cov0" title="0">{
                                        if _, err := fmt.Fprintf(file, "  分辨率: %dx%d\n", detail.MediaInfo.Width, detail.MediaInfo.Height); err != nil </span><span class="cov0" title="0">{
                                                return c.errorHandler.WrapError("write resolution to report", err)
                                        }</span>
                                }
                                <span class="cov0" title="0">if detail.MediaInfo.Duration &gt; 0 </span><span class="cov0" title="0">{
                                        if _, err := fmt.Fprintf(file, "  时长: %.2f秒\n", detail.MediaInfo.Duration); err != nil </span><span class="cov0" title="0">{
                                                return c.errorHandler.WrapError("write duration to report", err)
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        if _, err := fmt.Fprintf(file, "  错误: %s\n", detail.Error); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write error to report", err)
                        }</span>
                }
                <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "  处理时间: %v\n", detail.ProcessingTime); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write processing time to report", err)
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "\n"); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write newline to report", err)
                }</span>
        }

        // 写入错误信息
        <span class="cov0" title="0">if len(report.Errors) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "=== 错误详情 ===\n"); err != nil </span><span class="cov0" title="0">{
                        return c.errorHandler.WrapError("write errors header to report", err)
                }</span>
                <span class="cov0" title="0">for _, errDetail := range report.Errors </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(file, "文件: %s\n", errDetail.File); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write error file to report", err)
                        }</span>
                        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "错误: %s\n", errDetail.Error); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write error message to report", err)
                        }</span>
                        <span class="cov0" title="0">if _, err := fmt.Fprintf(file, "\n"); err != nil </span><span class="cov0" title="0">{
                                return c.errorHandler.WrapError("write error newline to report", err)
                        }</span>
                }
        }

        // 可读报告已保存
        <span class="cov0" title="0">return nil</span>
}

// verifyConversionResults 验证转换结果
func (c *Converter) verifyConversionResults() error <span class="cov0" title="0">{
        // 验证转换结果

        var verificationErrors []string

        for _, result := range c.results </span><span class="cov0" title="0">{
                if !result.Success </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 确定实际需要验证的文件路径
                <span class="cov0" title="0">var actualPath string

                // 检查是否为原地转换
                isInPlace := c.config.Output.DirectoryTemplate == ""

                if isInPlace </span><span class="cov0" title="0">{
                        // 原地转换：验证输出路径（原文件已被删除并重命名为新扩展名）
                        actualPath = result.OutputPath
                        // 原地转换验证
                }</span> else<span class="cov0" title="0"> {
                        // 指定目录转换：验证输出路径
                        actualPath = result.OutputPath
                        // 指定目录转换验证
                }</span>

                // 检查实际文件是否存在
                <span class="cov0" title="0">if _, err := os.Stat(actualPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        var errBuilder strings.Builder
                        errBuilder.WriteString("输出文件不存在: ")
                        errBuilder.WriteString(actualPath)
                        verificationErrors = append(verificationErrors, errBuilder.String())
                        continue</span>
                }

                // 检查文件大小是否合理
                <span class="cov0" title="0">if result.CompressedSize &lt;= 0 </span><span class="cov0" title="0">{
                        var errBuilder strings.Builder
                        errBuilder.WriteString("输出文件大小异常: ")
                        errBuilder.WriteString(actualPath)
                        errBuilder.WriteString(" (大小: ")
                        errBuilder.WriteString(strconv.FormatInt(result.CompressedSize, 10))
                        errBuilder.WriteString(")")
                        verificationErrors = append(verificationErrors, errBuilder.String())
                }</span>
        }

        <span class="cov0" title="0">if len(verificationErrors) &gt; 0 </span><span class="cov0" title="0">{
                c.logger.Warn("发现验证错误", zap.Strings("errors", verificationErrors))
                var errBuilder strings.Builder
                errBuilder.WriteString("发现 ")
                errBuilder.WriteString(strconv.Itoa(len(verificationErrors)))
                errBuilder.WriteString(" 个验证错误")
                return c.errorHandler.WrapError(errBuilder.String(), nil)
        }</span>

        // 转换结果验证通过
        <span class="cov0" title="0">return nil</span>
}

// getSourceDirectory 获取源目录
func (c *Converter) getSourceDirectory() string <span class="cov0" title="0">{
        // 简化版本，从第一个结果获取目录
        if len(c.results) &gt; 0 </span><span class="cov0" title="0">{
                return GlobalPathUtils.GetDirName(c.results[0].OriginalFile.Path)
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package converter

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "go.uber.org/zap"
)

// SignalHandlerConfig 信号处理器配置 - 使用现代化配置结构
type SignalHandlerConfig struct {
        MaxInterrupts int
        BufferSize    int
        Timeout       time.Duration
        Signals       []os.Signal
}

// DefaultSignalHandlerConfig 返回默认配置
func DefaultSignalHandlerConfig() SignalHandlerConfig <span class="cov8" title="1">{
        return SignalHandlerConfig{
                MaxInterrupts: 2,
                BufferSize:    1,
                Timeout:       30 * time.Second,
                Signals:       []os.Signal{syscall.SIGINT, syscall.SIGTERM},
        }
}</span>

// SignalHandler 信号处理器 - 强制中断处理
type SignalHandler struct {
        logger   *zap.Logger
        ctx      context.Context
        cancel   context.CancelFunc
        sigChan  chan os.Signal
        shutdown chan struct{}
        mutex    sync.RWMutex

        // 状态管理
        isShuttingDown bool
        converter      *Converter
        checkpoint     *CheckpointManager

        // 配置
        config SignalHandlerConfig

        // 强制中断计数
        interruptCount int
}

// NewSignalHandler 创建新的信号处理器
func NewSignalHandler(logger *zap.Logger, converter *Converter, checkpoint *CheckpointManager) *SignalHandler <span class="cov8" title="1">{
        return NewSignalHandlerWithConfig(logger, converter, checkpoint, DefaultSignalHandlerConfig())
}</span>

// NewSignalHandlerWithConfig 使用配置创建信号处理器
func NewSignalHandlerWithConfig(logger *zap.Logger, converter *Converter, checkpoint *CheckpointManager, config SignalHandlerConfig) *SignalHandler <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;SignalHandler{
                logger:         logger,
                ctx:            ctx,
                cancel:         cancel,
                sigChan:        make(chan os.Signal, config.BufferSize),
                shutdown:       make(chan struct{}),
                converter:      converter,
                checkpoint:     checkpoint,
                config:         config,
                interruptCount: 0,
        }
}</span>

// Start 启动信号监听
func (sh *SignalHandler) Start() <span class="cov0" title="0">{
        // 注册信号监听
        signal.Notify(sh.sigChan, syscall.SIGINT, syscall.SIGTERM)

        // 启动信号处理goroutine
        go sh.handleSignals()

        // 信号处理器已启动
}</span>

// Stop 停止信号处理器
func (sh *SignalHandler) Stop() <span class="cov8" title="1">{
        sh.mutex.Lock()
        defer sh.mutex.Unlock()

        if sh.isShuttingDown </span><span class="cov0" title="0">{
                return // 已经停止，避免重复关闭
        }</span>

        <span class="cov8" title="1">sh.isShuttingDown = true
        signal.Stop(sh.sigChan)
        close(sh.sigChan)
        sh.cancel()</span>

        // 信号处理器已停止
}

// handleSignals 处理信号
func (sh *SignalHandler) handleSignals() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case sig := &lt;-sh.sigChan:<span class="cov0" title="0">
                        if sig == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // 收到中断信号

                        // 处理中断
                        <span class="cov0" title="0">sh.handleInterrupt(sig)</span>

                case &lt;-sh.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// handleInterrupt 处理中断信号 - 强制中断
func (sh *SignalHandler) handleInterrupt(sig os.Signal) <span class="cov0" title="0">{
        sh.mutex.Lock()
        defer sh.mutex.Unlock()

        sh.interruptCount++
        // 收到中断信号

        // 检查是否超过最大中断次数
        if sh.interruptCount &gt;= sh.config.MaxInterrupts </span><span class="cov0" title="0">{
                sh.logger.Warn("达到最大中断次数，强制退出程序")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if sh.isShuttingDown </span><span class="cov0" title="0">{
                sh.logger.Warn("程序正在关闭中，再次中断将强制退出")
                return
        }</span>

        <span class="cov0" title="0">sh.isShuttingDown = true

        // 保存当前状态到断点续传系统
        if sh.checkpoint != nil </span><span class="cov0" title="0">{
                if err := sh.checkpoint.SaveCurrentState(); err != nil </span><span class="cov0" title="0">{
                        sh.logger.Error("保存断点状态失败", zap.Error(err))
                }</span> else <span class="cov0" title="0">{
                        // 断点状态已保存
                }</span>
        }

        // 立即停止转换器
        <span class="cov0" title="0">if sh.converter != nil </span><span class="cov0" title="0">{
                sh.converter.RequestStop()
        }</span>

        // 取消上下文，通知所有goroutine退出
        <span class="cov0" title="0">sh.cancel()

        // 显示中断后的选项菜单
        sh.showInterruptMenu()</span>
}

// showInterruptMenu 显示中断信息并立即退出
func (sh *SignalHandler) showInterruptMenu() <span class="cov0" title="0">{
        // 显示中断信息
        // 程序已中断，状态已保存
        // 可以使用相同命令恢复转换进度

        // 立即退出，不等待用户输入
        os.Exit(0)
}</span>

// IsShuttingDown 检查是否正在关闭
func (sh *SignalHandler) IsShuttingDown() bool <span class="cov0" title="0">{
        sh.mutex.RLock()
        defer sh.mutex.RUnlock()
        return sh.isShuttingDown
}</span>

// GetContext 获取上下文
func (sh *SignalHandler) GetContext() context.Context <span class="cov0" title="0">{
        return sh.ctx
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package converter

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "go.uber.org/zap"
)

// ConversionStrategy 转换策略接口
type ConversionStrategy interface {
        ConvertImage(file *MediaFile) (string, error)
        ConvertVideo(file *MediaFile) (string, error)
        GetName() string
}

// AutoPlusStrategy 自动模式+策略（智能决策核心）
type AutoPlusStrategy struct {
        converter    *Converter
        errorHandler *ErrorHandler
}

// QualityStrategy 品质模式策略
type QualityStrategy struct {
        converter    *Converter
        errorHandler *ErrorHandler
}

// EmojiStrategy 表情包模式策略
type EmojiStrategy struct {
        converter    *Converter
        errorHandler *ErrorHandler
}

// NewStrategy 创建策略实例
func NewStrategy(mode ConversionMode, conv *Converter) ConversionStrategy <span class="cov8" title="1">{
        switch mode </span>{
        case ModeAutoPlus:<span class="cov8" title="1">
                return &amp;AutoPlusStrategy{converter: conv, errorHandler: conv.errorHandler}</span>
        case ModeQuality:<span class="cov8" title="1">
                return &amp;QualityStrategy{converter: conv, errorHandler: conv.errorHandler}</span>
        case ModeEmoji:<span class="cov8" title="1">
                return &amp;EmojiStrategy{converter: conv, errorHandler: conv.errorHandler}</span>
        default:<span class="cov0" title="0">
                return &amp;AutoPlusStrategy{converter: conv, errorHandler: conv.errorHandler}</span>
        }
}

// === 自动模式+ 实现 ===

func (s *AutoPlusStrategy) GetName() string <span class="cov8" title="1">{
        return "auto+ (智能决策)"
}</span>

func (s *AutoPlusStrategy) ConvertImage(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 0. 优先检测无损JPEG/PNG - 新增功能
        if s.isLosslessFormat(file) </span><span class="cov0" title="0">{
                // 检测到无损格式，优先使用质量模式
                return s.applyQualityModeLogic(file)
        }</span>

        // 1. 品质分类体系
        <span class="cov0" title="0">quality := s.analyzeImageQuality(file)

        switch quality </span>{
        case "极高", "高品质", "原画":<span class="cov0" title="0">
                // 路由至品质模式的无损压缩逻辑
                return s.applyQualityModeLogic(file)</span>

        case "中高", "中低", "中等":<span class="cov0" title="0">
                // 平衡优化逻辑
                return s.applyBalancedOptimization(file)</span>

        case "极低", "低品质":<span class="cov0" title="0">
                // 根据最新README规范，移除低质量文件跳过功能
                // 直接应用平衡优化逻辑
                return s.applyBalancedOptimization(file)</span>

        default:<span class="cov0" title="0">
                return s.applyBalancedOptimization(file)</span>
        }
}

func (s *AutoPlusStrategy) ConvertVideo(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 视频转换逻辑，主要是容器转换
        return s.converter.convertVideoContainer(file)
}</span>

// ConvertAudio方法已删除 - 根据README要求，本程序不处理音频文件

// ImageQualityMetrics 图像质量度量
type ImageQualityMetrics struct {
        Complexity           float64 // 图像复杂度 (0-1)
        NoiseLevel           float64 // 噪声水平 (0-1)
        CompressionPotential float64 // 压缩潜力 (0-1)
        ContentType          string  // 内容类型: photo, graphic, mixed
        QualityScore         float64 // 综合质量分数 (0-100)
}

// analyzeImageQuality 智能图像质量分析
func (s *AutoPlusStrategy) analyzeImageQuality(file *MediaFile) string <span class="cov8" title="1">{
        metrics := s.analyzeImageMetrics(file)

        // 基于综合质量分数进行分类
        if metrics.QualityScore &gt;= 85 </span><span class="cov8" title="1">{
                return "原画"
        }</span> else<span class="cov0" title="0"> if metrics.QualityScore &gt;= 75 </span><span class="cov0" title="0">{
                return "高品质"
        }</span> else<span class="cov0" title="0"> if metrics.QualityScore &gt;= 60 </span><span class="cov0" title="0">{
                return "中等"
        }</span> else<span class="cov0" title="0"> if metrics.QualityScore &gt;= 40 </span><span class="cov0" title="0">{
                return "中低"
        }</span> else<span class="cov0" title="0"> {
                return "低品质"
        }</span>
}

// isLosslessFormat 检测是否为无损JPEG/PNG格式
func (s *AutoPlusStrategy) isLosslessFormat(file *MediaFile) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(file.Path))

        // 只检测JPEG和PNG格式
        if ext != ".jpg" &amp;&amp; ext != ".jpeg" &amp;&amp; ext != ".png" </span><span class="cov0" title="0">{
                return false
        }</span>

        // 获取图像度量指标
        <span class="cov0" title="0">metrics := s.analyzeImageMetrics(file)

        // 无损判定条件：
        // 1. PNG格式且像素格式为rgba/rgb24（无损格式）
        // 2. JPEG格式且像素格式为yuv444p（无损JPEG）
        // 3. 噪声水平极低（&lt;= 0.1）
        // 4. 质量分数很高（&gt;= 90）
        if ext == ".png" </span><span class="cov0" title="0">{
                // PNG本身就是无损格式，但要排除过度压缩的情况
                return metrics.NoiseLevel &lt;= 0.1 &amp;&amp; metrics.QualityScore &gt;= 85
        }</span>

        <span class="cov0" title="0">if ext == ".jpg" || ext == ".jpeg" </span><span class="cov0" title="0">{
                // JPEG无损检测：yuv444p像素格式 + 高质量分数 + 低噪声
                return metrics.NoiseLevel &lt;= 0.1 &amp;&amp; metrics.QualityScore &gt;= 95
        }</span>

        <span class="cov0" title="0">return false</span>
}

// analyzeImageMetrics 分析图像度量指标
func (s *AutoPlusStrategy) analyzeImageMetrics(file *MediaFile) ImageQualityMetrics <span class="cov8" title="1">{
        ext := strings.ToLower(file.Extension)
        sizeInMB := float64(file.Size) / (1024 * 1024)

        // 获取图像基本信息
        width, height := s.getImageDimensions(file)
        pixelCount := float64(width * height)

        // 计算像素密度 (MB per megapixel)
        pixelDensity := sizeInMB / (pixelCount / 1000000)

        var metrics ImageQualityMetrics

        // 基于格式特性分析
        switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov8" title="1">
                metrics = s.analyzeJPEGQuality(file, pixelDensity, sizeInMB)</span>
        case ".png":<span class="cov0" title="0">
                metrics = s.analyzePNGQuality(file, pixelDensity)</span>
        case ".gif":<span class="cov0" title="0">
                metrics = s.analyzeGIFQuality(sizeInMB)</span>
        case ".webp":<span class="cov0" title="0">
                metrics = s.analyzeWebPQuality(file, pixelDensity, sizeInMB)</span>
        default:<span class="cov0" title="0">
                metrics = s.analyzeGenericQuality(sizeInMB)</span>
        }

        <span class="cov8" title="1">return metrics</span>
}

// getImageDimensions 获取图像尺寸
func (s *AutoPlusStrategy) getImageDimensions(file *MediaFile) (int, int) <span class="cov8" title="1">{
        // 通过FFprobe获取图像尺寸
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_streams",
                file.Path,
        }

        cmd := exec.Command(s.converter.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                // 如果FFprobe失败，返回默认值
                return 1920, 1080
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Streams []struct {
                        Width  int `json:"width"`
                        Height int `json:"height"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil || len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                return 1920, 1080
        }</span>

        // 安全访问第一个流的尺寸信息
        <span class="cov0" title="0">if len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                s.converter.logger.Warn("No streams found for dimension analysis, using default dimensions",
                        zap.String("file", file.Path))
                return 1920, 1080
        }</span>
        <span class="cov0" title="0">return probeData.Streams[0].Width, probeData.Streams[0].Height</span>
}

// analyzeJPEGQuality 分析JPEG质量
func (s *AutoPlusStrategy) analyzeJPEGQuality(file *MediaFile, pixelDensity, sizeInMB float64) ImageQualityMetrics <span class="cov8" title="1">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "photo"

        // 使用FFprobe获取JPEG详细信息
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_streams",
                "-show_format",
                file.Path,
        }

        cmd := exec.Command(s.converter.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                // 回退到基础分析
                return s.fallbackJPEGAnalysis(pixelDensity, sizeInMB)
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Streams []struct {
                        Width      int    `json:"width"`
                        Height     int    `json:"height"`
                        PixFmt     string `json:"pix_fmt"`
                        BitRate    string `json:"bit_rate"`
                        ColorSpace string `json:"color_space"`
                } `json:"streams"`
                Format struct {
                        BitRate string `json:"bit_rate"`
                        Size    string `json:"size"`
                } `json:"format"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil || len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                return s.fallbackJPEGAnalysis(pixelDensity, sizeInMB)
        }</span>

        // 安全访问第一个流
        <span class="cov0" title="0">if len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                s.converter.logger.Warn("No streams found in probe data, using fallback analysis",
                        zap.String("file", file.Path))
                return s.fallbackJPEGAnalysis(pixelDensity, sizeInMB)
        }</span>
        <span class="cov0" title="0">stream := probeData.Streams[0]

        // 基于像素格式分析质量
        switch stream.PixFmt </span>{
        case "yuv444p", "yuvj444p":<span class="cov0" title="0">
                metrics.QualityScore = 98 // 4:4:4采样，接近无损质量
                metrics.Complexity = 0.9
                metrics.NoiseLevel = 0.05</span> // 极低噪声，接近无损
        case "yuv422p", "yuvj422p":<span class="cov0" title="0">
                metrics.QualityScore = 80 // 4:2:2采样，高质量
                metrics.Complexity = 0.7
                metrics.NoiseLevel = 0.15</span>
        case "yuv420p", "yuvj420p":<span class="cov0" title="0">
                metrics.QualityScore = 65 // 4:2:0采样，标准质量
                metrics.Complexity = 0.6
                metrics.NoiseLevel = 0.25</span>
        default:<span class="cov0" title="0">
                metrics.QualityScore = 50
                metrics.Complexity = 0.5
                metrics.NoiseLevel = 0.35</span>
        }

        // 基于像素密度调整
        <span class="cov0" title="0">if pixelDensity &gt; 1.0 </span><span class="cov0" title="0">{
                metrics.QualityScore += 10
        }</span> else<span class="cov0" title="0"> if pixelDensity &lt; 0.3 </span><span class="cov0" title="0">{
                metrics.QualityScore -= 15
        }</span>

        // 限制范围
        <span class="cov0" title="0">if metrics.QualityScore &gt; 100 </span><span class="cov0" title="0">{
                metrics.QualityScore = 100
        }</span> else<span class="cov0" title="0"> if metrics.QualityScore &lt; 20 </span><span class="cov0" title="0">{
                metrics.QualityScore = 20
        }</span>

        // JPEG压缩潜力分析
        <span class="cov0" title="0">if metrics.QualityScore &gt; 80 </span><span class="cov0" title="0">{
                metrics.CompressionPotential = 0.2 // 高质量JPEG压缩潜力有限
        }</span> else<span class="cov0" title="0"> if metrics.QualityScore &gt; 60 </span><span class="cov0" title="0">{
                metrics.CompressionPotential = 0.4
        }</span> else<span class="cov0" title="0"> {
                metrics.CompressionPotential = 0.6 // 低质量JPEG有较大压缩空间
        }</span>

        // 如果之前没有设置噪声水平，则进行估算
        <span class="cov0" title="0">if metrics.NoiseLevel == 0 </span><span class="cov0" title="0">{
                metrics.NoiseLevel = (100 - metrics.QualityScore) / 200.0
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// fallbackJPEGAnalysis JPEG分析回退方案
func (s *AutoPlusStrategy) fallbackJPEGAnalysis(pixelDensity, sizeInMB float64) ImageQualityMetrics <span class="cov8" title="1">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "photo"
        metrics.CompressionPotential = 0.3

        // 根据文件大小和像素密度综合判断质量
        // 大文件（&gt;= 2MB）通常表示高质量原图
        if sizeInMB &gt;= 2.0 &amp;&amp; pixelDensity &gt; 0.8 </span><span class="cov8" title="1">{
                metrics.QualityScore = 90 // 原画级别
                metrics.NoiseLevel = 0.1
                metrics.Complexity = 0.8
        }</span> else<span class="cov0" title="0"> if pixelDensity &gt; 0.8 </span><span class="cov0" title="0">{
                metrics.QualityScore = 80 // 高品质
                metrics.NoiseLevel = 0.2
                metrics.Complexity = 0.7
        }</span> else<span class="cov0" title="0"> if pixelDensity &gt; 0.4 </span><span class="cov0" title="0">{
                metrics.QualityScore = 60
                metrics.NoiseLevel = 0.4
                metrics.Complexity = 0.5
        }</span> else<span class="cov0" title="0"> {
                metrics.QualityScore = 45
                metrics.NoiseLevel = 0.6
                metrics.Complexity = 0.4
        }</span>

        <span class="cov8" title="1">return metrics</span>
}

// analyzePNGQuality 分析PNG质量
func (s *AutoPlusStrategy) analyzePNGQuality(file *MediaFile, pixelDensity float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "graphic"
        metrics.NoiseLevel = 0.0 // PNG无损格式无噪声

        // 使用FFprobe获取PNG详细信息
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_streams",
                file.Path,
        }

        cmd := exec.Command(s.converter.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return s.fallbackPNGAnalysis(pixelDensity)
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Streams []struct {
                        Width            int    `json:"width"`
                        Height           int    `json:"height"`
                        PixFmt           string `json:"pix_fmt"`
                        BitsPerRawSample string `json:"bits_per_raw_sample"`
                        ColorSpace       string `json:"color_space"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil || len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                return s.fallbackPNGAnalysis(pixelDensity)
        }</span>

        // 安全访问第一个流
        <span class="cov0" title="0">if len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                s.converter.logger.Warn("No streams found in PNG probe data, using fallback analysis",
                        zap.String("file", file.Path))
                return s.fallbackPNGAnalysis(pixelDensity)
        }</span>
        <span class="cov0" title="0">stream := probeData.Streams[0]

        // 基于像素格式和位深度分析质量
        switch stream.PixFmt </span>{
        case "rgba", "rgba64be", "rgba64le":<span class="cov0" title="0">
                metrics.QualityScore = 100 // RGBA，最高质量
                metrics.Complexity = 0.9
                metrics.CompressionPotential = 0.8</span> // 透明通道压缩潜力大
        case "rgb24", "rgb48be", "rgb48le":<span class="cov0" title="0">
                metrics.QualityScore = 95 // RGB真彩色
                metrics.Complexity = 0.8
                metrics.CompressionPotential = 0.7</span>
        case "pal8":<span class="cov0" title="0">
                metrics.QualityScore = 70 // 调色板模式
                metrics.Complexity = 0.5
                metrics.CompressionPotential = 0.9</span> // 调色板PNG压缩潜力很大
        case "gray", "gray16be", "gray16le":<span class="cov0" title="0">
                metrics.QualityScore = 85 // 灰度图
                metrics.Complexity = 0.6
                metrics.CompressionPotential = 0.8</span>
        default:<span class="cov0" title="0">
                metrics.QualityScore = 80
                metrics.Complexity = 0.7
                metrics.CompressionPotential = 0.7</span>
        }

        // 基于位深度调整
        <span class="cov0" title="0">if stream.BitsPerRawSample == "16" </span><span class="cov0" title="0">{
                metrics.QualityScore += 5 // 16位深度加分
                metrics.CompressionPotential += 0.1
        }</span>

        // 基于像素密度调整复杂度
        <span class="cov0" title="0">if pixelDensity &gt; 3.0 </span><span class="cov0" title="0">{
                metrics.Complexity += 0.1
                metrics.CompressionPotential -= 0.1 // 高密度图像压缩潜力稍低
        }</span> else<span class="cov0" title="0"> if pixelDensity &lt; 0.5 </span><span class="cov0" title="0">{
                metrics.CompressionPotential += 0.1 // 低密度图像压缩潜力更大
        }</span>

        // 限制范围
        <span class="cov0" title="0">if metrics.QualityScore &gt; 100 </span><span class="cov0" title="0">{
                metrics.QualityScore = 100
        }</span>
        <span class="cov0" title="0">if metrics.Complexity &gt; 1.0 </span><span class="cov0" title="0">{
                metrics.Complexity = 1.0
        }</span>
        <span class="cov0" title="0">if metrics.CompressionPotential &gt; 1.0 </span><span class="cov0" title="0">{
                metrics.CompressionPotential = 1.0
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// fallbackPNGAnalysis PNG分析回退方案
func (s *AutoPlusStrategy) fallbackPNGAnalysis(pixelDensity float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "graphic"
        metrics.NoiseLevel = 0.0
        metrics.CompressionPotential = 0.7

        if pixelDensity &gt; 2.0 </span><span class="cov0" title="0">{
                metrics.QualityScore = 90
                metrics.Complexity = 0.8
        }</span> else<span class="cov0" title="0"> if pixelDensity &gt; 0.5 </span><span class="cov0" title="0">{
                metrics.QualityScore = 75
                metrics.Complexity = 0.6
        }</span> else<span class="cov0" title="0"> {
                metrics.QualityScore = 60
                metrics.Complexity = 0.5
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// analyzeGIFQuality 分析GIF质量
func (s *AutoPlusStrategy) analyzeGIFQuality(sizeInMB float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "animation"

        // GIF格式限制，质量通常较低
        metrics.CompressionPotential = 0.8 // 高压缩潜力
        metrics.NoiseLevel = 0.4           // 抖动噪声

        // GIF质量评估
        if sizeInMB &gt; 10 </span><span class="cov0" title="0">{
                metrics.QualityScore = 30 // 大GIF通常质量差
                metrics.Complexity = 0.3
        }</span> else<span class="cov0" title="0"> if sizeInMB &gt; 2 </span><span class="cov0" title="0">{
                metrics.QualityScore = 50
                metrics.Complexity = 0.5
        }</span> else<span class="cov0" title="0"> {
                metrics.QualityScore = 65
                metrics.Complexity = 0.6
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// analyzeWebPQuality 分析WebP质量
func (s *AutoPlusStrategy) analyzeWebPQuality(file *MediaFile, pixelDensity, sizeInMB float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "mixed"

        // 使用FFprobe获取WebP详细信息
        args := []string{
                "-v", "quiet",
                "-print_format", "json",
                "-show_streams",
                file.Path,
        }

        cmd := exec.Command(s.converter.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return s.fallbackWebPAnalysis(pixelDensity)
        }</span>

        // 解析FFprobe输出
        <span class="cov0" title="0">var probeData struct {
                Streams []struct {
                        Width      int    `json:"width"`
                        Height     int    `json:"height"`
                        PixFmt     string `json:"pix_fmt"`
                        CodecName  string `json:"codec_name"`
                        ColorSpace string `json:"color_space"`
                } `json:"streams"`
        }

        if err := json.Unmarshal(output, &amp;probeData); err != nil || len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                return s.fallbackWebPAnalysis(pixelDensity)
        }</span>

        // 安全访问第一个流
        <span class="cov0" title="0">if len(probeData.Streams) == 0 </span><span class="cov0" title="0">{
                s.converter.logger.Warn("No streams found in WebP probe data, using fallback analysis",
                        zap.String("file", file.Path))
                return s.fallbackWebPAnalysis(pixelDensity)
        }</span>
        <span class="cov0" title="0">stream := probeData.Streams[0]

        // 基于像素格式判断质量
        switch stream.PixFmt </span>{
        case "yuv420p", "yuv422p", "yuv444p":<span class="cov0" title="0">
                // 有损WebP
                if pixelDensity &gt; 0.8 </span><span class="cov0" title="0">{
                        metrics.QualityScore = 85
                        metrics.NoiseLevel = 0.15
                        metrics.Complexity = 0.8
                }</span> else<span class="cov0" title="0"> if pixelDensity &gt; 0.5 </span><span class="cov0" title="0">{
                        metrics.QualityScore = 70
                        metrics.NoiseLevel = 0.25
                        metrics.Complexity = 0.6
                }</span> else<span class="cov0" title="0"> {
                        metrics.QualityScore = 55
                        metrics.NoiseLevel = 0.35
                        metrics.Complexity = 0.5
                }</span>
                <span class="cov0" title="0">metrics.CompressionPotential = 0.3</span>
        case "rgba", "rgb24":<span class="cov0" title="0">
                // 无损WebP
                metrics.QualityScore = 95
                metrics.NoiseLevel = 0.05
                metrics.Complexity = 0.9
                metrics.CompressionPotential = 0.6
                metrics.ContentType = "graphic"</span>
        default:<span class="cov0" title="0">
                return s.fallbackWebPAnalysis(pixelDensity)</span>
        }

        // 基于文件大小调整
        <span class="cov0" title="0">if sizeInMB &gt; 10 </span><span class="cov0" title="0">{
                if metrics.QualityScore+10 &gt; 100 </span><span class="cov0" title="0">{
                        metrics.QualityScore = 100
                }</span> else<span class="cov0" title="0"> {
                        metrics.QualityScore += 10
                }</span>
                <span class="cov0" title="0">if metrics.Complexity+0.1 &gt; 1.0 </span><span class="cov0" title="0">{
                        metrics.Complexity = 1.0
                }</span> else<span class="cov0" title="0"> {
                        metrics.Complexity += 0.1
                }</span>
        } else<span class="cov0" title="0"> if sizeInMB &lt; 0.5 </span><span class="cov0" title="0">{
                if metrics.QualityScore-15 &lt; 20 </span><span class="cov0" title="0">{
                        metrics.QualityScore = 20
                }</span> else<span class="cov0" title="0"> {
                        metrics.QualityScore -= 15
                }</span>
                <span class="cov0" title="0">if metrics.NoiseLevel+0.2 &gt; 1.0 </span><span class="cov0" title="0">{
                        metrics.NoiseLevel = 1.0
                }</span> else<span class="cov0" title="0"> {
                        metrics.NoiseLevel += 0.2
                }</span>
        }

        // 基于色彩空间调整
        <span class="cov0" title="0">if stream.ColorSpace == "bt709" || stream.ColorSpace == "bt2020" </span><span class="cov0" title="0">{
                if metrics.QualityScore+5 &gt; 100 </span><span class="cov0" title="0">{
                        metrics.QualityScore = 100
                }</span> else<span class="cov0" title="0"> {
                        metrics.QualityScore += 5
                }</span>
                <span class="cov0" title="0">metrics.ContentType = "photo"</span>
        }

        <span class="cov0" title="0">return metrics</span>
}

func (s *AutoPlusStrategy) fallbackWebPAnalysis(pixelDensity float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "mixed"
        metrics.CompressionPotential = 0.4

        if pixelDensity &gt; 0.6 </span><span class="cov0" title="0">{
                metrics.QualityScore = 75
                metrics.NoiseLevel = 0.2
                metrics.Complexity = 0.7
        }</span> else<span class="cov0" title="0"> if pixelDensity &gt; 0.3 </span><span class="cov0" title="0">{
                metrics.QualityScore = 60
                metrics.NoiseLevel = 0.3
                metrics.Complexity = 0.5
        }</span> else<span class="cov0" title="0"> {
                metrics.QualityScore = 45
                metrics.NoiseLevel = 0.4
                metrics.Complexity = 0.4
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// analyzeGenericQuality 分析通用格式质量
func (s *AutoPlusStrategy) analyzeGenericQuality(sizeInMB float64) ImageQualityMetrics <span class="cov0" title="0">{
        var metrics ImageQualityMetrics
        metrics.ContentType = "mixed"
        metrics.CompressionPotential = 0.6
        metrics.QualityScore = 65 // 中等质量
        metrics.NoiseLevel = 0.3
        metrics.Complexity = 0.5

        return metrics
}</span>

// applyQualityModeLogic 应用品质模式逻辑
func (s *AutoPlusStrategy) applyQualityModeLogic(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 保存原始模式
        originalMode := s.converter.mode

        // 临时切换到品质模式
        s.converter.mode = ModeQuality
        defer func() </span><span class="cov0" title="0">{
                // 恢复原始模式
                s.converter.mode = originalMode
        }</span>()

        <span class="cov0" title="0">qualityStrategy := &amp;QualityStrategy{converter: s.converter}
        return qualityStrategy.ConvertImage(file)</span>
}

// ProbeResult 探测结果结构体
type ProbeResult struct {
        Path    string
        Quality int
        Size    int64
}

// applyBalancedOptimization 平衡优化算法（严格按照README规范实现）
func (s *AutoPlusStrategy) applyBalancedOptimization(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 自动模式+：应用平衡优化算法

        // 步骤 1: 无损重新包装优先 - 无损转换成功就使用，不管体积
        losslessRepackResult, err := s.attemptLosslessRepackaging(file)
        if err == nil &amp;&amp; losslessRepackResult != "" </span><span class="cov0" title="0">{
                // 平衡优化：无损重包成功
                return losslessRepackResult, nil
        }</span>

        // 步骤 2: 数学无损压缩 - 无损转换成功就使用，不管体积
        <span class="cov0" title="0">mathLosslessResult, err := s.attemptMathematicalLossless(file)
        if err == nil &amp;&amp; mathLosslessResult != "" </span><span class="cov0" title="0">{
                // 平衡优化：数学无损压缩成功
                return mathLosslessResult, nil
        }</span>

        // 步骤 3: 有损探测
        <span class="cov0" title="0">probeResults := []ProbeResult{}
        fileQuality := s.getFileQuality(file)

        var qualityTargets []int
        if fileQuality &gt; 70 </span><span class="cov0" title="0">{
                qualityTargets = []int{90, 85, 75}
        }</span> else<span class="cov0" title="0"> {
                qualityTargets = []int{60, 55}
        }</span>

        <span class="cov0" title="0">for _, quality := range qualityTargets </span><span class="cov0" title="0">{
                result, err := s.attemptLossyCompression(file, quality)
                if err == nil &amp;&amp; result != file.Path </span><span class="cov0" title="0">{ // 避免把原文件路径当作探测结果
                        probeResults = append(probeResults, ProbeResult{
                                Path:    result,
                                Quality: quality,
                                Size:    s.getFileSize(result),
                        })
                        // 平衡优化：有损探测成功
                }</span>
        }

        // 步骤 4: 最终决策
        <span class="cov0" title="0">if len(probeResults) == 0 </span><span class="cov0" title="0">{
                // 平衡优化：无优化可能，跳过
                return file.Path, nil // skip(file, "No optimization possible")
        }</span>

        <span class="cov0" title="0">bestResult := s.selectBestProbeResult(probeResults, s.getFileSize(file.Path))
        if bestResult != nil </span><span class="cov0" title="0">{
                // 关键修复：根据最佳结果的实际扩展名确定输出路径
                // bestResult.Path是临时文件，需要根据其扩展名确定最终输出扩展名
                var targetExt string
                if strings.HasSuffix(bestResult.Path, ".avif") </span><span class="cov0" title="0">{
                        targetExt = ".avif"
                }</span> else<span class="cov0" title="0"> {
                        targetExt = ".jxl"
                }</span>

                <span class="cov0" title="0">finalOutputPath := s.converter.getOutputPath(file, targetExt)

                // 确保输出目录存在（统一走文件操作助手）
                if err := s.converter.fileOpHandler.EnsureOutputDirectory(finalOutputPath); err != nil </span><span class="cov0" title="0">{
                        s.converter.logger.Error("平衡优化：创建输出目录失败",
                                zap.String("dir", filepath.Dir(finalOutputPath)),
                                zap.Error(err))
                        // 清理所有临时文件
                        for _, result := range probeResults </span><span class="cov0" title="0">{
                                os.Remove(result.Path)
                        }</span>
                        <span class="cov0" title="0">return "", s.errorHandler.WrapError("failed to create output directory", err)</span>
                }

                // 将最佳临时文件移动到最终输出路径（原地使用原子替换，非原地直接重命名）
                <span class="cov0" title="0">isInPlace := s.converter.config.Output.DirectoryTemplate == ""
                if isInPlace </span><span class="cov0" title="0">{
                        if err := s.converter.fileOpHandler.AtomicFileReplace(bestResult.Path, finalOutputPath, true); err != nil </span><span class="cov0" title="0">{
                                s.converter.logger.Error("平衡优化：原子替换失败",
                                        zap.String("from", bestResult.Path),
                                        zap.String("to", finalOutputPath),
                                        zap.Error(err))
                                for _, result := range probeResults </span><span class="cov0" title="0">{
                                        os.Remove(result.Path)
                                }</span>
                                <span class="cov0" title="0">return "", s.errorHandler.WrapError("failed to atomically replace best result to final path", err)</span>
                        }
                } else<span class="cov0" title="0"> {
                        if err := os.Rename(bestResult.Path, finalOutputPath); err != nil </span><span class="cov0" title="0">{
                                s.converter.logger.Error("平衡优化：文件移动失败",
                                        zap.String("from", bestResult.Path),
                                        zap.String("to", finalOutputPath),
                                        zap.Error(err))
                                for _, result := range probeResults </span><span class="cov0" title="0">{
                                        os.Remove(result.Path)
                                }</span>
                                <span class="cov0" title="0">return "", s.errorHandler.WrapError("failed to move best result to final path", err)</span>
                        }
                }

                // 平衡优化：选择最佳结果

                // 清理其他探测结果的临时文件
                <span class="cov0" title="0">for _, result := range probeResults </span><span class="cov0" title="0">{
                        if result.Path != bestResult.Path </span><span class="cov0" title="0">{
                                os.Remove(result.Path)
                        }</span>
                }

                <span class="cov0" title="0">return finalOutputPath, nil</span>
        } else<span class="cov0" title="0"> {
                // 清理所有探测结果的临时文件
                for _, result := range probeResults </span><span class="cov0" title="0">{
                        os.Remove(result.Path)
                }</span>
                // 平衡优化：无显著体积减小，跳过
                <span class="cov0" title="0">return file.Path, nil</span> // skip(file, "No significant size reduction")
        }
}

// attemptLosslessRepackaging 尝试无损重新包装
// 第一步：容器格式优化，不改变编码数据
func (s *AutoPlusStrategy) attemptLosslessRepackaging(file *MediaFile) (string, error) <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 平衡优化步骤1：无损重新包装

        // 无损重新包装：仅改变容器格式，不重新编码像素数据
        switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                // JPEG -&gt; JXL 无损重新包装（lossless_jpeg=1）
                // 这是真正的重新包装，不重新编码JPEG数据
                return s.converter.convertJPEGToJXLRepackaging(file)</span>
        case ".png":<span class="cov0" title="0">
                // PNG -&gt; JXL 无损重新包装
                // 保持PNG的无损特性，仅改变容器
                return s.converter.convertPNGToJXLRepackaging(file)</span>
        case ".webp":<span class="cov0" title="0">
                // WebP文件跳过处理，避免性能瓶颈
                // 跳过WebP文件的无损重新包装（性能优化）
                return "", s.errorHandler.WrapError("WebP format skipped for performance optimization", nil)</span>
        default:<span class="cov0" title="0">
                // 其他格式不支持无损重新包装
                return "", s.errorHandler.WrapError("format "+ext+" does not support lossless repackaging", nil)</span>
        }
}

// attemptMathematicalLossless 尝试数学无损压缩
// 第二步：重新编码但保持数学无损
func (s *AutoPlusStrategy) attemptMathematicalLossless(file *MediaFile) (string, error) <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 平衡优化步骤2：数学无损压缩

        // 数学无损压缩：重新编码像素数据但保持完全无损
        switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                // JPEG -&gt; JXL 数学无损（distance=0，重新编码像素）
                return s.converter.convertToJXLMathematicalLossless(file)</span>
        case ".png":<span class="cov0" title="0">
                // PNG动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图 -&gt; AVIF（无损）
                        // PNG动图转换为AVIF
                        return s.converter.convertToAVIF(file, 100) // 无损AVIF
                }</span> else<span class="cov0" title="0"> {
                        // PNG -&gt; JXL 数学无损
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        case ".webp":<span class="cov0" title="0">
                // WebP动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图 -&gt; AVIF（无损）
                        // WebP动图转换为AVIF
                        return s.converter.convertToAVIF(file, 100) // 无损AVIF
                }</span> else<span class="cov0" title="0"> {
                        // WebP -&gt; JXL 数学无损
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        case ".gif":<span class="cov0" title="0">
                // GIF动图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图 -&gt; AVIF（无损）
                        // GIF动图转换为AVIF
                        return s.converter.convertToAVIF(file, 100) // 无损AVIF
                }</span> else<span class="cov0" title="0"> {
                        // 静图 -&gt; JXL 数学无损
                        // GIF静图转换为JXL
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        case ".avif":<span class="cov0" title="0">
                // AVIF已是目标格式，跳过转换
                return file.Path, nil</span>
        case ".jxl":<span class="cov0" title="0">
                // JXL动静图检测：动图转AVIF，静图保持JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态JXL为AVIF (数学无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：静态JXL已是目标格式，跳过转换
                        return file.Path, nil
                }</span>
        case ".apng":<span class="cov0" title="0">
                // APNG动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态APNG为AVIF (数学无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态APNG为JXL (数学无损)
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        case ".tiff", ".tif":<span class="cov0" title="0">
                // TIFF动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态TIFF为AVIF (数学无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态TIFF为JXL (数学无损)
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        case ".heif", ".heic":<span class="cov0" title="0">
                // HEIF/HEIC Live Photo检测：Live Photo跳过，静态图转JXL
                detector := NewFileTypeDetector(s.converter.config, s.converter.logger, s.converter.toolManager)
                details, err := detector.DetectFileType(file.Path)
                if err == nil &amp;&amp; details.FileType == FileTypeLivePhoto </span><span class="cov0" title="0">{
                        // Auto+模式：Live Photo跳过处理
                        return file.Path, nil
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态HEIF/HEIC为JXL (数学无损)
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        default:<span class="cov0" title="0">
                // 其他格式检测动静图：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换其他动态格式为AVIF (数学无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换其他静态格式为JXL (数学无损)
                        return s.converter.convertToJXLMathematicalLossless(file)
                }</span>
        }
}

// getFileQuality 获取文件质量（基于智能分析）
func (s *AutoPlusStrategy) getFileQuality(file *MediaFile) int <span class="cov0" title="0">{
        // 使用智能图像质量分析系统
        metrics := s.analyzeImageMetrics(file)

        // 将0-100的质量分数转换为压缩质量参数
        qualityScore := int(metrics.QualityScore)

        // 智能质量分析

        return qualityScore
}</span>

// attemptLossyCompression 尝试有损压缩
// attemptLossyCompression 尝试有损压缩
func (s *AutoPlusStrategy) attemptLossyCompression(file *MediaFile, quality int) (string, error) <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 为探测阶段创建带质量后缀的临时输入副本路径（通过硬链接/符号链接，无需拷贝）
        dir := filepath.Dir(file.Path)
        base := filepath.Base(file.Path)
        extName := filepath.Ext(base)
        name := strings.TrimSuffix(base, extName)
        probeBase := fmt.Sprintf("%s._probe_q%d%s", name, quality, extName)
        probePath := filepath.Join(dir, probeBase)

        // 预清理同名残留
        _ = s.converter.fileOpHandler.SafeRemoveFile(probePath)

        // 优先创建硬链接，失败则退回符号链接
        linkCreated := false
        if err := os.Link(file.Path, probePath); err == nil </span><span class="cov0" title="0">{
                linkCreated = true
        }</span> else<span class="cov0" title="0"> if err := os.Symlink(file.Path, probePath); err == nil </span><span class="cov0" title="0">{
                linkCreated = true
        }</span> else<span class="cov0" title="0"> {
                s.converter.logger.Warn("创建探测链接失败，将回退为直接使用源文件（可能导致输出命名冲突）",
                        zap.String("source", file.Path),
                        zap.String("probe", probePath))
        }</span>

        <span class="cov0" title="0">if linkCreated </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := os.Remove(probePath); err != nil </span><span class="cov0" title="0">{
                                s.converter.logger.Debug("清理探测链接失败", zap.String("probe", probePath), zap.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">probeFile := *file
        if linkCreated </span><span class="cov0" title="0">{
                probeFile.Path = probePath
        }</span> else<span class="cov0" title="0"> {
                // 链接创建失败时，保持原路径，输出将可能与其他探测产出冲突（极少数情况）
                probeFile.Path = file.Path
        }</span>

        // 根据格式选择最佳有损压缩方法（输出将落在带_probe后缀的独立文件中）
        <span class="cov0" title="0">switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                // 使用AVIF进行有损压缩
                return s.converter.convertToAVIF(&amp;probeFile, quality)</span>
        case ".png":<span class="cov0" title="0">
                // PNG使用JXL进行有损压缩（JXL支持透明度且效率更优）
                return s.converter.convertToJXL(&amp;probeFile, quality)</span>
        case ".webp":<span class="cov0" title="0">
                // WebP动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图 -&gt; AVIF（有损）
                        // WebP动图有损压缩为AVIF
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // 静图 -&gt; JXL（有损）
                        // WebP静图有损压缩为JXL
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        case ".gif":<span class="cov0" title="0">
                // GIF动图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图 -&gt; AVIF（有损）
                        // GIF动图有损压缩为AVIF
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // 静图 -&gt; JXL（有损）
                        // GIF静图有损压缩为JXL
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        case ".avif":<span class="cov0" title="0">
                // AVIF已是目标格式，跳过转换
                return file.Path, nil</span>
        case ".jxl":<span class="cov0" title="0">
                // JXL动静图检测：动图转AVIF，静图保持JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态JXL为AVIF (有损)
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：静态JXL已是目标格式，跳过转换
                        return file.Path, nil
                }</span>
        case ".apng":<span class="cov0" title="0">
                // APNG动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态APNG为AVIF (有损)
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态APNG为JXL (有损)
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        case ".tiff", ".tif":<span class="cov0" title="0">
                // TIFF动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换动态TIFF为AVIF (有损)
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态TIFF为JXL (有损)
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        case ".heif", ".heic":<span class="cov0" title="0">
                // HEIF/HEIC Live Photo检测：Live Photo跳过，静态图转JXL
                detector := NewFileTypeDetector(s.converter.config, s.converter.logger, s.converter.toolManager)
                details, err := detector.DetectFileType(file.Path)
                if err == nil &amp;&amp; details.FileType == FileTypeLivePhoto </span><span class="cov0" title="0">{
                        // Auto+模式：Live Photo跳过处理
                        return file.Path, nil
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换静态HEIF/HEIC为JXL (有损)
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        default:<span class="cov0" title="0">
                // 其他格式检测动静图：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // Auto+模式：转换其他动态格式为AVIF (有损)
                        return s.converter.convertToAVIF(&amp;probeFile, quality)
                }</span> else<span class="cov0" title="0"> {
                        // Auto+模式：转换其他静态格式为JXL (有损)
                        return s.converter.convertToJXL(&amp;probeFile, quality)
                }</span>
        }
}

// getFileSize 获取文件大小
func (s *AutoPlusStrategy) getFileSize(path string) int64 <span class="cov0" title="0">{
        if stat, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return stat.Size()
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// selectOptimalStrategy 基于图像特征选择最优转换策略
func (s *AutoPlusStrategy) selectOptimalStrategy(metrics ImageQualityMetrics, file *MediaFile) string <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 高质量原画：仅无损优化
        if metrics.QualityScore &gt; 90 &amp;&amp; metrics.CompressionPotential &lt; 0.3 </span><span class="cov0" title="0">{
                return "lossless_only"
        }</span>

        // 高压缩潜力且非关键格式：优先有损
        <span class="cov0" title="0">if metrics.CompressionPotential &gt; 0.7 &amp;&amp; (ext == ".png" || ext == ".bmp" || ext == ".tiff") </span><span class="cov0" title="0">{
                return "lossy_preferred"
        }</span>

        // 低质量或高噪声：优先有损
        <span class="cov0" title="0">if metrics.QualityScore &lt; 60 || metrics.NoiseLevel &gt; 0.6 </span><span class="cov0" title="0">{
                return "lossy_preferred"
        }</span>

        // 已经是现代格式且质量不错：可能跳过
        <span class="cov0" title="0">if (ext == ".webp" || ext == ".avif" || ext == ".jxl") &amp;&amp; metrics.QualityScore &gt; 70 </span><span class="cov0" title="0">{
                return "skip"
        }</span>

        // 默认渐进式优化
        <span class="cov0" title="0">return "progressive"</span>
}

// selectBestProbeResult 选择最佳探测结果
func (s *AutoPlusStrategy) selectBestProbeResult(results []ProbeResult, originalSize int64) *ProbeResult <span class="cov0" title="0">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 智能决策逻辑：选择空间减小至少1KB或减少比例明显的版本
        <span class="cov0" title="0">const minSizeReduction = 1024  // 1KB
        const minReductionRatio = 0.05 // 5%

        var bestResult *ProbeResult
        bestScore := 0.0

        for i := range results </span><span class="cov0" title="0">{
                result := &amp;results[i]

                // 检查是否满足最小减小要求
                sizeReduction := originalSize - result.Size
                if sizeReduction &lt; minSizeReduction </span><span class="cov0" title="0">{
                        continue</span> // 减小不足1KB，跳过
                }

                <span class="cov0" title="0">reductionRatio := float64(sizeReduction) / float64(originalSize)
                if reductionRatio &lt; minReductionRatio </span><span class="cov0" title="0">{
                        continue</span> // 减少比例不足5%，跳过
                }

                // 计算综合评分：平衡质量和压缩比
                // 评分 = 压缩比权重 * 压缩比 + 质量权重 * (质量/100)
                <span class="cov0" title="0">compressionWeight := 0.7
                qualityWeight := 0.3

                score := compressionWeight*reductionRatio + qualityWeight*(float64(result.Quality)/100.0)

                if score &gt; bestScore </span><span class="cov0" title="0">{
                        bestScore = score
                        bestResult = result
                }</span>

                // 平衡优化：评估探测结果
        }

        <span class="cov0" title="0">if bestResult != nil </span>{<span class="cov0" title="0">
                // 平衡优化：选择最佳结果
        }</span>

        <span class="cov0" title="0">return bestResult</span>
}

// === 品质模式 实现 ===

func (s *QualityStrategy) GetName() string <span class="cov8" title="1">{
        return "quality (无损优先)"
}</span>

func (s *QualityStrategy) ConvertImage(file *MediaFile) (string, error) <span class="cov0" title="0">{
        s.converter.logger.Debug("品质模式图片转换开始", zap.String("file", file.Path), zap.String("extension", file.Extension))
        ext := strings.ToLower(file.Extension)

        // 检查是否已经是目标格式
        if s.converter.IsTargetFormat(ext) </span><span class="cov0" title="0">{
                s.converter.logger.Debug("文件已是目标格式，跳过转换", zap.String("file", file.Path))
                // 品质模式：文件已是目标格式，跳过转换
                return file.Path, nil
        }</span>

        // 强制转换为目标格式，采用数学无损压缩
        // 目标格式: 静图: JXL, 动图: AVIF (无损), 视频: MOV (仅重包装)
        <span class="cov0" title="0">switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                // JPEG必须使用cjxl的lossless_jpeg=1参数
                s.converter.logger.Debug("开始转换JPEG到JXL", zap.String("file", file.Path))
                return s.converter.convertToJXLLossless(file)</span>
        case ".png":<span class="cov0" title="0">
                // PNG动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("PNG是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动态PNG为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100) // 动图AVIF无损
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("PNG是静图，转换为JXL", zap.String("file", file.Path))
                        // PNG无损转换为JXL（JXL完全支持透明度且压缩效率更优）
                        // 品质模式：转换静态PNG为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        case ".gif":<span class="cov0" title="0">
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("GIF是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动图为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100) // 动图AVIF无损
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("GIF是静图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换静态GIF为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        case ".webp":<span class="cov0" title="0">
                // WebP动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("WebP是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动态WebP为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100) // 动图AVIF无损
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("WebP是静图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换静态WebP为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        case ".avif":<span class="cov0" title="0">
                // AVIF已是目标格式，跳过转换
                s.converter.logger.Debug("AVIF已是目标格式，跳过转换", zap.String("file", file.Path))
                return file.Path, nil</span>
        case ".jxl":<span class="cov0" title="0">
                // JXL动静图检测：动图转AVIF，静图保持JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("JXL是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动态JXL为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("JXL是静图，已是目标格式，跳过转换", zap.String("file", file.Path))
                        // 品质模式：静态JXL已是目标格式，跳过转换
                        return file.Path, nil
                }</span>
        case ".apng":<span class="cov0" title="0">
                // APNG动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("APNG是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动态APNG为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("APNG是静图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换静态APNG为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        case ".tiff", ".tif":<span class="cov0" title="0">
                // TIFF动静图检测：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("TIFF是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换动态TIFF为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("TIFF是静图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换静态TIFF为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        case ".heif", ".heic":<span class="cov0" title="0">
                // HEIF/HEIC Live Photo检测：Live Photo跳过，静态图转JXL
                s.converter.logger.Debug("处理HEIF/HEIC文件", zap.String("file", file.Path))
                detector := NewFileTypeDetector(s.converter.config, s.converter.logger, s.converter.toolManager)
                details, err := detector.DetectFileType(file.Path)
                if err == nil &amp;&amp; details.FileType == FileTypeLivePhoto </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("HEIF/HEIC是Live Photo，跳过处理", zap.String("file", file.Path))
                        // 品质模式：Live Photo跳过处理
                        return file.Path, nil
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("HEIF/HEIC是静态图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换静态HEIF/HEIC为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        default:<span class="cov0" title="0">
                // 其他格式检测动静图：动图转AVIF，静图转JXL
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        s.converter.logger.Debug("其他格式是动图，转换为AVIF", zap.String("file", file.Path))
                        // 品质模式：转换其他动态格式为AVIF (无损)
                        return s.converter.convertToAVIF(file, 100)
                }</span> else<span class="cov0" title="0"> {
                        s.converter.logger.Debug("其他格式是静图，转换为JXL", zap.String("file", file.Path))
                        // 品质模式：转换其他静态格式为JXL (无损)
                        return s.converter.convertToJXLLossless(file)
                }</span>
        }
}

func (s *QualityStrategy) ConvertVideo(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 视频重包装为MOV
        // 品质模式：视频重包装为MOV
        return s.converter.convertToMOV(file)
}</span>

// ConvertAudio方法已删除 - 根据README要求，本程序不处理音频文件

// === 表情包模式 实现 ===

func (s *EmojiStrategy) GetName() string <span class="cov8" title="1">{
        return "emoji (极限压缩)"
}</span>

func (s *EmojiStrategy) ConvertImage(file *MediaFile) (string, error) <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 检查是否已经是目标格式
        if s.converter.IsTargetFormat(ext) </span><span class="cov0" title="0">{
                // 表情包模式：文件已是目标格式，跳过转换
                return file.Path, nil
        }</span>

        // 跳过已经是高效格式的文件（AVIF, JXL, WebP）
        // 这些格式不需要进一步压缩，avifenc也不支持JXL作为输入
        <span class="cov0" title="0">if ext == ".webp" || ext == ".avif" || ext == ".jxl" </span><span class="cov0" title="0">{
                // 表情包模式跳过高效格式文件
                return file.Path, nil
        }</span>

        // 根据README规定：表情包模式下工具链优先级
        // 静态图: 使用 AVIF 官方组件 (avifenc)
        // 动图: 使用 ffmpeg 转换为 AVIF
        <span class="cov0" title="0">switch ext </span>{
        case ".gif":<span class="cov0" title="0">
                if s.converter.isAnimated(file.Path) </span><span class="cov0" title="0">{
                        // 动图使用ffmpeg处理
                        // 表情包模式：动图使用ffmpeg处理
                        return s.converter.ConvertToAVIFAnimated(file) // 使用ffmpeg
                }</span> else<span class="cov0" title="0"> {
                        // 静态GIF使用极限压缩策略
                        // 表情包模式：静态图使用极限压缩策略
                        return s.tryAggressiveAVIF(file)
                }</span>
        default:<span class="cov0" title="0">
                // 所有其他静态图片使用极限压缩策略
                // 表情包模式：静态图使用极限压缩策略
                return s.tryAggressiveAVIF(file)</span>
        }
}

func (s *EmojiStrategy) ConvertVideo(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 根据README规定：表情包模式下视频文件必须被直接跳过，不得进行任何处理
        // 表情包模式跳过视频文件
        return file.Path, nil
}</span>

// ConvertAudio方法已删除 - 根据README要求，本程序不处理音频文件

// tryAggressiveAVIF 尝试激进的AVIF压缩
func (s *EmojiStrategy) tryAggressiveAVIF(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 优先尝试无损压缩和重包装
        if result, err := s.converter.convertToAVIF(file, 100); err == nil </span><span class="cov0" title="0">{
                if s.checkAggressiveReduction(file.Path, result) </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        }

        // 比平衡优化更激进的有损压缩范围进行探底
        // 只要转换后文件体积相比原图减小 7%-13% 或更多，即视为成功
        <span class="cov0" title="0">aggressiveLevels := []int{60, 50, 40, 30, 25, 20}

        originalStat, err := os.Stat(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return file.Path, s.errorHandler.WrapError("无法获取原文件信息", err)
        }</span>
        <span class="cov0" title="0">originalSize := originalStat.Size()

        for _, quality := range aggressiveLevels </span><span class="cov0" title="0">{
                // 尝试AVIF质量级别

                result, err := s.converter.convertToAVIF(file, quality)
                if err != nil </span><span class="cov0" title="0">{
                        s.converter.logger.Warn("AVIF转换失败，尝试下一个质量级别",
                                zap.String("file", file.Path),
                                zap.Int("quality", quality),
                                zap.Error(err))
                        continue</span>
                }

                // 检查转换后的文件
                <span class="cov0" title="0">newStat, err := os.Stat(result)
                if err != nil </span><span class="cov0" title="0">{
                        s.converter.logger.Warn("无法获取转换后文件信息",
                                zap.String("file", result),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">newSize := newStat.Size()

                // 检查压缩效果：优先选择7%-13%范围，如果没有则选择最接近的
                reductionRatio := float64(originalSize-newSize) / float64(originalSize)
                // 检查压缩比例

                // 理想范围：7%-13%
                if reductionRatio &gt;= 0.07 &amp;&amp; reductionRatio &lt;= 0.13 </span><span class="cov0" title="0">{
                        // 找到理想的AVIF压缩级别
                        return result, nil
                }</span>

                // 如果压缩比例超过13%但文件确实变小了，也接受（表情包模式追求极限压缩）
                <span class="cov0" title="0">if reductionRatio &gt; 0.13 &amp;&amp; quality == 60 </span><span class="cov0" title="0">{ // 使用最高质量的结果
                        // 使用高压缩比AVIF结果
                        return result, nil
                }</span>
        }

        <span class="cov0" title="0">return file.Path, s.errorHandler.WrapError("无法找到合适的压缩级别", nil)</span>
}

// checkAggressiveReduction 检查是否达到7%-13%的体积减小
func (s *EmojiStrategy) checkAggressiveReduction(originalPath, newPath string) bool <span class="cov0" title="0">{
        originalStat, err1 := os.Stat(originalPath)
        newStat, err2 := os.Stat(newPath)

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // 计算减小比例
        <span class="cov0" title="0">reductionRatio := float64(originalStat.Size()-newStat.Size()) / float64(originalStat.Size())

        // 检查是否达到7%-13%的体积减小
        return reductionRatio &gt;= 0.07 &amp;&amp; reductionRatio &lt;= 0.13</span>
}

// convertImage 执行图像转换
func (s *AutoPlusStrategy) convertImage(inputPath, outputPath string, targetFormat string) error <span class="cov0" title="0">{
        // 验证输入文件
        if _, err := os.Stat(inputPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("输入文件不存在: %v", err)
        }</span>

        // 确保输出目录存在
        <span class="cov0" title="0">outputDir := GlobalPathUtils.GetDirName(outputPath)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法创建输出目录: %v", err)
        }</span>

        // 标准化目标格式
        <span class="cov0" title="0">targetFormat = strings.ToLower(targetFormat)
        if !strings.HasPrefix(targetFormat, ".") </span><span class="cov0" title="0">{
                targetFormat = "." + targetFormat
        }</span>

        // 根据目标格式选择转换策略
        <span class="cov0" title="0">switch targetFormat </span>{
        case ".avif":<span class="cov0" title="0">
                return s.convertToAVIF(inputPath, outputPath)</span>
        case ".jxl":<span class="cov0" title="0">
                return s.convertToJXL(inputPath, outputPath)</span>
        case ".webp":<span class="cov0" title="0">
                return s.convertToWebP(inputPath, outputPath)</span>
        case ".png":<span class="cov0" title="0">
                return s.convertToPNG(inputPath, outputPath)</span>
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return s.convertToJPEG(inputPath, outputPath)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("不支持的格式: %s", targetFormat)</span>
        }
}

// convertToAVIF 转换到AVIF格式
func (s *AutoPlusStrategy) convertToAVIF(inputPath, outputPath string) error <span class="cov0" title="0">{
        // 构建ffmpeg命令
        cmd := exec.Command("ffmpeg", "-i", inputPath, 
                "-c:v", "libaom-av1", 
                "-crf", "35", 
                "-b:v", "0", 
                "-pix_fmt", "yuv420p", 
                "-an", 
                outputPath)

        // 执行命令
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("AVIF转换失败: %v, 输出: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// convertToJXL 转换到JXL格式
func (s *AutoPlusStrategy) convertToJXL(inputPath, outputPath string) error <span class="cov0" title="0">{
        // 构建cjxl命令
        cmd := exec.Command("cjxl", inputPath, outputPath, "-q", "90", "-e", "7")

        // 执行命令
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JXL转换失败: %v, 输出: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// convertToWebP 转换到WebP格式
func (s *AutoPlusStrategy) convertToWebP(inputPath, outputPath string) error <span class="cov0" title="0">{
        cmd := exec.Command("cwebp", inputPath, "-q", "80", "-o", outputPath)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebP转换失败: %v, 输出: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToPNG 转换到PNG格式
func (s *AutoPlusStrategy) convertToPNG(inputPath, outputPath string) error <span class="cov0" title="0">{
        cmd := exec.Command("ffmpeg", "-i", inputPath, "-c:v", "png", outputPath)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PNG转换失败: %v, 输出: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToJPEG 转换到JPEG格式
func (s *AutoPlusStrategy) convertToJPEG(inputPath, outputPath string) error <span class="cov0" title="0">{
        cmd := exec.Command("ffmpeg", "-i", inputPath, "-c:v", "mjpeg", "-q:v", "2", outputPath)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JPEG转换失败: %v, 输出: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package converter

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "go.uber.org/zap"
)

// TaskState 任务状态枚举
type TaskState int

const (
        TaskStatePending TaskState = iota
        TaskStateQueued
        TaskStateRunning
        TaskStateCompleted
        TaskStateFailed
        TaskStateCanceled
        TaskStateSkipped
        TaskStateRetrying
)

// String 返回任务状态字符串
func (ts TaskState) String() string <span class="cov0" title="0">{
        switch ts </span>{
        case TaskStatePending:<span class="cov0" title="0">
                return "pending"</span>
        case TaskStateQueued:<span class="cov0" title="0">
                return "queued"</span>
        case TaskStateRunning:<span class="cov0" title="0">
                return "running"</span>
        case TaskStateCompleted:<span class="cov0" title="0">
                return "completed"</span>
        case TaskStateFailed:<span class="cov0" title="0">
                return "failed"</span>
        case TaskStateCanceled:<span class="cov0" title="0">
                return "canceled"</span>
        case TaskStateSkipped:<span class="cov0" title="0">
                return "skipped"</span>
        case TaskStateRetrying:<span class="cov0" title="0">
                return "retrying"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// TaskInfo 任务信息
type TaskInfo struct {
        ID           string        `json:"id"`
        FilePath     string        `json:"file_path"`
        FileSize     int64         `json:"file_size"`
        State        TaskState     `json:"state"`
        Progress     float64       `json:"progress"`
        StartTime    time.Time     `json:"start_time"`
        EndTime      time.Time     `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        ErrorMessage string        `json:"error_message,omitempty"`
        RetryCount   int           `json:"retry_count"`
        Priority     TaskPriority  `json:"priority"`
        WorkerID     int           `json:"worker_id"`
        QueueTime    time.Time     `json:"queue_time"`
        WaitDuration time.Duration `json:"wait_duration"`
        CreatedAt    time.Time     `json:"created_at"`
        UpdatedAt    time.Time     `json:"updated_at"`
}

// TaskMetrics 任务监控指标
type TaskMetrics struct {
        // 基础计数器
        TotalTasks     int64 `json:"total_tasks"`
        PendingTasks   int64 `json:"pending_tasks"`
        QueuedTasks    int64 `json:"queued_tasks"`
        RunningTasks   int64 `json:"running_tasks"`
        CompletedTasks int64 `json:"completed_tasks"`
        FailedTasks    int64 `json:"failed_tasks"`
        CanceledTasks  int64 `json:"canceled_tasks"`
        SkippedTasks   int64 `json:"skipped_tasks"`
        RetryingTasks  int64 `json:"retrying_tasks"`

        // 性能指标
        AverageWaitTime       time.Duration `json:"average_wait_time"`
        AverageProcessingTime time.Duration `json:"average_processing_time"`
        ThroughputPerSecond   float64       `json:"throughput_per_second"`
        SuccessRate           float64       `json:"success_rate"`
        FailureRate           float64       `json:"failure_rate"`

        // 资源使用
        ActiveWorkers     int32   `json:"active_workers"`
        MaxWorkers        int32   `json:"max_workers"`
        WorkerUtilization float64 `json:"worker_utilization"`

        // 时间戳
        LastUpdate time.Time `json:"last_update"`
        StartTime  time.Time `json:"start_time"`
}

// TaskMonitor 任务监控器
type TaskMonitor struct {
        logger *zap.Logger
        ctx    context.Context
        cancel context.CancelFunc

        // 任务存储
        tasks     map[string]*TaskInfo
        taskMutex sync.RWMutex

        // 指标统计
        metrics      TaskMetrics
        metricsMutex sync.RWMutex

        // 监控配置
        updateInterval  time.Duration
        cleanupInterval time.Duration
        maxTaskHistory  int

        // 事件通道
        taskUpdateChan   chan *TaskInfo
        metricUpdateChan chan TaskMetrics

        // 状态
        isRunning bool
        startTime time.Time
}

// NewTaskMonitor 创建新的任务监控器
func NewTaskMonitor(logger *zap.Logger) *TaskMonitor <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        tm := &amp;TaskMonitor{
                logger:           logger,
                ctx:              ctx,
                cancel:           cancel,
                tasks:            make(map[string]*TaskInfo),
                updateInterval:   time.Second,
                cleanupInterval:  5 * time.Minute,
                maxTaskHistory:   1000,
                taskUpdateChan:   make(chan *TaskInfo, 100),
                metricUpdateChan: make(chan TaskMetrics, 10),
                startTime:        time.Now(),
        }

        // 初始化指标
        tm.metrics.StartTime = time.Now()
        tm.metrics.LastUpdate = time.Now()

        return tm
}</span>

// Start 启动任务监控器
func (tm *TaskMonitor) Start() error <span class="cov8" title="1">{
        if tm.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("任务监控器已在运行")
        }</span>

        <span class="cov8" title="1">tm.isRunning = true
        // 启动任务监控器

        // 启动监控协程
        go tm.monitorLoop()
        go tm.metricsUpdateLoop()
        go tm.cleanupLoop()

        return nil</span>
}

// Stop 停止任务监控器
func (tm *TaskMonitor) Stop() <span class="cov8" title="1">{
        if !tm.isRunning </span><span class="cov0" title="0">{
                return
        }</span>

        // 停止任务监控器
        <span class="cov8" title="1">tm.cancel()
        tm.isRunning = false

        // 关闭通道
        close(tm.taskUpdateChan)
        close(tm.metricUpdateChan)</span>
}

// RegisterTask 注册新任务
func (tm *TaskMonitor) RegisterTask(taskID, filePath string, fileSize int64, priority TaskPriority) *TaskInfo <span class="cov0" title="0">{
        now := time.Now()
        task := &amp;TaskInfo{
                ID:        taskID,
                FilePath:  filePath,
                FileSize:  fileSize,
                State:     TaskStatePending,
                Progress:  0.0,
                Priority:  priority,
                CreatedAt: now,
                UpdatedAt: now,
        }

        tm.taskMutex.Lock()
        tm.tasks[taskID] = task
        atomic.AddInt64(&amp;tm.metrics.TotalTasks, 1)
        atomic.AddInt64(&amp;tm.metrics.PendingTasks, 1)
        tm.taskMutex.Unlock()

        // 注册新任务

        // 发送任务更新事件
        select </span>{
        case tm.taskUpdateChan &lt;- task:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // 通道满了，跳过
        }

        <span class="cov0" title="0">return task</span>
}

// UpdateTaskState 更新任务状态
func (tm *TaskMonitor) UpdateTaskState(taskID string, newState TaskState, errorMessage ...string) error <span class="cov0" title="0">{
        tm.taskMutex.Lock()
        defer tm.taskMutex.Unlock()

        task, exists := tm.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("任务不存在: %s", taskID)
        }</span>

        <span class="cov0" title="0">oldState := task.State
        now := time.Now()

        // 更新计数器
        tm.updateStateCounters(oldState, newState)

        // 更新任务信息
        task.State = newState
        task.UpdatedAt = now

        // 处理特定状态的逻辑
        switch newState </span>{
        case TaskStateQueued:<span class="cov0" title="0">
                task.QueueTime = now</span>
        case TaskStateRunning:<span class="cov0" title="0">
                task.StartTime = now
                if !task.QueueTime.IsZero() </span><span class="cov0" title="0">{
                        task.WaitDuration = now.Sub(task.QueueTime)
                }</span>
        case TaskStateCompleted, TaskStateFailed, TaskStateCanceled, TaskStateSkipped:<span class="cov0" title="0">
                task.EndTime = now
                if !task.StartTime.IsZero() </span><span class="cov0" title="0">{
                        task.Duration = now.Sub(task.StartTime)
                }</span>
                <span class="cov0" title="0">if len(errorMessage) &gt; 0 </span><span class="cov0" title="0">{
                        task.ErrorMessage = errorMessage[0]
                }</span>
        case TaskStateRetrying:<span class="cov0" title="0">
                task.RetryCount++</span>
        }

        // 更新任务状态

        // 发送任务更新事件
        <span class="cov0" title="0">select </span>{
        case tm.taskUpdateChan &lt;- task:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // 通道满了，跳过
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateTaskProgress 更新任务进度
func (tm *TaskMonitor) UpdateTaskProgress(taskID string, progress float64) error <span class="cov0" title="0">{
        tm.taskMutex.Lock()
        defer tm.taskMutex.Unlock()

        task, exists := tm.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("任务不存在: %s", taskID)
        }</span>

        // 确保进度在有效范围内
        <span class="cov0" title="0">if progress &lt; 0 </span><span class="cov0" title="0">{
                progress = 0
        }</span> else<span class="cov0" title="0"> if progress &gt; 100 </span><span class="cov0" title="0">{
                progress = 100
        }</span>

        <span class="cov0" title="0">task.Progress = progress
        task.UpdatedAt = time.Now()

        // 如果进度达到100%，自动更新状态为完成
        if progress &gt;= 100 &amp;&amp; task.State == TaskStateRunning </span><span class="cov0" title="0">{
                tm.updateStateCounters(task.State, TaskStateCompleted)
                task.State = TaskStateCompleted
                task.EndTime = time.Now()
                if !task.StartTime.IsZero() </span><span class="cov0" title="0">{
                        task.Duration = task.EndTime.Sub(task.StartTime)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AssignTaskToWorker 分配任务给工作器
func (tm *TaskMonitor) AssignTaskToWorker(taskID string, workerID int) error <span class="cov0" title="0">{
        tm.taskMutex.Lock()
        defer tm.taskMutex.Unlock()

        task, exists := tm.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("任务不存在: %s", taskID)
        }</span>

        <span class="cov0" title="0">task.WorkerID = workerID
        task.UpdatedAt = time.Now()

        // 分配任务给工作器

        return nil</span>
}

// GetTask 获取任务信息
func (tm *TaskMonitor) GetTask(taskID string) (*TaskInfo, error) <span class="cov0" title="0">{
        tm.taskMutex.RLock()
        defer tm.taskMutex.RUnlock()

        task, exists := tm.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("任务不存在: %s", taskID)
        }</span>

        // 返回任务副本
        <span class="cov0" title="0">taskCopy := *task
        return &amp;taskCopy, nil</span>
}

// GetAllTasks 获取所有任务
func (tm *TaskMonitor) GetAllTasks() map[string]*TaskInfo <span class="cov0" title="0">{
        tm.taskMutex.RLock()
        defer tm.taskMutex.RUnlock()

        tasks := make(map[string]*TaskInfo)
        for id, task := range tm.tasks </span><span class="cov0" title="0">{
                taskCopy := *task
                tasks[id] = &amp;taskCopy
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

// GetTasksByState 根据状态获取任务
func (tm *TaskMonitor) GetTasksByState(state TaskState) []*TaskInfo <span class="cov0" title="0">{
        tm.taskMutex.RLock()
        defer tm.taskMutex.RUnlock()

        var tasks []*TaskInfo
        for _, task := range tm.tasks </span><span class="cov0" title="0">{
                if task.State == state </span><span class="cov0" title="0">{
                        taskCopy := *task
                        tasks = append(tasks, &amp;taskCopy)
                }</span>
        }

        <span class="cov0" title="0">return tasks</span>
}

// GetMetrics 获取监控指标
func (tm *TaskMonitor) GetMetrics() TaskMetrics <span class="cov0" title="0">{
        tm.metricsMutex.RLock()
        defer tm.metricsMutex.RUnlock()

        return tm.metrics
}</span>

// updateStateCounters 更新状态计数器
func (tm *TaskMonitor) updateStateCounters(oldState, newState TaskState) <span class="cov0" title="0">{
        // 减少旧状态计数
        switch oldState </span>{
        case TaskStatePending:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.PendingTasks, -1)</span>
        case TaskStateQueued:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.QueuedTasks, -1)</span>
        case TaskStateRunning:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.RunningTasks, -1)</span>
        case TaskStateCompleted:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.CompletedTasks, -1)</span>
        case TaskStateFailed:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.FailedTasks, -1)</span>
        case TaskStateCanceled:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.CanceledTasks, -1)</span>
        case TaskStateSkipped:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.SkippedTasks, -1)</span>
        case TaskStateRetrying:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.RetryingTasks, -1)</span>
        }

        // 增加新状态计数
        <span class="cov0" title="0">switch newState </span>{
        case TaskStatePending:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.PendingTasks, 1)</span>
        case TaskStateQueued:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.QueuedTasks, 1)</span>
        case TaskStateRunning:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.RunningTasks, 1)</span>
        case TaskStateCompleted:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.CompletedTasks, 1)</span>
        case TaskStateFailed:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.FailedTasks, 1)</span>
        case TaskStateCanceled:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.CanceledTasks, 1)</span>
        case TaskStateSkipped:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.SkippedTasks, 1)</span>
        case TaskStateRetrying:<span class="cov0" title="0">
                atomic.AddInt64(&amp;tm.metrics.RetryingTasks, 1)</span>
        }
}

// monitorLoop 监控主循环
func (tm *TaskMonitor) monitorLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(tm.updateInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-tm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        tm.updateMetrics()</span>
                case task := &lt;-tm.taskUpdateChan:<span class="cov0" title="0">
                        tm.handleTaskUpdate(task)</span>
                }
        }
}

// metricsUpdateLoop 指标更新循环
func (tm *TaskMonitor) metricsUpdateLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-tm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        tm.calculateAdvancedMetrics()</span>
                }
        }
}

// cleanupLoop 清理循环
func (tm *TaskMonitor) cleanupLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(tm.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-tm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        tm.cleanupOldTasks()</span>
                }
        }
}

// updateMetrics 更新基础指标
func (tm *TaskMonitor) updateMetrics() <span class="cov0" title="0">{
        tm.metricsMutex.Lock()
        defer tm.metricsMutex.Unlock()

        tm.metrics.LastUpdate = time.Now()
}</span>

// calculateAdvancedMetrics 计算高级指标
func (tm *TaskMonitor) calculateAdvancedMetrics() <span class="cov0" title="0">{
        tm.taskMutex.RLock()
        tasks := make([]*TaskInfo, 0, len(tm.tasks))
        for _, task := range tm.tasks </span><span class="cov0" title="0">{
                tasks = append(tasks, task)
        }</span>
        <span class="cov0" title="0">tm.taskMutex.RUnlock()

        tm.metricsMutex.Lock()
        defer tm.metricsMutex.Unlock()

        // 计算平均等待时间和处理时间
        var totalWaitTime, totalProcessingTime time.Duration
        var waitCount, processingCount int

        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.WaitDuration &gt; 0 </span><span class="cov0" title="0">{
                        totalWaitTime += task.WaitDuration
                        waitCount++
                }</span>
                <span class="cov0" title="0">if task.Duration &gt; 0 </span><span class="cov0" title="0">{
                        totalProcessingTime += task.Duration
                        processingCount++
                }</span>
        }

        <span class="cov0" title="0">if waitCount &gt; 0 </span><span class="cov0" title="0">{
                tm.metrics.AverageWaitTime = totalWaitTime / time.Duration(waitCount)
        }</span>
        <span class="cov0" title="0">if processingCount &gt; 0 </span><span class="cov0" title="0">{
                tm.metrics.AverageProcessingTime = totalProcessingTime / time.Duration(processingCount)
        }</span>

        // 计算成功率和失败率
        <span class="cov0" title="0">totalCompleted := atomic.LoadInt64(&amp;tm.metrics.CompletedTasks) + atomic.LoadInt64(&amp;tm.metrics.FailedTasks)
        if totalCompleted &gt; 0 </span><span class="cov0" title="0">{
                tm.metrics.SuccessRate = float64(atomic.LoadInt64(&amp;tm.metrics.CompletedTasks)) / float64(totalCompleted) * 100
                tm.metrics.FailureRate = float64(atomic.LoadInt64(&amp;tm.metrics.FailedTasks)) / float64(totalCompleted) * 100
        }</span>

        // 计算吞吐量
        <span class="cov0" title="0">elapsed := time.Since(tm.metrics.StartTime)
        if elapsed &gt; 0 </span><span class="cov0" title="0">{
                tm.metrics.ThroughputPerSecond = float64(atomic.LoadInt64(&amp;tm.metrics.CompletedTasks)) / elapsed.Seconds()
        }</span>

        // 计算工作器利用率
        <span class="cov0" title="0">if tm.metrics.MaxWorkers &gt; 0 </span><span class="cov0" title="0">{
                tm.metrics.WorkerUtilization = float64(tm.metrics.ActiveWorkers) / float64(tm.metrics.MaxWorkers) * 100
        }</span>
}

// handleTaskUpdate 处理任务更新事件
func (tm *TaskMonitor) handleTaskUpdate(task *TaskInfo) {<span class="cov0" title="0">
        // 这里可以添加任务更新的额外处理逻辑
        // 比如发送通知、更新UI等
        // 处理任务更新事件
}</span>

// cleanupOldTasks 清理旧任务
func (tm *TaskMonitor) cleanupOldTasks() <span class="cov0" title="0">{
        tm.taskMutex.Lock()
        defer tm.taskMutex.Unlock()

        if len(tm.tasks) &lt;= tm.maxTaskHistory </span><span class="cov0" title="0">{
                return
        }</span>

        // 收集已完成的旧任务
        <span class="cov0" title="0">var oldTasks []string
        cutoff := time.Now().Add(-24 * time.Hour) // 保留24小时内的任务

        for id, task := range tm.tasks </span><span class="cov0" title="0">{
                if (task.State == TaskStateCompleted || task.State == TaskStateFailed ||
                        task.State == TaskStateCanceled || task.State == TaskStateSkipped) &amp;&amp;
                        task.UpdatedAt.Before(cutoff) </span><span class="cov0" title="0">{
                        oldTasks = append(oldTasks, id)
                }</span>
        }

        // 删除旧任务
        <span class="cov0" title="0">for _, id := range oldTasks </span><span class="cov0" title="0">{
                delete(tm.tasks, id)
        }</span>

        <span class="cov0" title="0">if len(oldTasks) &gt; 0 </span>{<span class="cov0" title="0">
                // 清理旧任务
        }</span>
}

// SetMaxWorkers 设置最大工作器数量
func (tm *TaskMonitor) SetMaxWorkers(maxWorkers int32) <span class="cov8" title="1">{
        tm.metricsMutex.Lock()
        defer tm.metricsMutex.Unlock()

        tm.metrics.MaxWorkers = maxWorkers
}</span>

// SetActiveWorkers 设置活跃工作器数量
func (tm *TaskMonitor) SetActiveWorkers(activeWorkers int32) <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;tm.metrics.ActiveWorkers, activeWorkers)
}</span>

// GetTaskUpdateChannel 获取任务更新通道（只读）
func (tm *TaskMonitor) GetTaskUpdateChannel() &lt;-chan *TaskInfo <span class="cov0" title="0">{
        return tm.taskUpdateChan
}</span>

// GetMetricUpdateChannel 获取指标更新通道（只读）
func (tm *TaskMonitor) GetMetricUpdateChannel() &lt;-chan TaskMetrics <span class="cov0" title="0">{
        return tm.metricUpdateChan
}</span>

// IsRunning 检查监控器是否运行中
func (tm *TaskMonitor) IsRunning() bool <span class="cov0" title="0">{
        return tm.isRunning
}</span>

// GetTaskCount 获取各状态任务数量
func (tm *TaskMonitor) GetTaskCount() map[string]int64 <span class="cov0" title="0">{
        return map[string]int64{
                "total":     atomic.LoadInt64(&amp;tm.metrics.TotalTasks),
                "pending":   atomic.LoadInt64(&amp;tm.metrics.PendingTasks),
                "queued":    atomic.LoadInt64(&amp;tm.metrics.QueuedTasks),
                "running":   atomic.LoadInt64(&amp;tm.metrics.RunningTasks),
                "completed": atomic.LoadInt64(&amp;tm.metrics.CompletedTasks),
                "failed":    atomic.LoadInt64(&amp;tm.metrics.FailedTasks),
                "canceled":  atomic.LoadInt64(&amp;tm.metrics.CanceledTasks),
                "skipped":   atomic.LoadInt64(&amp;tm.metrics.SkippedTasks),
                "retrying":  atomic.LoadInt64(&amp;tm.metrics.RetryingTasks),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package converter

import (
        "context"
        "errors"
        "os/exec"
        "strings"
        "sync"
        "time"

        "pixly/config"

        "go.uber.org/zap"
)

// ToolManager 工具管理器
type ToolManager struct {
        config       *config.Config
        logger       *zap.Logger
        toolCache    map[string]bool
        cacheMutex   sync.RWMutex
        errorHandler *ErrorHandler
}

// NewToolManager 创建新的工具管理器
func NewToolManager(config *config.Config, logger *zap.Logger, errorHandler *ErrorHandler) *ToolManager <span class="cov8" title="1">{
        return &amp;ToolManager{
                config:       config,
                logger:       logger,
                toolCache:    make(map[string]bool),
                errorHandler: errorHandler,
        }
}</span>

// IsToolAvailable 检查工具是否可用 - 改进版本
func (tm *ToolManager) IsToolAvailable(toolPath string) bool <span class="cov0" title="0">{
        tm.cacheMutex.RLock()
        if available, exists := tm.toolCache[toolPath]; exists </span><span class="cov0" title="0">{
                tm.cacheMutex.RUnlock()
                return available
        }</span>
        <span class="cov0" title="0">tm.cacheMutex.RUnlock()

        // 使用更可靠的工具检查机制
        available := tm.checkTool(toolPath)

        // 缓存结果
        tm.cacheMutex.Lock()
        tm.toolCache[toolPath] = available
        tm.cacheMutex.Unlock()

        return available</span>
}

// checkTool 实际检查工具是否可用
func (tm *ToolManager) checkTool(toolPath string) bool <span class="cov0" title="0">{
        // 使用更短的超时时间
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        // 使用一个更轻量级的命令检查工具可用性
        cmd := exec.CommandContext(ctx, toolPath, "-version")
        err := cmd.Run()

        // 如果-version不可用，尝试使用--version
        if err != nil </span><span class="cov0" title="0">{
                cmd = exec.CommandContext(ctx, toolPath, "--version")
                err = cmd.Run()
        }</span>

        // 如果--version也不可用，尝试使用不带参数的方式
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                cmd = exec.CommandContext(ctx, toolPath)
                err = cmd.Run()
        }</span>

        // 记录工具检查结果
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                tm.logger.Debug("工具不可用", zap.String("tool", toolPath), zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                tm.logger.Debug("工具可用", zap.String("tool", toolPath))
        }</span>

        <span class="cov0" title="0">return err == nil</span>
}

// FindToolInPath 在系统PATH中查找工具
func (tm *ToolManager) FindToolInPath(toolName string) (string, error) <span class="cov0" title="0">{
        path, err := exec.LookPath(toolName)
        if err != nil </span><span class="cov0" title="0">{
                return "", tm.errorHandler.WrapError("tool not found in PATH", err)
        }</span>
        <span class="cov0" title="0">return path, nil</span>
}

// GetAvailableTool 获取可用的工具路径，支持回退机制和自动查找
func (tm *ToolManager) GetAvailableTool(primaryPath, fallbackPath string) (string, error) <span class="cov0" title="0">{
        // 首先检查主工具
        if tm.IsToolAvailable(primaryPath) </span><span class="cov0" title="0">{
                return primaryPath, nil
        }</span>

        // 如果主工具不可用，检查回退工具
        <span class="cov0" title="0">if fallbackPath != "" &amp;&amp; tm.IsToolAvailable(fallbackPath) </span><span class="cov0" title="0">{
                tm.logger.Warn("主工具不可用，使用回退工具",
                        zap.String("primary", primaryPath),
                        zap.String("fallback", fallbackPath))
                return fallbackPath, nil
        }</span>

        // 尝试在系统PATH中查找主工具
        <span class="cov0" title="0">toolName := primaryPath
        // 如果是绝对路径，提取工具名称
        if strings.Contains(primaryPath, "/") </span><span class="cov0" title="0">{
                toolName = primaryPath[strings.LastIndex(primaryPath, "/")+1:]
        }</span>

        <span class="cov0" title="0">if path, err := tm.FindToolInPath(toolName); err == nil </span><span class="cov0" title="0">{
                if tm.IsToolAvailable(path) </span><span class="cov0" title="0">{
                        tm.logger.Info("在系统PATH中找到工具",
                                zap.String("tool", toolName),
                                zap.String("path", path))
                        return path, nil
                }</span>
        }

        // 如果都没有可用工具，返回错误
        <span class="cov0" title="0">var errorBuilder strings.Builder
        errorBuilder.WriteString("no available tool found: primary=")
        errorBuilder.WriteString(primaryPath)
        errorBuilder.WriteString(", fallback=")
        errorBuilder.WriteString(fallbackPath)
        return "", tm.errorHandler.WrapError(errorBuilder.String(), nil)</span>
}

// validateAndNormalizePath 验证并规范化文件路径
func (tm *ToolManager) validateAndNormalizePath(path string) (string, error) <span class="cov0" title="0">{
        // 使用GlobalPathUtils进行路径规范化
        normalizedPath, err := GlobalPathUtils.NormalizePath(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", tm.errorHandler.WrapError("path normalization failed", err)
        }</span>

        // 验证路径是否有效
        <span class="cov0" title="0">if !GlobalPathUtils.ValidatePath(normalizedPath) </span><span class="cov0" title="0">{
                var pathErrorBuilder strings.Builder
                pathErrorBuilder.WriteString("invalid path: ")
                pathErrorBuilder.WriteString(path)
                return "", tm.errorHandler.WrapError(pathErrorBuilder.String(), nil)
        }</span>

        <span class="cov0" title="0">return normalizedPath, nil</span>
}

// ExecuteWithPathValidation 执行工具命令，自动验证和规范化路径参数
func (tm *ToolManager) ExecuteWithPathValidation(toolPath string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        // 对所有参数进行路径验证和规范化
        validatedArgs := make([]string, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                // 检查参数是否看起来像文件路径（包含路径分隔符）
                if strings.Contains(arg, "/") || strings.Contains(arg, "\\") </span><span class="cov0" title="0">{
                        // 尝试规范化路径
                        if normalizedPath, err := tm.validateAndNormalizePath(arg); err == nil </span><span class="cov0" title="0">{
                                validatedArgs[i] = normalizedPath
                                // 路径已规范化
                        }</span> else<span class="cov0" title="0"> {
                                // 如果规范化失败，使用原始路径但记录警告
                                // 路径规范化失败，使用原始路径
                                validatedArgs[i] = arg
                        }</span>
                } else<span class="cov0" title="0"> {
                        validatedArgs[i] = arg
                }</span>
        }

        <span class="cov0" title="0">return tm.Execute(toolPath, validatedArgs...)</span>
}

// Execute 执行单个工具命令，带重试机制和超时控制
func (tm *ToolManager) Execute(toolPath string, args ...string) ([]byte, error) <span class="cov8" title="1">{
        // 最多重试3次
        var output []byte
        var err error

        for i := 0; i &lt; 3; i++ </span><span class="cov8" title="1">{
                // 创建带超时的上下文（30秒超时）
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                cmd := exec.CommandContext(ctx, toolPath, args...)

                output, err = cmd.CombinedOutput()
                cancel() // 立即释放资源

                if err == nil </span><span class="cov8" title="1">{
                        // 工具执行成功
                        if i &gt; 0 </span>{<span class="cov0" title="0">
                                // 工具执行成功（经过重试）
                        }</span>
                        <span class="cov8" title="1">return output, nil</span>
                }

                // 检查是否为context canceled错误，如果是则立即返回不重试
                <span class="cov0" title="0">if errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                        tm.logger.Warn("工具执行被取消",
                                zap.String("tool", toolPath),
                                zap.Error(err))
                        return output, err
                }</span>

                // 检查是否为context deadline exceeded错误，如果是则立即返回不重试
                <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        tm.logger.Warn("工具执行超时",
                                zap.String("tool", toolPath),
                                zap.Error(err))
                        return output, err
                }</span>

                // 只在最后一次重试失败时记录详细日志
                <span class="cov0" title="0">if i == 2 </span><span class="cov0" title="0">{
                        tm.logger.Error("工具执行失败，已达到最大重试次数",
                                zap.String("tool", toolPath),
                                zap.Error(err),
                                zap.String("output", string(output)))
                }</span> else<span class="cov0" title="0"> {
                        // 中间重试只记录简单信息，且只在Debug级别
                        // 工具执行重试
                        // 等待一段时间再重试
                        time.Sleep(time.Duration(i+1) * time.Second)
                }</span>
        }

        <span class="cov0" title="0">return output, err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package converter

import (
        "os/exec"
        "strconv"
        "strings"
)

// VideoInfo 视频信息结构
type VideoInfo struct {
        Duration   float64
        Width      int
        Height     int
        Bitrate    int
        FrameRate  float64
        Codec      string
        AudioCodec string
        HasAudio   bool
        FileSize   int64
}

// getVideoInfo 获取视频信息
func (c *Converter) getVideoInfo(path string) (*VideoInfo, error) <span class="cov0" title="0">{
        // 使用FFprobe获取视频信息
        args := []string{
                "-v", "quiet",
                "-print_format", "compact",
                "-show_entries", "format=duration,size:stream=width,height,r_frame_rate,bit_rate,codec_name,codec_type",
                path,
        }

        cmd := exec.Command(c.config.Tools.FFprobePath, args...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, c.errorHandler.WrapError("ffprobe failed", err)
        }</span>

        <span class="cov0" title="0">info := &amp;VideoInfo{}
        outputStr := string(output)
        lines := strings.Split(outputStr, "\n")

        // 解析compact格式输出
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "format|") </span><span class="cov0" title="0">{
                        // 解析format行: format|duration=10.5|size=1024000
                        parts := strings.Split(line, "|")
                        for _, part := range parts </span><span class="cov0" title="0">{
                                if strings.HasPrefix(part, "duration=") </span><span class="cov0" title="0">{
                                        info.Duration = parseFloat(strings.TrimPrefix(part, "duration="))
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(part, "size=") </span><span class="cov0" title="0">{
                                        info.FileSize = int64(parseInt(strings.TrimPrefix(part, "size=")))
                                }</span>
                        }
                } else<span class="cov0" title="0"> if strings.Contains(line, "stream|") </span><span class="cov0" title="0">{
                        // 解析stream行
                        parts := strings.Split(line, "|")
                        codecType := ""
                        for _, part := range parts </span><span class="cov0" title="0">{
                                if strings.HasPrefix(part, "codec_type=") </span><span class="cov0" title="0">{
                                        codecType = strings.TrimPrefix(part, "codec_type=")
                                }</span>
                        }

                        <span class="cov0" title="0">switch codecType </span>{
                        case "video":<span class="cov0" title="0">
                                for _, part := range parts </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(part, "width=") </span><span class="cov0" title="0">{
                                                info.Width = parseInt(strings.TrimPrefix(part, "width="))
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(part, "height=") </span><span class="cov0" title="0">{
                                                info.Height = parseInt(strings.TrimPrefix(part, "height="))
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(part, "r_frame_rate=") </span><span class="cov0" title="0">{
                                                frameRateStr := strings.TrimPrefix(part, "r_frame_rate=")
                                                if strings.Contains(frameRateStr, "/") </span><span class="cov0" title="0">{
                                                        frameParts := strings.Split(frameRateStr, "/")
                                                        if len(frameParts) == 2 </span><span class="cov0" title="0">{
                                                                num := parseFloat(frameParts[0])
                                                                den := parseFloat(frameParts[1])
                                                                if den &gt; 0 </span><span class="cov0" title="0">{
                                                                        info.FrameRate = num / den
                                                                }</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        info.FrameRate = parseFloat(frameRateStr)
                                                }</span>
                                        } else<span class="cov0" title="0"> if strings.HasPrefix(part, "bit_rate=") </span><span class="cov0" title="0">{
                                                info.Bitrate = parseInt(strings.TrimPrefix(part, "bit_rate=")) / 1000 // 转换为kbps
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(part, "codec_name=") </span><span class="cov0" title="0">{
                                                info.Codec = strings.TrimPrefix(part, "codec_name=")
                                        }</span>
                                }
                        case "audio":<span class="cov0" title="0">
                                info.HasAudio = true
                                for _, part := range parts </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(part, "codec_name=") </span><span class="cov0" title="0">{
                                                info.AudioCodec = strings.TrimPrefix(part, "codec_name=")
                                        }</span>
                                }
                        }
                }
        }

        // 设置默认值（如果解析失败）
        <span class="cov0" title="0">if info.Duration == 0 </span><span class="cov0" title="0">{
                info.Duration = 10.0
        }</span>
        <span class="cov0" title="0">if info.Width == 0 </span><span class="cov0" title="0">{
                info.Width = 1920
        }</span>
        <span class="cov0" title="0">if info.Height == 0 </span><span class="cov0" title="0">{
                info.Height = 1080
        }</span>
        <span class="cov0" title="0">if info.FrameRate == 0 </span><span class="cov0" title="0">{
                info.FrameRate = 30.0
        }</span>
        <span class="cov0" title="0">if info.Codec == "" </span><span class="cov0" title="0">{
                info.Codec = "h264"
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}

// needsOptimization 判断是否需要优化
func (c *Converter) needsOptimization(info *VideoInfo) bool <span class="cov0" title="0">{
        // 检查是否需要优化的条件

        // 如果码率过高
        if info.Bitrate &gt; 5000 </span><span class="cov0" title="0">{
                return true
        }</span>

        // 如果分辨率过高但文件较小（可能质量不好）
        <span class="cov0" title="0">if info.Width &gt; 1920 &amp;&amp; info.FileSize &lt; 10*1024*1024 </span><span class="cov0" title="0">{
                return true
        }</span>

        // 如果使用较老的编码器
        <span class="cov0" title="0">if info.Codec != "h264" &amp;&amp; info.Codec != "h265" &amp;&amp; info.Codec != "vp9" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// VideoConversionConfig 视频转换配置
type VideoConversionConfig struct {
        OutputExt    string
        VideoCodec   string
        AudioCodec   string
        CRF          *int
        Preset       string
        AudioBitrate string
        ExtraArgs    []string
        CopyStreams  bool // 是否直接复制流（重包装模式）
}

// executeVideoConversion 统一的视频转换执行函数
func (c *Converter) executeVideoConversion(file *MediaFile, config VideoConversionConfig) (string, error) <span class="cov0" title="0">{
        outputPath := c.getOutputPath(file, config.OutputExt)

        args := []string{"-i", file.Path}

        if config.CopyStreams </span><span class="cov0" title="0">{
                // 重包装模式：直接复制流
                args = append(args, "-c:v", "copy", "-c:a", "copy")
        }</span> else<span class="cov0" title="0"> {
                // 重新编码模式
                if config.VideoCodec != "" </span><span class="cov0" title="0">{
                        args = append(args, "-c:v", config.VideoCodec)
                }</span>
                <span class="cov0" title="0">if config.CRF != nil </span><span class="cov0" title="0">{
                        var crfBuilder strings.Builder
                        crfBuilder.WriteString(strconv.Itoa(*config.CRF))
                        args = append(args, "-crf", crfBuilder.String())
                }</span>
                <span class="cov0" title="0">if config.Preset != "" </span><span class="cov0" title="0">{
                        args = append(args, "-preset", config.Preset)
                }</span>
                <span class="cov0" title="0">if config.AudioCodec != "" </span><span class="cov0" title="0">{
                        args = append(args, "-c:a", config.AudioCodec)
                }</span>
                <span class="cov0" title="0">if config.AudioBitrate != "" </span><span class="cov0" title="0">{
                        args = append(args, "-b:a", config.AudioBitrate)
                }</span>
        }

        // 添加额外参数
        <span class="cov0" title="0">args = append(args, config.ExtraArgs...)
        args = append(args, "-y", outputPath)

        // Executing video conversion

        cmd := exec.Command(c.config.Tools.FFmpegPath, args...)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapErrorWithOutput("video conversion failed", err, output)
        }</span>

        <span class="cov0" title="0">return outputPath, nil</span>
}

// isCodecCompatibleWithMOV 检查编码格式是否与MOV容器兼容
func (c *Converter) isCodecCompatibleWithMOV(videoInfo *VideoInfo) bool <span class="cov0" title="0">{
        // VP8编码不支持MOV容器
        if strings.Contains(strings.ToLower(videoInfo.Codec), "vp8") </span><span class="cov0" title="0">{
                return false
        }</span>

        // VP9编码在某些情况下不支持MOV容器
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(videoInfo.Codec), "vp9") </span><span class="cov0" title="0">{
                return false
        }</span>

        // AV1编码只支持MP4和AVIF容器
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(videoInfo.Codec), "av01") ||
                strings.Contains(strings.ToLower(videoInfo.Codec), "av1") </span><span class="cov0" title="0">{
                return false
        }</span>

        // 其他常见编码格式（H.264, H.265, MPEG-4等）支持MOV容器
        <span class="cov0" title="0">return true</span>
}

// convertToMOV 转换为MOV格式（重包装方式，不重新编码）
func (c *Converter) convertToMOV(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 首先获取视频信息以检查编码兼容性
        videoInfo, err := c.getVideoInfo(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapError("failed to get video info for compatibility check", err)
        }</span>

        // 检查编码格式是否与MOV容器兼容
        <span class="cov0" title="0">if !c.isCodecCompatibleWithMOV(videoInfo) </span><span class="cov0" title="0">{
                // Skipping video conversion due to codec incompatibility

                // 返回原文件路径，表示跳过转换
                return file.Path, nil
        }</span>

        // 检查是否为原地转换
        <span class="cov0" title="0">isInPlace := c.config.Output.DirectoryTemplate == ""
        outputPath := c.getOutputPath(file, ".mov")
        
        // 如果是原地转换，需要使用临时文件
        if isInPlace </span><span class="cov0" title="0">{
                tempOutput := outputPath + ".tmp"
                defer func() </span><span class="cov0" title="0">{
                        if err := c.fileOpHandler.SafeRemoveFile(tempOutput); err != nil </span>{<span class="cov0" title="0">
                                // 清理临时文件
                        }</span>
                }()
                
                <span class="cov0" title="0">config := VideoConversionConfig{
                        OutputExt:   ".tmp",
                        CopyStreams: true,
                        ExtraArgs:   []string{"-movflags", "+faststart"},
                }
                
                // 先转换到临时文件
                _, err := c.executeVideoConversion(file, config)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                
                // 然后原子替换
                <span class="cov0" title="0">if err := c.fileOpHandler.AtomicFileReplace(tempOutput, outputPath, true); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                
                <span class="cov0" title="0">return outputPath, nil</span>
        }

        // 非原地转换
        <span class="cov0" title="0">config := VideoConversionConfig{
                OutputExt:   ".mov",
                CopyStreams: true,
                ExtraArgs:   []string{"-movflags", "+faststart"},
        }
        return c.executeVideoConversion(file, config)</span>
}

// optimizeMOV 优化MOV文件（重包装方式）
func (c *Converter) optimizeMOV(file *MediaFile) (string, error) <span class="cov0" title="0">{
        // 首先获取视频信息以检查编码兼容性
        videoInfo, err := c.getVideoInfo(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapError("failed to get video info for optimization compatibility check", err)
        }</span>

        // 检查编码格式是否与MOV容器兼容
        <span class="cov0" title="0">if !c.isCodecCompatibleWithMOV(videoInfo) </span><span class="cov0" title="0">{
                // Skipping MOV optimization due to codec incompatibility

                // 返回原文件路径，表示跳过优化
                return file.Path, nil
        }</span>

        <span class="cov0" title="0">config := VideoConversionConfig{
                OutputExt:   ".mov",
                CopyStreams: true,
                ExtraArgs:   []string{"-movflags", "+faststart"},
        }
        return c.executeVideoConversion(file, config)</span>
}

// convertToEmojiVideo 转换为表情包视频
// convertToEmojiVideo 已删除 - 表情包模式不处理视频文件

// 辅助函数

// parseFloat 安全解析浮点数
func parseFloat(s string) float64 <span class="cov0" title="0">{
        f, err := strconv.ParseFloat(s, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov0" title="0">return f</span>
}

// parseInt 安全解析整数
func parseInt(s string) int <span class="cov0" title="0">{
        i, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return i</span>
}

// getVideoBitrate 计算视频目标码率

// getVideoFPS 获取视频帧率
func (c *Converter) getVideoFPS(path string) (float64, error) <span class="cov0" title="0">{
        info, err := c.getVideoInfo(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return info.FrameRate, nil</span>
}

// 为策略系统提供的方法

// convertVideoContainer 视频容器转换（为策略系统提供）
func (c *Converter) convertVideoContainer(file *MediaFile) (string, error) <span class="cov0" title="0">{
        ext := strings.ToLower(file.Extension)

        // 根据用户要求：如果已经是目标格式即 avif jxl mov 则全部跳过 不进行更多检查 扫描 处理等行为
        if ext == ".avif" || ext == ".jxl" || ext == ".mov" </span><span class="cov0" title="0">{
                // 直接返回原文件路径，跳过所有处理
                return file.Path, nil
        }</span>

        // 根据README规定：所有视频格式都转换为MOV格式（重包装方式）
        <span class="cov0" title="0">videoInfo, err := c.getVideoInfo(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                return "", c.errorHandler.WrapError("failed to get video info", err)
        }</span>

        // 检查编码格式是否与MOV容器兼容
        <span class="cov0" title="0">if !c.isCodecCompatibleWithMOV(videoInfo) </span><span class="cov0" title="0">{
                // Skipping video conversion due to codec incompatibility

                // 返回原文件路径，表示跳过转换
                return file.Path, nil
        }</span>

        // 所有其他视频格式转换为MOV（重包装方式）
        <span class="cov0" title="0">return c.convertToMOV(file)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package converter

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "runtime"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// WatchdogMode 看门狗模式枚举
type WatchdogMode int

const (
        ModeUserInteraction WatchdogMode = iota // 用户交互模式（弱作用）

)

// WatchdogConfig 看门狗配置
type WatchdogConfig struct {
        // 进度停滞检测时间（秒）
        StagnantTimeout int
        // 大文件处理超时时间（秒）
        LargeFileTimeout int
        // 大文件阈值（MB）
        LargeFileThreshold int64
        // 单个文件处理超时时间（秒）
        FileProcessingTimeout int
        // 是否启用看门狗
        Enabled bool
        // 看门狗模式
        Mode WatchdogMode

        // 内存使用限制（MB）
        MemoryLimit int
}

// ProgressWatchdog 进度看门狗
type ProgressWatchdog struct {
        config *WatchdogConfig
        logger *zap.Logger

        // 进度跟踪
        lastProgress    float64
        lastUpdateTime  time.Time
        currentFile     string
        currentFileSize int64

        // 文件处理超时控制
        fileStartTime     time.Time
        fileTimeoutCancel context.CancelFunc
        fileTimeoutCtx    context.Context

        // 控制信号
        ctx     context.Context
        cancel  context.CancelFunc
        stopped chan struct{}

        // 用户交互
        userResponseChan chan string

        // 线程安全
        mutex sync.RWMutex
}

// NewProgressWatchdog 创建进度看门狗
func NewProgressWatchdog(config *WatchdogConfig, logger *zap.Logger) *ProgressWatchdog <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;ProgressWatchdog{
                config:           config,
                logger:           logger,
                ctx:              ctx,
                cancel:           cancel,
                stopped:          make(chan struct{}),
                userResponseChan: make(chan string, 1),
                lastUpdateTime:   time.Now(),
        }
}</span>

// Start 启动看门狗
func (w *ProgressWatchdog) Start() <span class="cov8" title="1">{
        if !w.config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // 启动进度看门狗

        <span class="cov8" title="1">go w.monitor()</span>
}

// Stop 停止看门狗
func (w *ProgressWatchdog) Stop() <span class="cov8" title="1">{
        w.cancel()
        select </span>{
        case &lt;-w.stopped:<span class="cov8" title="1"></span>
                // 看门狗已停止
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                w.logger.Warn("看门狗停止超时")</span>
        }
}

// UpdateProgress 更新进度
func (w *ProgressWatchdog) UpdateProgress(progress float64, currentFile string, fileSize int64) <span class="cov0" title="0">{
        if !w.config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">w.mutex.Lock()
        defer w.mutex.Unlock()

        // 检查是否是新文件
        if currentFile != w.currentFile </span><span class="cov0" title="0">{
                // 取消之前的文件超时
                if w.fileTimeoutCancel != nil </span><span class="cov0" title="0">{
                        w.fileTimeoutCancel()
                }</span>

                // 为新文件设置超时
                <span class="cov0" title="0">if w.config.FileProcessingTimeout &gt; 0 </span><span class="cov0" title="0">{
                        w.fileTimeoutCtx, w.fileTimeoutCancel = context.WithTimeout(w.ctx, time.Duration(w.config.FileProcessingTimeout)*time.Second)
                        go w.fileTimeoutMonitor(currentFile)
                }</span>

                // 更新文件开始时间
                <span class="cov0" title="0">w.fileStartTime = time.Now()</span>
        }

        // 检查进度是否有实质性变化
        // 修改检查条件，允许更小的进度更新，避免进度条看起来卡住
        // 同时确保100%进度能被正确更新
        <span class="cov0" title="0">if progress &gt; w.lastProgress+0.001 || progress == 100 || currentFile != w.currentFile </span><span class="cov0" title="0">{ // 进度需要至少增加0.001%就算有效更新，或者达到100%
                w.lastProgress = progress
                w.lastUpdateTime = time.Now()
                w.currentFile = currentFile
                w.currentFileSize = fileSize

                // 看门狗进度更新

                // 如果文件处理完成（100%），取消该文件的超时监控
                if progress &gt;= 100 </span><span class="cov0" title="0">{
                        if w.fileTimeoutCancel != nil </span><span class="cov0" title="0">{
                                w.fileTimeoutCancel()
                                w.fileTimeoutCancel = nil
                        }</span>
                        // 文件处理完成，取消超时监控
                }
        }
}

// fileTimeoutMonitor 文件处理超时监控
func (w *ProgressWatchdog) fileTimeoutMonitor(currentFile string) <span class="cov0" title="0">{
        &lt;-w.fileTimeoutCtx.Done()

        // 检查是否是正常完成还是超时
        if w.fileTimeoutCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                w.mutex.Lock()
                // 检查是否仍在处理同一个文件
                if w.currentFile == currentFile </span><span class="cov0" title="0">{
                        w.mutex.Unlock()

                        // 触发文件处理超时处理
                        w.handleFileTimeout(currentFile)
                        return
                }</span>
                <span class="cov0" title="0">w.mutex.Unlock()</span>
        }
}

// handleStagnation 处理进度停滞
func (w *ProgressWatchdog) handleStagnation(currentFile string, duration time.Duration, isLargeFile bool) <span class="cov0" title="0">{
        // 根据看门狗模式采取不同行动
        switch w.config.Mode </span>{
        case ModeUserInteraction:<span class="cov0" title="0">
                // 用户交互场景（弱作用）：分层次处理不同严重程度的停滞
                stagnantTimeout := time.Duration(w.config.StagnantTimeout) * time.Second

                // 轻微停滞：仅记录日志
                if duration &lt;= stagnantTimeout </span><span class="cov0" title="0">{
                        // 进度轻微停滞（用户交互模式）
                        return
                }</span>

                // 中等停滞：提供更多警告信息
                <span class="cov0" title="0">if duration &lt;= stagnantTimeout*2 </span><span class="cov0" title="0">{
                        w.logger.Warn("⚠️  进度中等停滞，可能需要关注",
                                zap.String("current_file", currentFile),
                                zap.Duration("stagnant_duration", duration),
                                zap.Bool("is_large_file", isLargeFile))

                        // 对于大文件，提供更多上下文信息
                        if isLargeFile </span>{<span class="cov0" title="0">
                                // 提示：正在处理大文件，可能需要更多时间
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // 严重停滞：提供更多操作选项
                <span class="cov0" title="0">if duration &lt;= stagnantTimeout*3 </span><span class="cov0" title="0">{
                        w.logger.Error("🚨 进度严重停滞，建议检查系统资源",
                                zap.String("current_file", currentFile),
                                zap.Duration("stagnant_duration", duration),
                                zap.Bool("is_large_file", isLargeFile))

                        // 提供系统资源信息
                        var m runtime.MemStats
                        runtime.ReadMemStats(&amp;m)
                        // 系统资源使用情况
                        return
                }</span>

                // 极端停滞：询问用户是否需要强制退出
                <span class="cov0" title="0">w.logger.Warn("⚠️  检测到极端进度停滞，询问用户是否需要强制退出",
                        zap.String("current_file", currentFile),
                        zap.Duration("stagnant_duration", duration),
                        zap.Bool("is_large_file", isLargeFile))

                // 在用户交互模式下询问用户
                if w.askUserForAction("检测到程序可能已卡死，是否需要强制退出？(y/N): ") </span><span class="cov0" title="0">{
                        w.logger.Fatal("用户选择强制退出程序")
                        os.Exit(1)
                }</span> else<span class="cov0" title="0"> {
                        // 用户选择继续，重置计时器
                        w.mutex.Lock()
                        w.lastUpdateTime = time.Now()
                        w.mutex.Unlock()
                        // 用户选择继续执行
                }</span>
        default:<span class="cov0" title="0"></span>
                // 默认情况：仅记录日志
                // 进度停滞检测（默认模式）
        }

        // 重置计时器，继续处理
        <span class="cov0" title="0">w.mutex.Lock()
        w.lastUpdateTime = time.Now()
        w.mutex.Unlock()</span>
}

// handleFileTimeout 处理文件处理超时
func (w *ProgressWatchdog) handleFileTimeout(currentFile string) <span class="cov0" title="0">{
        // 根据看门狗模式采取不同行动
        switch w.config.Mode </span>{
        case ModeUserInteraction:<span class="cov0" title="0">
                // 用户交互场景（弱作用）：提供更多上下文信息
                w.logger.Warn("⏰ 文件处理超时（用户交互模式）",
                        zap.String("current_file", currentFile),
                        zap.Duration("timeout", time.Duration(w.config.FileProcessingTimeout)*time.Second))

                // 提供文件大小信息
                // 文件信息

                // 提供系统资源信息
                var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)</span>
                // 系统资源使用情况
        default:<span class="cov0" title="0">
                // 默认情况：记录警告
                w.logger.Warn("⏰ 文件处理超时（默认模式）",
                        zap.String("current_file", currentFile),
                        zap.Duration("timeout", time.Duration(w.config.FileProcessingTimeout)*time.Second))</span>
        }
}

// askUserForAction 询问用户是否执行某个操作
func (w *ProgressWatchdog) askUserForAction(prompt string) bool <span class="cov0" title="0">{
        fmt.Print(prompt)
        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))
        return response == "y" || response == "yes"</span>
}

// monitor 监控主循环
func (w *ProgressWatchdog) monitor() <span class="cov8" title="1">{
        defer close(w.stopped)

        // 根据模式设置检查频率
        var ticker *time.Ticker
        // 用户模式下每10秒检查一次
        ticker = time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        // 添加内存监控
        memTicker := time.NewTicker(30 * time.Second)
        defer memTicker.Stop()

        // 添加系统资源压力检查（每分钟检查一次）
        resourceTicker := time.NewTicker(60 * time.Second)
        defer resourceTicker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.ctx.Done():<span class="cov8" title="1">
                        // 取消文件超时
                        if w.fileTimeoutCancel != nil </span><span class="cov0" title="0">{
                                w.fileTimeoutCancel()
                        }</span>
                        <span class="cov8" title="1">return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // 进度停滞检查
                        w.checkStagnation()</span>
                case &lt;-memTicker.C:<span class="cov0" title="0">
                        // 内存使用检查
                        w.checkMemoryUsage()</span>
                case &lt;-resourceTicker.C:<span class="cov0" title="0">
                        // 系统资源压力检查
                        // 这里可以添加更复杂的系统资源检查逻辑
                        var m runtime.MemStats
                        runtime.ReadMemStats(&amp;m)
                        memLimitMB := uint64(w.config.MemoryLimit)
                        currentMB := m.Alloc / (1024 * 1024)

                        // 如果内存使用超过限制的90%，处理资源压力
                        if memLimitMB &gt; 0 &amp;&amp; currentMB &gt; memLimitMB*90/100 </span><span class="cov0" title="0">{
                                w.handleSystemResourcePressure()
                        }</span>
                }
        }
}

// checkMemoryUsage 检查内存使用情况
func (w *ProgressWatchdog) checkMemoryUsage() <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        // 检查是否超过配置的内存限制
        memLimitMB := uint64(w.config.MemoryLimit)
        currentMB := m.Alloc / (1024 * 1024)

        // 在所有模式下都记录内存使用情况（但级别不同）
        switch w.config.Mode </span>{
        case ModeUserInteraction:<span class="cov0" title="0">
                // 内存使用情况（用户模式）

                // 用户模式下，如果内存使用超过限制的80%，给出警告
                if memLimitMB &gt; 0 &amp;&amp; currentMB &gt; memLimitMB*80/100 </span><span class="cov0" title="0">{
                        w.logger.Warn("⚠️  内存使用接近限制",
                                zap.Uint64("current_mb", currentMB),
                                zap.Uint64("limit_mb", memLimitMB),
                                zap.Uint64("threshold_mb", memLimitMB*80/100))

                        // 如果内存使用超过限制的95%，提供更强烈的警告
                        if currentMB &gt; memLimitMB*95/100 </span><span class="cov0" title="0">{
                                w.logger.Error("🚨 内存使用严重接近限制，建议释放资源",
                                        zap.Uint64("current_mb", currentMB),
                                        zap.Uint64("limit_mb", memLimitMB))
                        }</span>
                }
        default:<span class="cov0" title="0"></span>
                // 内存使用情况（默认模式）
        }
}

// SetMemoryLimit 设置内存限制（MB）
func (w *ProgressWatchdog) SetMemoryLimit(limit int) <span class="cov0" title="0">{
        w.config.MemoryLimit = limit
}</span>

// handleSystemResourcePressure 处理系统资源紧张情况
func (w *ProgressWatchdog) handleSystemResourcePressure() <span class="cov0" title="0">{
        // 根据模式采取不同行动
        switch w.config.Mode </span>{
        case ModeUserInteraction:<span class="cov0" title="0">
                // 用户交互模式：记录警告并提供优化建议
                w.logger.Warn("⚠️  系统资源紧张，建议优化处理")

                // 提供优化建议
                // 优化建议

                // 询问用户是否需要自动调整
                if w.askUserForAction("是否需要自动减少并发处理数量以释放资源？(y/N): ") </span>{<span class="cov0" title="0">
                        // 这里可以添加自动调整逻辑
                        // 已建议用户手动优化系统资源
                }</span>
        default:<span class="cov0" title="0"></span>
                // 默认模式：仅记录信息
                // 系统资源使用情况
        }
}

// checkStagnation 检查进度停滞
func (w *ProgressWatchdog) checkStagnation() <span class="cov0" title="0">{
        w.mutex.RLock()
        lastUpdate := w.lastUpdateTime
        currentFile := w.currentFile
        fileSize := w.currentFileSize
        progress := w.lastProgress
        w.mutex.RUnlock()

        if currentFile == "" </span><span class="cov0" title="0">{
                return // 还没有开始处理文件
        }</span>

        // 如果文件已经处理完成（100%），跳过停滞检测
        <span class="cov0" title="0">if progress &gt;= 100 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">stagnantDuration := time.Since(lastUpdate)
        isLargeFile := fileSize &gt; w.config.LargeFileThreshold*1024*1024

        // 根据文件大小选择不同的超时策略
        var timeout time.Duration
        if isLargeFile </span><span class="cov0" title="0">{
                timeout = time.Duration(w.config.LargeFileTimeout) * time.Second
                // 检测大文件处理
        }</span> else<span class="cov0" title="0"> {
                timeout = time.Duration(w.config.StagnantTimeout) * time.Second
        }</span>

        <span class="cov0" title="0">if stagnantDuration &gt; timeout </span><span class="cov0" title="0">{
                // 检测到进度停滞

                // 处理进度停滞
                w.handleStagnation(currentFile, stagnantDuration, isLargeFile)
        }</span>
}

// GetDefaultWatchdogConfig 获取默认看门狗配置
func GetDefaultWatchdogConfig() *WatchdogConfig <span class="cov8" title="1">{
        return &amp;WatchdogConfig{
                StagnantTimeout:       60,   // 进度停滞检测时间：用户模式60秒
                LargeFileTimeout:      180,  // 大文件处理超时：用户模式180秒
                LargeFileThreshold:    50,   // 50MB以上视为大文件
                FileProcessingTimeout: 120,  // 单个文件处理超时：用户模式120秒
                MemoryLimit:           8192, // 默认内存限制：8GB
                Enabled:               true,
                Mode:                  ModeUserInteraction, // 默认为用户交互模式
        }
}</span>

// GetEnhancedUserWatchdogConfig 获取增强的用户交互看门狗配置
func GetEnhancedUserWatchdogConfig() *WatchdogConfig <span class="cov0" title="0">{
        return &amp;WatchdogConfig{
                StagnantTimeout:       60,   // 进度停滞检测时间：用户模式60秒
                LargeFileTimeout:      180,  // 大文件处理超时：用户模式180秒
                LargeFileThreshold:    50,   // 50MB以上视为大文件
                FileProcessingTimeout: 120,  // 单个文件处理超时：用户模式120秒
                MemoryLimit:           8192, // 默认内存限制：8GB
                Enabled:               true,
                Mode:                  ModeUserInteraction, // 用户交互模式
        }
}</span>

// GetExtremeCaseWatchdogConfig 获取极端情况处理看门狗配置
func GetExtremeCaseWatchdogConfig() *WatchdogConfig <span class="cov0" title="0">{
        return &amp;WatchdogConfig{
                StagnantTimeout:       30,   // 进度停滞检测时间：30秒
                LargeFileTimeout:      90,   // 大文件处理超时：90秒
                LargeFileThreshold:    50,   // 50MB以上视为大文件
                FileProcessingTimeout: 60,   // 单个文件处理超时：60秒
                MemoryLimit:           4096, // 内存限制：4GB
                Enabled:               true,
                Mode:                  ModeUserInteraction, // 用户交互模式但更敏感
        }
}</span>


</pre>
		
		<pre class="file" id="file21" style="display: none">package converter

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/panjf2000/ants/v2"
        "go.uber.org/zap"
)

// WorkerSignals 工作器信号接口，借鉴xl-converter的信号机制
type WorkerSignals interface {
        OnStarted(workerID int, file *MediaFile)
        OnCompleted(workerID int, file *MediaFile, result *ConversionResult)
        OnFailed(workerID int, file *MediaFile, err error)
        OnCanceled(workerID int, file *MediaFile)
}

// TimestampMap 泛型时间戳映射
type TimestampMap[T any] struct {
        data map[string]T
        mu   sync.RWMutex
}

// NewTimestampMap 创建新的时间戳映射
func NewTimestampMap[T any]() *TimestampMap[T] <span class="cov0" title="0">{
        return &amp;TimestampMap[T]{
                data: make(map[string]T),
        }
}</span>

// Set 设置时间戳值
func (tm *TimestampMap[T]) Set(key string, value T) <span class="cov0" title="0">{
        tm.mu.Lock()
        defer tm.mu.Unlock()
        tm.data[key] = value
}</span>

// Get 获取时间戳值
func (tm *TimestampMap[T]) Get(key string) (T, bool) <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        value, exists := tm.data[key]
        return value, exists
}</span>

// Len 返回映射中元素的数量
func (tm *TimestampMap[T]) Len() int <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        return len(tm.data)
}</span>

// GetAll 获取所有时间戳
func (tm *TimestampMap[T]) GetAll() map[string]T <span class="cov0" title="0">{
        tm.mu.RLock()
        defer tm.mu.RUnlock()
        result := make(map[string]T)
        for k, v := range tm.data </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// PoolStats 工作池统计信息
type PoolStats struct {
        ActiveWorkers  int32 `json:"active_workers"`
        CompletedTasks int64 `json:"completed_tasks"`
        FailedTasks    int64 `json:"failed_tasks"`
        CanceledTasks  int64 `json:"canceled_tasks"`
        PoolCapacity   int   `json:"pool_capacity"`
        PoolRunning    int   `json:"pool_running"`
        PoolFree       int   `json:"pool_free"`
}

// WorkerTask 工作器任务，借鉴xl-converter的Worker结构
type WorkerTask struct {
        ID       int
        File     *MediaFile
        Params   *ConversionParams
        Settings *ConversionSettings
        Mutex    *sync.RWMutex
        Logger   *zap.Logger
        Signals  WorkerSignals
        Ctx      context.Context

        // 任务状态
        StartTime time.Time
        Skip      bool
        Canceled  bool

        // 转换相关
        OutputPath    string
        TempFiles     []string
        SrcTimestamps *TimestampMap[any]
        LosslessJPEG  bool
}

// ConversionParams 转换参数
type ConversionParams struct {
        Format            string
        Quality           int
        Effort            int
        Lossless          bool
        KeepMetadata      bool
        KeepTimestamps    bool
        Downscaling       *DownscalingParams
        IntelligentEffort bool
        JXLModular        bool
}

// DownscalingParams 缩放参数
type DownscalingParams struct {
        Enabled      bool
        Mode         string
        FileSize     int64
        Percent      float64
        Width        int
        Height       int
        ShortestSide int
        LongestSide  int
        Megapixels   float64
        Resample     string
}

// ConversionSettings 转换设置
type ConversionSettings struct {
        JXLAutoLosslessJPEG bool
        AVIFEncoder         string
        JPGEncoder          string
        EnableCustomArgs    bool
        CustomArgs          map[string]string
        Threads             int
}

// ResourceManager 资源管理器，借鉴xl-converter的RAMOptimizer
type ResourceManager struct {
        enabled           bool
        usedThreadCount   int
        optimizationRules []OptimizationRule
        mutex             sync.RWMutex
}

// OptimizationRule 优化规则
type OptimizationRule struct {
        Scope     string  // "all", "JXL", "AVIF", "JPEG"
        Threshold float64 // 激活阈值（兆像素）
        Target    string  // 目标并发数（"1" 或分数如 "1/2"）
}

// ThreadManager 线程管理器，借鉴xl-converter的ThreadManager
type ThreadManager struct {
        threadsPerWorker int
        burstThreadPool  []int
        resourceManager  *ResourceManager
        mutex            sync.RWMutex
}

// EnhancedWorkerPool 增强的工作器池，整合xl-converter的工作器模式
type EnhancedWorkerPool struct {
        pool            *ants.Pool
        logger          *zap.Logger
        errorHandler    *ErrorHandler
        ctx             context.Context
        cancel          context.CancelFunc
        mutex           sync.RWMutex
        signals         WorkerSignals
        threadManager   *ThreadManager
        resourceManager *ResourceManager

        // 统计信息
        activeWorkers  int32
        completedTasks int64
        failedTasks    int64
        canceledTasks  int64

        // 任务监控
        taskMonitor *TaskMonitor

        // 配置
        maxWorkers      int
        taskTimeout     time.Duration
        cleanupInterval time.Duration

        // 清理相关
        cleanupTicker  *time.Ticker
        tempFiles      map[string][]string // workerID -&gt; temp files
        tempFilesMutex sync.RWMutex
}

// NewResourceManager 创建资源管理器
func NewResourceManager() *ResourceManager <span class="cov0" title="0">{
        return &amp;ResourceManager{
                enabled:           false,
                usedThreadCount:   runtime.NumCPU(),
                optimizationRules: make([]OptimizationRule, 0),
        }
}</span>

// SetEnabled 设置资源管理器启用状态
func (rm *ResourceManager) SetEnabled(enabled bool) <span class="cov0" title="0">{
        rm.mutex.Lock()
        defer rm.mutex.Unlock()
        rm.enabled = enabled
}</span>

// IsEnabled 检查资源管理器是否启用
func (rm *ResourceManager) IsEnabled() bool <span class="cov0" title="0">{
        rm.mutex.RLock()
        defer rm.mutex.RUnlock()
        return rm.enabled
}</span>

// SetUsedThreadCount 设置使用的线程数
func (rm *ResourceManager) SetUsedThreadCount(count int) <span class="cov0" title="0">{
        rm.mutex.Lock()
        defer rm.mutex.Unlock()
        if count &lt; 1 </span><span class="cov0" title="0">{
                count = 1
        }</span>
        <span class="cov0" title="0">rm.usedThreadCount = count</span>
}

// IsNecessary 检查是否需要资源优化，借鉴xl-converter的逻辑
func (rm *ResourceManager) IsNecessary(format string, effort int, lossless bool) bool <span class="cov0" title="0">{
        // JXL高内存使用场景
        if format == "JXL" &amp;&amp; (effort &gt;= 7 || lossless) </span><span class="cov0" title="0">{
                return true
        }</span>
        // AVIF高质量编码
        <span class="cov0" title="0">if format == "AVIF" &amp;&amp; effort &gt;= 8 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// NewThreadManager 创建线程管理器
func NewThreadManager(resourceManager *ResourceManager) *ThreadManager <span class="cov0" title="0">{
        return &amp;ThreadManager{
                threadsPerWorker: 1,
                burstThreadPool:  make([]int, 0),
                resourceManager:  resourceManager,
        }
}</span>

// Configure 配置线程管理器，借鉴xl-converter的configure方法
func (tm *ThreadManager) Configure(itemCount, usedThreadCount int, format string, effort int, lossless bool) <span class="cov0" title="0">{
        tm.mutex.Lock()
        defer tm.mutex.Unlock()

        singleWorkerMode := false
        tm.resourceManager.SetEnabled(false)

        // 检查是否需要资源优化
        if tm.resourceManager.IsNecessary(format, effort, lossless) </span><span class="cov0" title="0">{
                singleWorkerMode = true
                tm.resourceManager.SetEnabled(true)
                tm.resourceManager.SetUsedThreadCount(usedThreadCount)
        }</span>

        // 设置工作器配置
        <span class="cov0" title="0">if singleWorkerMode </span><span class="cov0" title="0">{
                tm.burstThreadPool = make([]int, 0)
                tm.threadsPerWorker = usedThreadCount
        }</span> else<span class="cov0" title="0"> {
                tm.burstThreadPool = tm.getBurstThreadPool(itemCount, usedThreadCount)
                tm.threadsPerWorker = 1
        }</span>
}

// GetAvailableThreads 获取可用线程数
func (tm *ThreadManager) GetAvailableThreads(index int) int <span class="cov0" title="0">{
        tm.mutex.RLock()
        defer tm.mutex.RUnlock()

        if len(tm.burstThreadPool) &gt; 0 &amp;&amp; index &lt; len(tm.burstThreadPool) </span><span class="cov0" title="0">{
                return tm.burstThreadPool[index]
        }</span>
        <span class="cov0" title="0">return tm.threadsPerWorker</span>
}

// getBurstThreadPool 分配突发线程池，借鉴xl-converter的算法
func (tm *ThreadManager) getBurstThreadPool(workers, cores int) []int <span class="cov0" title="0">{
        if workers &gt;= cores || cores &lt; 1 || workers &lt; 1 </span><span class="cov0" title="0">{
                return make([]int, 0)
        }</span>

        <span class="cov0" title="0">baseThreads := cores / workers
        extraThreads := cores % workers
        threadPool := make([]int, workers)

        for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                threadPool[i] = baseThreads
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; extraThreads; i++ </span><span class="cov0" title="0">{
                threadPool[i]++
        }</span>

        <span class="cov0" title="0">return threadPool</span>
}

// NewEnhancedWorkerPool 创建增强的工作器池
func NewEnhancedWorkerPool(maxWorkers int, logger *zap.Logger, signals WorkerSignals) (*EnhancedWorkerPool, error) <span class="cov0" title="0">{
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = runtime.NumCPU()
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        // 创建资源管理器和线程管理器
        resourceManager := NewResourceManager()
        threadManager := NewThreadManager(resourceManager)

        // 创建任务监控器
        taskMonitor := NewTaskMonitor(logger)

        pool, err := ants.NewPool(maxWorkers, ants.WithOptions(ants.Options{
                ExpiryDuration:   time.Minute * 10,
                PreAlloc:         true,
                MaxBlockingTasks: maxWorkers * 2,
                Nonblocking:      true, // 修改为非阻塞模式，避免死锁
        }))
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("创建工作器池失败: %w", err)
        }</span>

        // 创建错误处理器
        <span class="cov0" title="0">errorHandler := NewErrorHandler(logger)

        wp := &amp;EnhancedWorkerPool{
                pool:            pool,
                logger:          logger,
                errorHandler:    errorHandler,
                ctx:             ctx,
                cancel:          cancel,
                signals:         signals,
                threadManager:   threadManager,
                resourceManager: resourceManager,
                taskMonitor:     taskMonitor,
                maxWorkers:      maxWorkers,
                taskTimeout:     time.Minute * 30,
                cleanupInterval: time.Minute * 5,
                tempFiles:       make(map[string][]string),
        }

        // 启动任务监控器
        if err := taskMonitor.Start(); err != nil </span><span class="cov0" title="0">{
                cancel()
                pool.Release()
                return nil, fmt.Errorf("启动任务监控器失败: %w", err)
        }</span>

        // 启动清理协程
        <span class="cov0" title="0">wp.startCleanupRoutine()

        return wp, nil</span>
}

// ConfigureForBatch 为批处理配置工作器池
func (wp *EnhancedWorkerPool) ConfigureForBatch(itemCount int, format string, effort int, lossless bool) <span class="cov0" title="0">{
        wp.threadManager.Configure(itemCount, wp.maxWorkers, format, effort, lossless)
        // 工作器池已配置
}</span>

// SubmitTask 提交任务到工作器池
func (wp *EnhancedWorkerPool) SubmitTask(task *WorkerTask) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-wp.ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("工作器池已关闭")</span>
        default:<span class="cov0" title="0"></span>
        }

        // 直接提交任务，利用ants池的非阻塞特性
        <span class="cov0" title="0">return wp.pool.Submit(func() </span><span class="cov0" title="0">{
                wp.executeTask(task)
        }</span>)
}

// SubmitTaskWithIndex 提交带索引的任务，支持智能线程分配
func (wp *EnhancedWorkerPool) SubmitTaskWithIndex(task *WorkerTask, index int) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-wp.ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("工作器池已关闭")</span>
        default:<span class="cov0" title="0"></span>
        }

        // 获取该任务的可用线程数
        <span class="cov0" title="0">availableThreads := wp.threadManager.GetAvailableThreads(index)
        task.Settings.Threads = availableThreads

        // 直接提交任务，利用ants池的非阻塞特性
        return wp.pool.Submit(func() </span><span class="cov0" title="0">{
                wp.executeTask(task)
        }</span>)
}

// executeTask 执行任务，借鉴xl-converter的run方法结构
func (wp *EnhancedWorkerPool) executeTask(task *WorkerTask) <span class="cov0" title="0">{
        atomic.AddInt32(&amp;wp.activeWorkers, 1)
        defer func() </span><span class="cov0" title="0">{
                atomic.AddInt32(&amp;wp.activeWorkers, -1)
                // 处理panic恢复
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        wp.logger.Error("任务执行发生panic",
                                zap.Int("worker_id", task.ID),
                                zap.String("file", task.File.Path),
                                zap.Any("panic", r))
                        atomic.AddInt64(&amp;wp.failedTasks, 1)
                        if wp.signals != nil </span><span class="cov0" title="0">{
                                wp.signals.OnFailed(task.ID, task.File, fmt.Errorf("panic: %v", r))
                        }</span>
                }
                // 更新资源管理器的线程使用计数
                <span class="cov0" title="0">wp.resourceManager.SetUsedThreadCount(wp.pool.Running())</span>
        }()

        <span class="cov0" title="0">task.StartTime = time.Now()
        // 检查取消信号
        select </span>{
        case &lt;-wp.ctx.Done():<span class="cov0" title="0">
                wp.handleTaskCancellation(task)
                return</span>
        case &lt;-task.Ctx.Done():<span class="cov0" title="0">
                wp.handleTaskCancellation(task)
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        // 通知任务开始
        <span class="cov0" title="0">if wp.signals != nil </span><span class="cov0" title="0">{
                wp.signals.OnStarted(task.ID, task.File)
        }</span>

        // 注册任务到监控器并更新状态为运行中 - 优化字符串转换
        <span class="cov0" title="0">taskIDStr := strconv.Itoa(task.ID)
        wp.taskMonitor.RegisterTask(taskIDStr, task.File.Path, task.File.Size, PriorityNormal)
        wp.taskMonitor.UpdateTaskState(taskIDStr, TaskStateRunning)

        // 检查资源管理器是否需要优化
        if wp.resourceManager.IsEnabled() &amp;&amp; wp.resourceManager.IsNecessary(task.Params.Format, task.Params.Effort, task.Params.Lossless) </span>{<span class="cov0" title="0">
                // 资源优化已启用
        }</span>

        // 工作器开始处理任务

        // 执行任务的主要逻辑
        <span class="cov0" title="0">result := wp.runTaskWithTimeout(task)

        // 处理结果
        if result.Error != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;wp.failedTasks, 1)
                // 更新任务状态为失败
                taskIDStr := strconv.Itoa(task.ID)
                wp.taskMonitor.UpdateTaskState(taskIDStr, TaskStateFailed, result.Error.Error())
                if wp.signals != nil </span><span class="cov0" title="0">{
                        wp.signals.OnFailed(task.ID, task.File, result.Error)
                }</span>
                <span class="cov0" title="0">wp.logger.Error("任务执行失败",
                        zap.Int("worker_id", task.ID),
                        zap.String("file", task.File.Path),
                        zap.Error(result.Error))</span>
        } else<span class="cov0" title="0"> {
                atomic.AddInt64(&amp;wp.completedTasks, 1)
                // 更新任务状态为完成
                taskIDStr := strconv.Itoa(task.ID)
                wp.taskMonitor.UpdateTaskState(taskIDStr, TaskStateCompleted)
                if wp.signals != nil </span><span class="cov0" title="0">{
                        wp.signals.OnCompleted(task.ID, task.File, result)
                }</span>
                // 任务执行成功
        }

        // 清理临时文件
        <span class="cov0" title="0">wp.cleanupTaskTempFiles(strconv.Itoa(task.ID))</span>
}

// runTaskWithTimeout 带超时的任务执行
func (wp *EnhancedWorkerPool) runTaskWithTimeout(task *WorkerTask) *ConversionResult <span class="cov0" title="0">{
        resultChan := make(chan *ConversionResult, 1)
        timeoutCtx, cancel := context.WithTimeout(task.Ctx, wp.taskTimeout)
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                result := wp.runTask(task)
                select </span>{
                case resultChan &lt;- result:<span class="cov0" title="0"></span>
                case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                        // 超时，清理资源
                        wp.cleanupTaskTempFiles(strconv.FormatUint(uint64(task.ID), 10))</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case result := &lt;-resultChan:<span class="cov0" title="0">
                return result</span>
        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                var timeoutBuilder strings.Builder
                timeoutBuilder.WriteString("任务执行超时: ")
                timeoutBuilder.WriteString(task.File.Path)
                timeoutMsg := timeoutBuilder.String()
                return &amp;ConversionResult{
                        OriginalFile: task.File,
                        Success:      false,
                        Error:        fmt.Errorf("%s", timeoutMsg),
                        Skipped:      true,
                        SkipReason:   timeoutMsg,
                        Method:       "enhanced_worker",
                }</span>
        }
}

// runTask 执行具体的转换任务，借鉴xl-converter的工作流程
func (wp *EnhancedWorkerPool) runTask(task *WorkerTask) *ConversionResult <span class="cov0" title="0">{
        startTime := time.Now()
        result := &amp;ConversionResult{
                OriginalFile: task.File,
                OriginalSize: task.File.Size,
                OutputPath:   task.OutputPath,
                Method:       "enhanced_worker",
        }

        // 使用错误处理器执行转换任务
        err := wp.errorHandler.RetryWithBackoff(func() error </span><span class="cov0" title="0">{
                // 检查任务是否被取消
                select </span>{
                case &lt;-task.Ctx.Done():<span class="cov0" title="0">
                        return task.Ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // 阶段1: 运行检查 (借鉴xl-converter的runChecks)
                <span class="cov0" title="0">if err := wp.runChecks(task); err != nil </span><span class="cov0" title="0">{
                        var precheckBuilder strings.Builder
                        precheckBuilder.WriteString("预检查失败: ")
                        precheckBuilder.WriteString(err.Error())
                        return wp.errorHandler.WrapErrorWithType(
                                ErrorTypeFileOperation,
                                SeverityMedium,
                                "file_validation",
                                precheckBuilder.String(),
                                err,
                        )
                }</span>

                // 如果需要跳过
                <span class="cov0" title="0">if task.Skip </span><span class="cov0" title="0">{
                        result.Success = true
                        result.Skipped = true
                        result.SkipReason = "文件已存在，跳过处理"
                        return nil
                }</span>

                // 阶段2: 设置转换 (借鉴xl-converter的setupConversion)
                <span class="cov0" title="0">if err := wp.setupConversion(task); err != nil </span><span class="cov0" title="0">{
                        var setupBuilder strings.Builder
                        setupBuilder.WriteString("设置转换失败: ")
                        setupBuilder.WriteString(err.Error())
                        return wp.errorHandler.WrapErrorWithType(
                                ErrorTypeConversion,
                                SeverityMedium,
                                "conversion_setup",
                                setupBuilder.String(),
                                err,
                        )
                }</span>

                // 阶段3: 执行转换 (借鉴xl-converter的convert)
                <span class="cov0" title="0">if err := wp.performConversion(task, result); err != nil </span><span class="cov0" title="0">{
                        var conversionBuilder strings.Builder
                        conversionBuilder.WriteString("转换失败: ")
                        conversionBuilder.WriteString(err.Error())
                        return wp.errorHandler.WrapErrorWithType(
                                ErrorTypeConversion,
                                SeverityHigh,
                                "file_conversion",
                                conversionBuilder.String(),
                                err,
                        )
                }</span>

                // 阶段4: 完成转换 (借鉴xl-converter的finishConversion)
                <span class="cov0" title="0">if err := wp.finishConversion(task, result); err != nil </span><span class="cov0" title="0">{
                        var builder strings.Builder
                        builder.WriteString("完成转换失败: ")
                        builder.WriteString(err.Error())
                        return wp.errorHandler.WrapErrorWithType(
                                ErrorTypeFileOperation,
                                SeverityMedium,
                                "conversion_finish",
                                builder.String(),
                                err,
                        )
                }</span>

                // 阶段5: 后处理 (借鉴xl-converter的postConversionRoutines)
                <span class="cov0" title="0">if err := wp.postConversionRoutines(task, result); err != nil </span><span class="cov0" title="0">{
                        var builder strings.Builder
                        builder.WriteString("后处理失败: ")
                        builder.WriteString(err.Error())
                        return wp.errorHandler.WrapErrorWithType(
                                ErrorTypeFileOperation,
                                SeverityLow,
                                "post_processing",
                                builder.String(),
                                err,
                        )
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, ErrorTypeConversion, "file_conversion")

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Error = err
                result.Duration = time.Since(startTime)

                // 检查是否是特定类型的错误
                if pixlyErr, ok := err.(*PixlyError); ok </span><span class="cov0" title="0">{
                        if pixlyErr.Type == ErrorTypeFileOperation </span><span class="cov0" title="0">{
                                result.Skipped = true
                                result.SkipReason = pixlyErr.Message
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov0" title="0">result.Success = true
        result.Duration = time.Since(startTime)
        result.CompressedSize = result.OriginalSize // 模拟压缩后大小
        if result.OriginalSize &gt; 0 </span><span class="cov0" title="0">{
                result.CompressionRatio = float64(result.CompressedSize) / float64(result.OriginalSize)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// runChecks 运行预检查，借鉴xl-converter的runChecks方法
func (wp *EnhancedWorkerPool) runChecks(task *WorkerTask) error <span class="cov0" title="0">{
        // 检查文件是否存在
        if task.File == nil || task.File.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("无效的文件路径")
        }</span>

        // 检查文件是否可读
        <span class="cov0" title="0">if _, err := os.Stat(task.File.Path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("文件不存在: %s", task.File.Path)
        }</span>

        // 检查是否需要跳过
        <span class="cov0" title="0">if task.Params != nil </span>{<span class="cov0" title="0">
                // 这里可以添加更多的跳过逻辑
                // 例如：如果输出文件已存在且设置为跳过
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupConversion 设置转换参数，借鉴xl-converter的setupConversion方法
func (wp *EnhancedWorkerPool) setupConversion(task *WorkerTask) error <span class="cov0" title="0">{
        // 设置输出路径
        if task.OutputPath == "" </span><span class="cov0" title="0">{
                // 根据格式生成输出路径
                outputExt := wp.getOutputExtension(task.Params.Format)
                task.OutputPath = wp.generateOutputPath(task.File.Path, outputExt)
        }</span>

        // 初始化临时文件列表
        <span class="cov0" title="0">task.TempFiles = make([]string, 0)

        // 获取源文件时间戳
        if task.Params.KeepTimestamps </span><span class="cov0" title="0">{
                // 这里可以添加时间戳提取逻辑
                task.SrcTimestamps = NewTimestampMap[any]()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performConversion 执行转换，使用实际的Converter实例
func (wp *EnhancedWorkerPool) performConversion(task *WorkerTask, result *ConversionResult) error <span class="cov0" title="0">{
        // 注意：实际转换逻辑应该在调用此方法之前完成
        // 这里只是一个占位符，实际的转换应该通过Converter实例进行
        // WorkerPool主要负责任务调度和并发管理

        // 如果需要在这里执行转换，需要传入Converter实例
        // 目前这个方法主要用于任务状态管理
        result.Success = true
        result.OutputPath = task.OutputPath
        return nil
}</span>

// finishConversion 完成转换，借鉴xl-converter的finishConversion方法
func (wp *EnhancedWorkerPool) finishConversion(task *WorkerTask, result *ConversionResult) error <span class="cov0" title="0">{
        // 验证输出文件
        if task.OutputPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("输出路径为空")
        }</span>

        // 检查输出文件是否存在
        // 这里可以添加文件验证逻辑

        // 应用元数据
        <span class="cov0" title="0">if task.Params.KeepMetadata </span>{<span class="cov0" title="0">
                // 这里可以添加元数据处理逻辑
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// postConversionRoutines 后处理例程，借鉴xl-converter的postConversionRoutines方法
func (wp *EnhancedWorkerPool) postConversionRoutines(task *WorkerTask, result *ConversionResult) error <span class="cov0" title="0">{
        // 保留时间戳
        if task.Params.KeepTimestamps &amp;&amp; task.SrcTimestamps.Len() &gt; 0 </span>{<span class="cov0" title="0">
                // 这里可以添加时间戳恢复逻辑
        }</span>

        // 清理临时文件
        <span class="cov0" title="0">for _, tempFile := range task.TempFiles </span><span class="cov0" title="0">{
                wp.addTempFile(strconv.Itoa(task.ID), tempFile)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// 注意：实际转换逻辑在 Converter 类型中实现，这里不需要重复实现

// 辅助方法
func (wp *EnhancedWorkerPool) getOutputExtension(format string) string <span class="cov0" title="0">{
        switch format </span>{
        case "JPEG XL":<span class="cov0" title="0">
                return ".jxl"</span>
        case "AVIF":<span class="cov0" title="0">
                return ".avif"</span>
        case "JPEG":<span class="cov0" title="0">
                return ".jpg"</span>
        case "WebP":<span class="cov0" title="0">
                return ".webp"</span>
        case "PNG":<span class="cov0" title="0">
                return ".png"</span>
        default:<span class="cov0" title="0">
                return ".out"</span>
        }
}

func (wp *EnhancedWorkerPool) generateOutputPath(inputPath, extension string) string <span class="cov0" title="0">{
        // 输出路径生成逻辑在 Converter.getOutputPath 中实现
        base := inputPath[:len(inputPath)-len(filepath.Ext(inputPath))]
        return base + extension
}</span>

// handleTaskCancellation 处理任务取消
func (wp *EnhancedWorkerPool) handleTaskCancellation(task *WorkerTask) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;wp.canceledTasks, 1)
        task.Canceled = true

        if wp.signals != nil </span><span class="cov0" title="0">{
                wp.signals.OnCanceled(task.ID, task.File)
        }</span>

        // 任务被取消

        // 清理临时文件
        <span class="cov0" title="0">wp.cleanupTaskTempFiles(strconv.Itoa(task.ID))</span>
}

// 临时文件管理
func (wp *EnhancedWorkerPool) addTempFile(workerID, filePath string) <span class="cov0" title="0">{
        wp.tempFilesMutex.Lock()
        defer wp.tempFilesMutex.Unlock()

        if wp.tempFiles[workerID] == nil </span><span class="cov0" title="0">{
                wp.tempFiles[workerID] = make([]string, 0)
        }</span>
        <span class="cov0" title="0">wp.tempFiles[workerID] = append(wp.tempFiles[workerID], filePath)</span>
}

func (wp *EnhancedWorkerPool) cleanupTaskTempFiles(workerID string) <span class="cov0" title="0">{
        wp.tempFilesMutex.Lock()
        files := wp.tempFiles[workerID]
        delete(wp.tempFiles, workerID)
        wp.tempFilesMutex.Unlock()

        for _, file := range files </span><span class="cov0" title="0">{
                if err := wp.removeTempFile(file); err != nil </span><span class="cov0" title="0">{
                        wp.logger.Warn("清理临时文件失败",
                                zap.String("file", file),
                                zap.Error(err))
                }</span>
        }
}

func (wp *EnhancedWorkerPool) removeTempFile(filePath string) error <span class="cov0" title="0">{
        if filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("empty file path provided")
        }</span>

        // 检查文件是否存在
        <span class="cov0" title="0">if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // 临时文件已删除或不存在
                return nil
        }</span>

        // 安全删除文件
        <span class="cov0" title="0">if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                wp.logger.Error("Failed to remove temp file",
                        zap.String("file", filePath),
                        zap.Error(err))
                return fmt.Errorf("failed to remove temp file %s: %w", filePath, err)
        }</span>

        // 成功删除临时文件
        <span class="cov0" title="0">return nil</span>
}

// startCleanupRoutine 启动清理协程
func (wp *EnhancedWorkerPool) startCleanupRoutine() <span class="cov0" title="0">{
        wp.cleanupTicker = time.NewTicker(wp.cleanupInterval)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-wp.cleanupTicker.C:<span class="cov0" title="0">
                                wp.performCleanup()</span>
                        case &lt;-wp.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (wp *EnhancedWorkerPool) performCleanup() <span class="cov0" title="0">{
        // 清理过期的临时文件
        wp.tempFilesMutex.RLock()
        workerIDs := make([]string, 0, len(wp.tempFiles))
        for workerID := range wp.tempFiles </span><span class="cov0" title="0">{
                workerIDs = append(workerIDs, workerID)
        }</span>
        <span class="cov0" title="0">wp.tempFilesMutex.RUnlock()

        for _, workerID := range workerIDs </span><span class="cov0" title="0">{
                // 这里可以添加更智能的清理逻辑
                // 例如：只清理超过一定时间的临时文件
                wp.cleanupTaskTempFiles(workerID)
        }</span>
}

// GetPoolMetrics 获取工作器池的实时统计信息
func (ewp *EnhancedWorkerPool) GetPoolMetrics() *PoolMetrics <span class="cov0" title="0">{
        ewp.mutex.RLock()
        defer ewp.mutex.RUnlock()

        // 从任务监控器获取详细指标
        monitorMetrics := ewp.taskMonitor.GetMetrics()

        return &amp;PoolMetrics{
                ActiveWorkers:   int32(ewp.pool.Running()),
                QueuedTasks:     int32(ewp.pool.Waiting()),
                CompletedTasks:  ewp.completedTasks,
                FailedTasks:     ewp.failedTasks,
                TotalTasks:      ewp.completedTasks + ewp.failedTasks + ewp.canceledTasks,
                AverageWaitTime: monitorMetrics.AverageWaitTime,
                AverageExecTime: monitorMetrics.AverageProcessingTime,
                LastUpdate:      time.Now(),
        }
}</span>

// GetResourceManager 获取资源管理器
func (wp *EnhancedWorkerPool) GetResourceManager() *ResourceManager <span class="cov0" title="0">{
        return wp.resourceManager
}</span>

// GetThreadManager 获取线程管理器
func (wp *EnhancedWorkerPool) GetThreadManager() *ThreadManager <span class="cov0" title="0">{
        return wp.threadManager
}</span>

// GetTaskMonitor 获取任务监控器
func (wp *EnhancedWorkerPool) GetTaskMonitor() *TaskMonitor <span class="cov0" title="0">{
        return wp.taskMonitor
}</span>

// GetStats 获取统计信息
func (wp *EnhancedWorkerPool) GetStats() *PoolStats <span class="cov0" title="0">{
        return &amp;PoolStats{
                ActiveWorkers:  atomic.LoadInt32(&amp;wp.activeWorkers),
                CompletedTasks: atomic.LoadInt64(&amp;wp.completedTasks),
                FailedTasks:    atomic.LoadInt64(&amp;wp.failedTasks),
                CanceledTasks:  atomic.LoadInt64(&amp;wp.canceledTasks),
                PoolCapacity:   wp.pool.Cap(),
                PoolRunning:    wp.pool.Running(),
                PoolFree:       wp.pool.Free(),
        }
}</span>

// GetStatsMap 获取统计信息的map版本（向后兼容）
func (wp *EnhancedWorkerPool) GetStatsMap() map[string]interface{} <span class="cov0" title="0">{
        stats := wp.GetStats()
        return map[string]interface{}{
                "active_workers":  stats.ActiveWorkers,
                "completed_tasks": stats.CompletedTasks,
                "failed_tasks":    stats.FailedTasks,
                "canceled_tasks":  stats.CanceledTasks,
                "pool_capacity":   stats.PoolCapacity,
                "pool_running":    stats.PoolRunning,
                "pool_free":       stats.PoolFree,
        }
}</span>

// Close 关闭工作器池
func (wp *EnhancedWorkerPool) Close() error <span class="cov0" title="0">{
        wp.cancel()

        if wp.cleanupTicker != nil </span><span class="cov0" title="0">{
                wp.cleanupTicker.Stop()
        }</span>

        // 停止任务监控器
        <span class="cov0" title="0">wp.taskMonitor.Stop()

        // 清理所有临时文件
        wp.tempFilesMutex.Lock()
        for workerID := range wp.tempFiles </span><span class="cov0" title="0">{
                wp.cleanupTaskTempFiles(workerID)
        }</span>
        <span class="cov0" title="0">wp.tempFilesMutex.Unlock()

        wp.pool.Release()
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
